---
title: 整数快速算法：快速幂&矩阵快速幂总结
comments: true
mathjax: true
toc: true
tocnumber: true
music: false
image: 'kuaisumi.jpg'
abbrlink: 32ad2daa
date: 2019-03-01 14:10:02
tags:
  - 算法笔记
  - 快速幂
  - 矩阵快速幂
categories: 
  - 编程开发
  - 算法学习
description: '快速幂&矩阵快速幂总结'
---



### 快速幂

第一次遇到快速幂是在做杭电题`HDU2034 人见人爱A^B`，求A^B的最后三位数表示的整数。看到题目的第一反应是用`高精度`来求，最后去后三位，反正`高精度`写的非常熟练了，几十行代码写完之后发现本题数据其实并不大，是一道水题而已，于是写了个很水的循环取余，后来就在评论区知道了`快速幂`这么个快速算法。

```c++
typedef long long ll;  
ll mod_pow(ll x, ll n, ll mod){  
	ll res = 1;  
	while( n > 0 ){   
		if( n & 1 ) res = res * x % mod;    //n&1 即 n%2  
		x = x * x % mod;  
		n >>= 1;                 //n >>= 1 即 n/=2  
	}  
	return res;  
}  
```

​           

### 矩阵快速幂

刷北邮复试机考题遇到了一道板子题，直接套上就可以了，顺便总结一下这个知识点。

 >给定一个n*n的矩阵，求该矩阵的k次幂，即P^k。

* 题目地址：[矩阵幂](https://www.nowcoder.com/practice/31e539ab08f949a8bece2a7503e9319a?tpId=67&tqId=29638&tPage=1&ru=%2Fkaoyan%2Fretest%2F1005&qru=%2Fta%2Fbupt-kaoyan%2Fquestion-ranking)

AC代码：

```c++
#include <iostream>
#include <cstdio>
#include <string>
#include <cstring>
using namespace std;
const int MAXN = 15;
const int MOD = 1e8;

struct node
{
    int mat[MAXN][MAXN]; //矩阵
    int row, col;
    void init(){ //初始化為單位矩陣
        memset(mat, 0, sizeof(mat));
        for (int i = 0; i < row; i++){
            for (int j = 0; j < col; j++){
                mat[i][j] = (i==j);
            }
        }
    }
};

node mod_mul(node a, node b, int p) //矩阵乘法
{
    node ans;
    ans.row = a.row;
    ans.col = b.col;
    memset(ans.mat, 0, sizeof(ans.mat));
    for (int i = 0; i < ans.row; i++)
        for (int j = 0; j < ans.col; j++)
            for (int k = 0; k < a.col; k++)
            {
                ans.mat[i][j] += a.mat[i][k] * b.mat[k][j];
                ans.mat[i][j] %= p;
            }
    return ans;
}

node mod_pow(node a, int k, int p) //矩陣快速冪
{
    node ans;
    ans.row = a.row;
    ans.col = a.col;
    ans.init();
    while (k){
        if (k & 1) 
            ans = mod_mul(ans, a, p);
        a = mod_mul(a, a, p);
        k >>= 1;
    }
    return ans;
}

int main()
{
    node m;
    int n, k;
    while (scanf("%d%d", &n, &k)!=EOF)
    {
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++){
                scanf("%d", &m.mat[i][j]);
                m.mat[i][j] %= MOD;
            }  
        m.col = m.row = n;
        node ans = mod_pow(m, k, MOD);
        for (int i = 0; i < n; i++)
        {
            for (int j = 0; j < n; j++)
            {
                if (j != 0)
                    printf(" ");
                printf("%d", ans.mat[i][j]);
            }
            printf("\n");
        }
    }
    return 0;
}
```

