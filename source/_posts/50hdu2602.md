---
title: 【动态规划-0-1背包】HDU 2602 Bone Collector
comments: true
mathjax: true
toc: true
tags:
  - OJ
  - hdu
  - 动态规划
categories: OJ
abbrlink: b0fea3aa
date: 2019-01-23 20:58:25
---

> 一位骨头收集者有一个体积为V的背包，不同的骨头有不同的价值和体积，现在考虑到每块骨头的价值及体积，计算出能收集的骨头最大的价值。

<!-- more -->

​         

- 题目地址：http://acm.hdu.edu.cn/showproblem.php?pid=2602

​         

## 思路

0-1背包常规题

本题属于简单的0-1背包，但是前面的细节限制很容易出错：

- 只有A，B，C三种类型的发票，如测试数据一中的X发票就不报销
- 物品单项的报销额不超过600，如测试数据一第三张发票两个A类需要累加后计算
- 每张发票总额不超过1000

除了限制条件外，还有一些需要处理的点：

- 报销额都为保留两位小数的浮点数，遍历起来不方便，可以采取都乘100，最后结果除100的方式来处理。
- 数据输入处理很麻烦，可以用%*c来过滤空格

解决完这些问题，剩下就是0-1背包了。

​       



## AC代码

```c++


#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
using namespace std;

const int MAXN = 1005;

int dp[MAXN];

struct node{
    int a;
    int b;
} bone[MAXN];

int main(){
    int T;
    scanf("%d", &T);
    while(T--){
        int N, V;
        scanf("%d%d", &N, &V);
        for (int i = 0; i < N; i++){
            scanf("%d", &bone[i].a);
        }
        for (int i = 0; i < N; i++){
            scanf("%d", &bone[i].b);
        }
        memset(dp, 0, sizeof(dp));
        for (int i = 0; i < N; i++){
            for (int j = V; j >= bone[i].b; j--){
                dp[j] = max(dp[j], dp[j - bone[i].b] + bone[i].a);
            }
        }
        printf("%d\n", dp[V]);
    }
    return 0;
}
```

