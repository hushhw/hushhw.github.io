---
title: 【动态规划-0-1背包】HDU 2955 Robberies
comments: true
mathjax: true
toc: true
tocnumber: true
tags:
  - OJ
  - hdu
  - 动态规划
categories: 
  - OJ
abbrlink: b883e502
date: 2019-01-23 15:25:34
---

> 有一个小偷要偷银行的钱，可是他偷每家银行总是有一定的概率被抓，现在给了你一个概率P，只要他被抓的概率乘积不大与P，他就是安全的。问你在他安全的情况下，他最多可以偷多少钱。
>
> 首先给定一个数T，表示的是有T组数据，每组数据首先给出一个小数p和一个整数n，分别表示的是最大的能够被抓住的概率，如果>这个概率这个强盗的母亲就不让他去，然后下面有n行数据，每行有两个数，分别表示这个银行的钱数和被抓住的概率。

<!-- more -->

​         

- 题目地址：http://acm.hdu.edu.cn/showproblem.php?pid=2955

​         

## 思路

典型的0-1背包问题

本题特殊点在于浮点数不好遍历，于是转成所有银行的总资产为背包容量V，求最大的逃跑概率。

题目中给的是被抓的概率，所以求逃跑概率为`1-p[i]`。

状态转移方程：`dp[j] = max(dp[j], dp[j - bank[i].Mj] * bank[i].Pj)`。





## AC代码

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
#include <algorithm>
using namespace std;

const int MAXN = 1e4 + 5;

double dp[MAXN];

struct node{
    int Mj;
    double Pj;
} bank[105];

int main(){
    int T;
    scanf("%d", &T);
    while(T--){
        int n, sum;
        double p;
        scanf("%lf%d", &p, &n);
        p = 1.0 - p;
        sum = 0;
        for (int i = 0; i < n; i++){
            scanf("%d%lf", &bank[i].Mj, &bank[i].Pj);
            bank[i].Pj = 1.0 - bank[i].Pj;
            sum += bank[i].Mj;
        }
        memset(dp, 0, sizeof(dp));
        dp[0] = 1;
        for (int i = 0; i < n; i++){
            for (int j = sum; j >= bank[i].Mj; j--){
                dp[j] = max(dp[j], dp[j - bank[i].Mj] * bank[i].Pj);
            }
        }
        for (int i = sum; i >= 0; i--){
            if(dp[i]-p>0.000000001){
                printf("%d\n", i);
                break;
            }
        }
    }
    return 0;
}
```

