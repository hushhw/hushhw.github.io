---
title: 错排公式的推导及应用
date: 2018-02-07 23:06:32
tags: [算法笔记, 错排公式]
categories: 学习
---

之前就遇到过错排公式的题，但是自己没有注意这个知识点，以为只要硬记住就好啦，结果就是不知道推导过程完全记不住呀，所以今天认真整理一下错排公式相关的点。

<!--more-->

# 错排公式的推导

考虑一个有n个元素的排列，若一个排列中所有的元素都不在自己原来的位置上，那么这样的排列就称为原排列的一个错排，n个元素的错排记为D(n)。下面就是求出D(n)为多少中排列。

首先我们拿第一个元素的放置来理解一下这个过程：把元素1放在除自己原来的位置以外的位置，共有(n-1)种，假设第一个元素被放在了第k个元素的位置上，对第k个元素而言就有两种情况要讨论了，第一种，它放在非第一个位置上，所以对于接下来的排列就相当于是n-1个元素的错排，即D(n-1)；第二种，它就放在第1个元素的位置上，所以排列D(n)中有两个元素已经找到位置了，那么接下来就只需要考虑n-2个元素的错排，即D(n-2)。由此，我们就可以写出**递推式对于D(n)都有D(n)=(n-1)*(D(n-1)+D(n-2))【特殊的情况 D(1)=0, D(2)=1】**。

下面通过这个递推关系进行推导：
为了运算方便，我们设D(n)=n!*N(n)，则有：
n!*N(n) = (n-1)*(n-2)!*N(n-2) + (n-1)*(n-1)!N(n-1); 对两边同时除以(n-1)!，可得：
n*N(n) = N(n-2)+(n-1)*N(n-1)，移项：
N(n) - N(n-1) = (N(n-2) - N(n-1))/n = -(1/n)(N(n-1) - N(n-2))，所以，由此可以推出
N(n-1) - N(n-2) = -(1/(n-1))(N(n-2) - N(n-3))
…… 
N(2) - N(1) = 1/2; 
由此，将每个式子相加得到：N(n) - N(1) = (1/2! - 1/3! + 1/4! - ……+((-1)^(n-1))/(n-1)! + (-1)^n/n!)
由于N(1) = 0，所以N(n) = (1/2! - 1/3! + 1/4! - …… +((-1)^(n-1))/(n-1)! + (-1)^n/n!)，于是可以得到：
错排公式**D(n) = n!(1/2! - 1/3! + 1/4! - …… +((-1)^(n-1))/(n-1)! + (-1)^n/n!)**。



# 错排公式的应用解题

## 【hdu2049】考新郎

> ## 题目描述
>  在一场盛大的集体婚礼中,为了使婚礼进行的丰富一些,司仪临时想出了有一个有意思的节目,叫做"考新郎",具体的操作是这样的:
> ## 输入
>  输入数据的第一行是一个整数C,表示测试实例的个数，然后是C行数据，每行包含两个整数N和M(1< M<=N<=20)
> ## 输出
>  对于每个测试实例，请输出一共有多少种发生这种情况的可能，每个实例的输出占一行。
> ## 示例输入
>  2
>  2 2
>  3 2

最开始做着题的时候就直接求解排列组合C(n,m)，没有考虑错排m个元素D(m)的问题，这里用上面的两种方法分别写出代码：

### 方法一：递推公式 D(n)=(n-1)*(D(n-1)+D(n-2)) [D(1)=0，D(2)=1]

```
#include <cstdio>
#include <iostream>
#include <cstring>
using namespace std;

long long f[22];  
void init()//错排  
{  
	f[1]=0;  
	f[2]=1;  
	for(int i=3;i<=20;i++)  
	{  
		f[i]=(i-1)*(f[i-1]+f[i-2]);  
	}  
	return ;  
}  

int c(int x, int y){  
	int n=x, m=y;
	int sum=1,a=1,b=1;  
	for(int i=1;i<=y;i++)  {  
		a*=n;  
		n--; 
		b*=m;  
		m--; 
	}  
	sum=a/b;  
	return sum;
}

int main(){  
	int N,M;  
	init();  
	while(scanf("%d%d",&N,&M)!=EOF)  
	{  
		
		cout<<c(N,M)*f[M]<<endl;  
	}  
	return 0;  
}   
```
### 方法二：通项公式 D(n)=n!*(1/2!-1/3!+1/4!- 1/5!+ ··· ··· +((-1)^(n-1))/(n-1)!+((-1)^n)/n! )

对通项先进行简单变形：
C(n,m)*D(m) = (n!/(m!*(n-m)!))*D(m) = n!*(1/2!-1/3!+1/4!- 1/5!+ ··· ··· +((-1)^(m-1))/(m-1)!+((-1)^m)/m! )/(n-m)!

```
#include <cstdio>
#include <iostream>
#include <cstring>
typedef long long ll;
using namespace std;

long long f[22];  


int c(int n){  
	ll sum=1;
	for(int i=1; i<=n; i++)
		sum*=i;
	return sum;
}

int main(){  
	int N,M;   
	while(scanf("%d%d",&N,&M)!=EOF)  
	{  
		ll a=c(N), sum=0, b=c(N-M);
		for(int i=2; i<=M; ++i){
			a/=i;
			if(i%2==0)
				sum+=a;
			else
				sum-=a;
		}
		cout<<sum/b<<endl;
	}  
	return 0;  
}   
```


> 本文内容参考自：
> http://blog.csdn.net/yangyuhao0408/article/details/50971170