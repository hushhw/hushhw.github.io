---
title: 从头开始学算法——动态规划
comments: true
mathjax: true
toc: true
abbrlink: 61022a09
date: 2019-01-20 18:53:09
tags:
  - 算法笔记
  - 动态规划
categories: learn
---

## 什么是动态规划

> **dynamic programming **is a method for solving a complex problem by breaking it down into a collection of simpler subproblems, solving each of those subproblems just once, and storing their solutions.



动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量： 一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。 这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。

**动态规划问题满足三大重要性质：**

1. **最优子结构性质：**如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。
2. **无后效性：**即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。
3. **子问题重叠性质：**子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。

对于动态规划的概念其实不好把握，最好的方式是在做题中去体会动态规划的思想。

## 简单基础DP

这类`dp`主要是问题比较常见，遇到这类题目可以直接在基础模板上变化即可，包括**递推、背包、LIS（最长递增序列），LCS（最长公共子序列）**

### 递推

经典的递推dp是`斐波那契数列`(Fibonacci sequence)，在求F(n)F(n)时，总会先求F(n−1)F(n−1)和F(n−2)F(n−2)，然后根据公式F(n)=F(n−1)+F(n−2)F(n)=F(n−1)+F(n−2)求出，例如我们在求出F(3)F(3)后，再求F(5)F(5)时就不必从头再推一遍而是直接调用。

* [【动态规划-递推】HDU 2044 一只小蜜蜂…](https://hushhw.cn/posts/OJ/ace523f9.html)
* [【动态规划-递推】HDU 2047 阿牛的EOF牛肉串](https://hushhw.cn/posts/OJ/f94672dd.html)
* [【动态规划-递推】HDU 2045 RPG难题](https://hushhw.cn/posts/OJ/1d8d1ae8.html)
* [【动态规划-递推】HDU 2046 骨牌铺方格](https://hushhw.cn/posts/OJ/482e4bcc.html)
* [【动态规划-递推】POJ 1664 放苹果](https://hushhw.cn/posts/OJ/d0e7bee4.html)

​       

### 背包

#### 0-1背包(每个物品最多只能放一次)

##### 题目
有N件物品和一个容量为V的背包。第i件物品的费用是c[i],价值是w[i]。求解将哪些物品装入背包可使价值总和最大

##### 思路

这是最基础的背包问题，特点是：每种物品只有一件，可以选择放或者不放

用子问题定义状态：即`dp[i][j]`表示前i件物品放入一个容量为j的背包可以获得的最大价值。则其状态转移方程为：

`dp[i][j] = max{dp[i - 1][j], dp[i - 1][j - c[i]] + w[i]}`

这个方程非常重要，基本上所有跟背包相关的问题的方程都是由它衍生出来。这里详细解释一下：

**将前i件物品放入容量为j的背包中**这个子问题，若只考虑第i件物品的策略（放或者不放），那么就可以转换为一个只牵扯前i-1件物品的问题。

* 如果不放第i件物品，那么问题就转换为前i-1件物品放入容量为j的背包中的最大价值，价值为`dp[i - 1][j]`
* 如果放入第i件物品，那么问题就转换为前i-1件物品放入容量为j-c[i]的背包中，此时能获得的最大价值是`dp[i-1][j-c[i]]`,再加上放入第i件物品获得的价值w[i]

##### 优化空间复杂度

先考虑一下上面的状态转移方程如何实现，肯定有一个主循环i = 1...N,每次算出来二维数组dp[i][0..V]的所有值。那么如果只用一个数组`f[0...V]`,能不能保证第i次循环结束后`f[v]`就是我们定义的状态`f[i][v]`呢？`f[i][v]`是由`f[i-1][v]`和`f[i-1][v-c[i]]`两个子问题递推而来，能否保证在推`f[i][v]`时（也即在第i次主循环中推f[v]时）能够得到`f[i-1][v]`和`f[i-1][v-c[i]]`的值呢？事实上，这要求在每次主循环中我们以v=V...0的顺序推f[v]，这样才能保证推f[v]时f[v-c[i]]保存的是状态`f[i-1][v-c[i]]`的值。伪代码如下：
```
for i  in 0 ... N
    for  v = V ... 0
        f[v] = max{f[v], f[v-c[i]] + w[i]}
```

##### 练习题目

* [【动态规划-0-1背包】HDU 2955 Robberies](https://hushhw.cn/posts/OJ/b883e502.html) 
* [【动态规划-0-1背包】HDU 1864 最大报销额](https://hushhw.cn/posts/OJ/44777a5c.html)

* [【动态规划-0-1背包】HDU 2602 Bone Collector](https://hushhw.cn/posts/OJ/b0fea3aa.html)
* [【动态规划-0-1背包】HDU 2639 Bone Collector II](https://hushhw.cn/posts/OJ/e729ac5b.html)

​           

#### 完全背包(每种物品可以放无限多次)

##### 题目

有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是c[i]，价值是w[i].

求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大

##### 思路

这个问题类似于0-1背包问题，所不同的是每种物品有无限件。也就是从每种物品的角度考虑，与它相关的策略已非取或不取两种，而且有取0件、取1件、取2件...等很多种。如果仍然按照0-1背包的思路，令`dp[i][v]`表示前i种物品恰好放入一个容量为v的背包的最大权值。仍然可以按照每种物品不同的策略写出状态转移方程：

```
dp[i][v] = max{dp[i-1][v - k * c[i]] + k * w[i] | 0 <= k * c[i]<= v}
```

转化为01背包求解
最简单的想法是：考虑到第i种物品最多选V/c[i]件，于是可以把第i种物品转换为V/c[i]件费用及价值均不变的物品，然后求解这个01背包问题。但是这样完全没有改进时间复杂度，但这毕竟给了我们将完全背包转换为01背包问题的思路：将一种物品拆成多件物品

##### O(VN)的算法

这个算法使用一维数组，先看伪代码：
```
for i = 1 ... N
    for v = 0 ... V
        f[v] = max{f[v], f[v-cost] + weight}
```
你会发现，这个伪代码与01背包的伪代码只有v的循环次序不同而已。为什么这样一改就行呢？首先，想想为什么01背包问题中要按照v=V...0的逆序来循环。这是因为要保证第i次循环中的状态f[i][v]是由状态`f[i-1][v-c[i]]`递推而来。换句话说，这正是为了保证每件物品只选一次，保证在考虑“选入第i件物品”这件策略时，依据的是一个绝无已经选入第i件物品的子结果`f[i-1][v-c[i]]`。而现在完全背包的特点恰好是每种物品可选无限件，所以在考虑“加选一件dii种物品”这种策略时，却正需要一个可能已选入第i种物品的子结果`f[i][c-v[i]]`,所以就可以并且必须采用v=0...V的顺序循环。这就是这个简单的程序为何成立的道理。

值得一提的是，上面的伪代码中两层for循环的次序可以颠倒。这个结论有可能会带来算法时间常数上的优化。

这个算法也可以以另外的思路得出。例如，将基本思路中求解f[i][v-c[i]]的状态转移方程显式地写出来，代入原方程中，会发现该方程可以等价地变形成这种形式：

`f[i][v]=max{f[i-1][v],f[i][v-c[i]]+w[i]}`

将这个方程用一维数组实现，便得到了上面的伪代码。

##### 练习题目

* [【动态规划-完全背包】HDU 2159 FATE](https://hushhw.cn/posts/OJ/2e53604.html)

​         

#### 多重背包(每种物品有一个固定的次数上限)

##### 题目

有N种物品和一个容量为V的背包。第i种物品最多有n[i]件，每件费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大

##### 思路

多重背包问题的思路跟完全背包的思路非常类似，只是k的取值是有限制的，因为每件物品的数量是有限制的，状态转移方程为：

```
dp[i][v] = max{dp[i - 1][v - k * c[i]] + w[i] | 0 <=k <= n[i]}
```

复杂度是`O(V*Σn[i])`。

##### 练习题目

* [【动态规划-多重背包】HDU 2844 Coins](https://hushhw.cn/posts/OJ/dab6998b.html)


​        

### LIS(最长递增子序列)

**最长递增子序列，朴素的是o(n^2)算法，二分下可以写成o(nlgn)：维护一个当前最优的递增序列——找到恰好大于它更新**

* [【动态规划-最大连续子序列】HDU 1003 Max Sum](https://hushhw.cn/posts/OJ/a996c21e.html)


​         

### LCS(最长公共子序列)

​          

​           

## 区间dp

 区间DP是一类在区间上进行动态规划的最优问题，一般是根据问题设出一个表示状态的dp，可以是二维的也可以是三维的，一般情况下为二维。然后将问题划分成两个子问题，也就是一段区间分成左右两个区间，然后将左右两个区间合并到整个区间，或者说局部最优解合并为全局最优解，然后得解。





> 本文参考自：
>
> https://en.wikipedia.org/wiki/Dynamic_programming
>
> https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92
>
> https://blog.csdn.net/cc_again/article/details/25866971
>
> https://blog.csdn.net/woshi250hua/article/details/7969225

