---
title: 从头开始学算法——动态规划
comments: true
mathjax: true
toc: true
abbrlink: 61022a09
date: 2019-01-20 18:53:09
tags:
  - 算法笔记
  - 动态规划
categories: learn
---

## 什么是动态规划

> **dynamic programming **is a method for solving a complex problem by breaking it down into a collection of simpler subproblems, solving each of those subproblems just once, and storing their solutions.



{% qnimg Snipaste_2019-01-20_22-10-44.png %}



动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量： 一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。 这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。

**动态规划问题满足三大重要性质：**

1. **最优子结构性质：**如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。
2. **无后效性：**即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。
3. **子问题重叠性质：**子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。

对于动态规划的概念其实不好把握，最好的方式是在做题中去体会动态规划的思想。

## 简单基础DP

这类`dp`主要是问题比较常见，遇到这类题目可以直接在基础模板上变化即可，包括**递推、背包、LIS（最长递增序列），LCS（最长公共子序列）**

### 递推

经典的递推dp是`斐波那契数列`(Fibonacci sequence)，在求F(n)F(n)时，总会先求F(n−1)F(n−1)和F(n−2)F(n−2)，然后根据公式F(n)=F(n−1)+F(n−2)F(n)=F(n−1)+F(n−2)求出，例如我们在求出F(3)F(3)后，再求F(5)F(5)时就不必从头再推一遍而是直接调用。

[【动态规划】HDU 2044 一只小蜜蜂…](http://localhost:4000/posts/OJ/ace523f9.html)

[【动态规划】HDU 2047 阿牛的EOF牛肉串](http://localhost:4000/posts/OJ/f94672dd.html)



> 本文参考自：
>
> https://en.wikipedia.org/wiki/Dynamic_programming
>
> https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92