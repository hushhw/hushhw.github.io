---
title: 树状数组和归并排序求逆序数
comments: true
mathjax: true
abbrlink: e5d88cfb
date: 2018-02-28 19:38:26
tags:
  - 算法笔记
  - 树状数组
  - 归并排序
categories: learn
toc: true
tocnumber: true
---

> 整理解决逆序数问题的方法
>
> 树状数组+归并排序求逆序数

<!--more-->

​        

## 树状数组

树状数组，具体的说是 离散化+树状数组。

算法的大体流程就是：

1. 先对输入的数组离散化，使得各个元素比较接近，而不是离散的
2. 接着，运用树状数组的标准操作来累计数组的逆序数。



算法详细解释：

1. 解释为什么要有离散的这么一个过程？

刚开始以为999.999.999这么一个数字，对于int存储类型来说是足够了。还有只有500000个数字，何必要离散化呢？刚开始一直想不通，后来明白了，后面在运用树状数组操作的时候，用到的树状数组C[i]是建立在一个有点像位存储的数组的基础之上的，不是单纯的建立在输入数组之上。

比如输入一个9 1 0 5 4，那么C[i]树状数组的建立是在，

​    下标 0 1 2 3 4 5 6 7 8 9

​    数组 1 1 0 0 1 1 0 0 0 1

现在由于999999999这个数字相对于500000这个数字来说是很大的，所以如果用数组位存储的话，那么需要999999999的空间来存储输入的数据。这样是很浪费空间的，题目也是不允许的，所以这里想通过离散化操作，使得离散化的结果可以更加的密集。



1. 怎么对这个输入的数组进行离散操作？

离散化是一种常用的技巧，有时数据范围太大，可以用来放缩到我们能处理的范围；因为其中需排序的数的范围0---999 999 999；显然数组不肯能这么大；而N的最大范围是500 000；故给出的数一定可以与1.。。。N建立一个一一映射；

   ①当然用map可以建立，效率可能低点；

   ②这里用一个结构体

   struct Node

   {

​      int v,ord;

   }p[510000];和一个数组a[510000];

   其中v就是原输入的值，ord是下标；然后对结构体按v从小到大排序；此时，v和结构体的下标就是一个一一对应关系，而且满足原来的大小关系；

   for(i=1;i<=N;i++) a[p[i].ord]=i;

然后a数组就存储了原来所有的大小信息；比如 9 1 0 5 4 ------- 离散后aa数组就是 5 2 1 4 3；具体的过程可以自己用笔写写就好了。



1. 离散之后，怎么使用离散后的结果数组来进行树状数组操作，计算出逆序数？

如果数据不是很大， 可以一个个插入到树状数组中，每插入一个数， 统计比他小的数的个数，对应的逆序为 i- getsum( aa[i] )，其中 i 为当前已经插入的数的个数，getsum( aa[i] ）为比 aa[i] 小的数的个数，i- sum( aa[i] ) 即比 aa[i] 大的个数， 即逆序的个数。

但如果数据比较大，就必须采用离散化方法。

假设输入的数组是9 1 0 5 4， 离散后的结果aa[] = {5,2,1,4,3};

在离散结果中间结果的基础上，那么其计算逆序数的过程是这么一个过程。

1. 输入5，   调用upDate(5, 1),把第5位设置为1

1 2 3 4 5

0 0 0 0 1

计算1-5上比5小的数字存在么？ 这里用到了树状数组的getSum（5） = 1操作，现在用输入的下标1 - getSum(5) = 0 就可以得到对于5的逆序数为0。

1. 输入2， 调用upDate(2, 1),把第2位设置为1

1 2 3 4 5

0 1 0 0 1

计算1-2上比2小的数字存在么？ 这里用到了树状数组的getSum（2） = 1操作，现在用输入的下标2 - getSum(2) = 1 就可以得到对于2的逆序数为1。

1. 输入1， 调用upDate(1, 1),把第1位设置为1

1 2 3 4 5

1 1 0 0 1

计算1-1上比1小的数字存在么？ 这里用到了树状数组的getSum（1） = 1操作，现在用输入的下标 3 - getSum(1) = 2 就可以得到对于1的逆序数为2。

1. 输入4， 调用upDate(4, 1),把第5位设置为1

1 2 3 4 5

1 1 0 1 1

计算1-4上比4小的数字存在么？ 这里用到了树状数组的getSum（4） = 3操作，现在用输入的下标4 - getSum(4) = 1 就可以得到对于4的逆序数为1。

1. 输入3， 调用upDate(3, 1),把第3位设置为1

1 2 3 4 5

1 1 1 1 1

计算1-3上比3小的数字存在么？ 这里用到了树状数组的getSum（3） = 3操作，现在用输入的下标5 - getSum(3) = 2 就可以得到对于3的逆序数为2。

1. 0+1+2+1+2 = 6 这就是最后的逆序数

分析一下时间复杂度，首先用到快速排序，时间复杂度为O(NlogN),

后面是循环插入每一个数字，每次插入一个数字，分别调用一次upData()和getSum()

外循环N, upData()和getSum()时间O(logN) => 时间复杂度还是O(NlogN).

最后总的还是O(NlogN).



```c++
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
using namespace std;

const int maxn = 500005;

int n;
int aa[maxn];	//离散后的数组
int c[maxn];	//树状数组

struct Node{
	int v;
	int order;
}in[maxn];

int lowbit(int x){
	return x&(-x);
	//求出2^p(其中p: x 的二进制表示数中， 右向左数第一个1的位置)
	//如6的二进制表示为110，向左数第零个为0，第一个为1，则p=1，故Lowbit(6) = 2^1 = 2。
}

bool cmp(Node a, Node b){
	return a.v<b.v;
}

void update(int t, int value){
	int i;
	for(i=t; i<=n; i+=lowbit(i))
		c[i]+=value;
}

int getsum(int x){
	int i;
	int temp = 0;
	for(i=x; i>=1; i-=lowbit(i))
		temp+=c[i];
	return temp;
}

int main(){
	int i, j;
	while(scanf("%d",&n)==1 && n){
		//离散化
		for(i=1; i<=n; i++){
			scanf("%d",&in[i].v);
			in[i].order=i;
		}
		sort(in+1, in+n+1, cmp);
		for(i=1; i<=n; i++)
			aa[in[i].order] = i;

		//树状数组求逆序
		long long ans = 0;
		memset(c, 0, sizeof(c));
		for(i=1; i<=n; i++){
			update(aa[i],1);
			ans += i-getsum(aa[i]);
		}
		cout<<ans<<endl;
	}
	return 0;
}
```



## 归并排序

对于一个数组{5，3，7，4，6，2，1，8}，如果我们以中间（或者左中）为界限将其分成两个数组，只要知道这两个数组中的逆序对数和两边的数所组成的逆序对数就是它所有的逆序对数了。而数组划分的递归结束点在两个数组都只有一个元素的时候，因此两数组中的逆序对数可以要去求分裂的两数组中的逆序对数可以这样去做：先将两数组按升序排序，若前一个数组的第一个元素比后一个的大，则说明前一组的后面所有都要比后一组的第一个元素大，这样将较小的第一个元素去掉后，继续比较两个数组的第一个元素可以把所有的逆序对找到。



```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
#define N 100000

using namespace std;

void merge(int arr[],int left,int mid,int right,int temp[],long long *count){
	int k = 0,i,j;
	i = left; j = mid+1;

	while((i<=mid) && (j<=right)){
		if(arr[i] <= arr[j]){
			temp[k++] = arr[i++];
		}
		else{
			temp[k++] = arr[j++];
			//ans+=e1-p1+1;
			(*count) = (*count) + mid - i + 1;
			//在归并排序的过程中，可以一步步来计算逆序数的值，由于归并排序的过程一直都是升序在排序，所以如果a[i]>a[j]的话，那么a[i]后面的数一定都大于a[j]，加上后面的数的个数；
		}
	}
	while(i<=mid)
		temp[k++] = arr[i++];
	while(j<=right)
		temp[k++] = arr[j++];

	for(int i=0;i<k;i++){
		arr[left+i] = temp[i];
	}
}

void mergeSort(int arr[],int left,int right,int temp[],long long *count){
	if(left<right){ // 递归出口
		int mid = (left+right)>>1;
		mergeSort(arr,left,mid,temp,count);
		mergeSort(arr,mid+1,right,temp,count);
		merge(arr,left,mid,right,temp,count);
	}
}
int main(){
	long long count = 0;
	int m = 0;
	cin>>m;
	int *a = new int[m];
	for(int i=0;i<m;i++){
		cin>>a[i];
	}

	int *temp = new int[m];
	mergeSort(a,0,m-1,temp,&count);
	delete []a;
	delete []temp;
	cout<<count;
	system("pause");
	return 0;
}
```



> 本文参考整理自：
>
> http://www.360doc.com/content/12/0925/21/9615799_238155264.shtml