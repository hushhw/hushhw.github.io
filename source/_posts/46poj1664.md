---
title: 【动态规划-递推】POJ 1664 放苹果
comments: true
mathjax: true
toc: true
tocnumber: true
abbrlink: d0e7bee4
date: 2019-01-21 16:50:02
tags:
  - OJ
  - poj
  - 动态规划
categories: OJ
---

> 把M个同样的苹果放在N个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？（用K表示）5，1，1和1，5，1 是同一种分法。
>
> 第一行是测试数据的数目t（0 <= t <= 20）。以下每行均包含二个整数M和N，以空格分开。1<=M，N<=10。
>
> 对输入的每组数据M和N，用一行输出相应的K。

<!-- more -->

- 题目地址：http://poj.org/problem?id=1664


​          


## 思路

又是一题思路超级重要的题。

M个相同的苹果放在N个同样的盘子里，允许有的盘子空着不放。

设f(m,n)为m个苹果，n个盘子的放法数目，先对n作讨论，

当n>m：则必定有n-m个盘子永远空着，去掉它们对摆放苹果方法数目不产生影响。即 if(n>m) f(m,n) = f(m,m)

当n <= m:不同的放法可以分成两类：含有0的方案数，不含有0的方案数

含有0的方案数，即有至少一个盘子空着，即相当于 f(m,n)=f(m,n-1);

不含有0的方案数，即所有的盘子都有苹果，相当于可以从每个盘子中拿掉一个苹果，不影响不同放法的数目，即 f(m,n)=f(m-n,n).

而总的放苹果的放法数目等于两者的和，即 f(m,n)=f(m,n-1)+f(m-n,n)



递归出口条件说明：

当n==1时，所有苹果都必须放在一个盘子里，所以返回1；

当m==0(没有苹果可放)时，定义为1种放法；

​        

## AC代码

```c++
#include <cstdio>  
#include <iostream>  
#include <cstring>  
using namespace std;  
int dp[1001][1001];  
  
int main()  
{  
    int n;  
    cin>>n;  
    while(n--)  
    {  
        int M,N;  
        cin>>M>>N;  
        memset(dp,0,sizeof(dp));  
        for(int i=0;i<=M;i++)  
        {  
            dp[i][0]=0;  
            dp[i][1]=1;  
        }  
        for(int i=0;i<=N;i++)  
            dp[0][i]=1;  
          
        for(int i=1;i<=M;i++)  
        {  
            for(int j=1;j<=N;j++)  
            {  
                if(i<j)  
                    dp[i][j]=dp[i][i];  
                else  
                    dp[i][j]=dp[i][j-1]+dp[i-j][j];  
            }  
        }  
        cout<<dp[M][N]<<endl;  
    }  
    return 0;  
}   
```

