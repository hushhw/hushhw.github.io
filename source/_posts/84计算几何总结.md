---
title: 计算几何简单总结
comments: true
mathjax: true
toc: true
tocnumber: true
music: false
image: false
abbrlink: 689f6bc0
date: 2019-03-18 09:18:37
tags:
  - 计算几何
  - 算法笔记
categories:
  - 编程开发
  - 算法学习
description: '最近要整理板子，所以都要涉及一点，计算几何这块从来没有总结过，简单的整理一下，后面有时间慢慢补充起来。'
---



> 最近要整理板子，所以都要涉及一点，计算几何这块从来没有总结过，简单的整理一下，后面有时间慢慢补充起来。



### 三角形的面积

这里介绍的是用`叉乘`求三角形面积的方法，两个响亮的向量集（叉乘）的模可以解释为以 a 和 b 为邻边的平行四边形的面积，故求三角形的面积为：$S = |\overrightarrow{AB} \times \overrightarrow{AC} | /2$ 。

```c++
struct Point{
    double x,y;
};

double getS(Point a,Point b,Point c) {  
    return ((b.x - a.x) * (c.y - a.y) - (b.y - a.y)*(c.x - a.x))/2;  
}
```



### 多边形的面积

求多边形面积最基础的方法就是用剖分法来做的，就是把多边形分成若干个三角形，然后对每个三角形求面积，求面积，在有精度要求的情况下，不要用海伦-秦九昭公式，海伦公式可能在精度损失方面会比较严重，而且计算量很大。



### 多边形的重心

重心的横坐标 = 多边形每一个三角形的重心的横坐标 \* 该三角形的权值（面积）/ 多边形总面积。
重心的纵坐标 = 多边形每一个三角形的重心的纵坐标 \* 该三角形的权值（面积）/ 多边形总面积。



### 举例

「[nyoj 3-多边形重心问题](http://nyoj.top/problem/3)」

```c++

//#include <bits/stdc++.h>
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <string>
#include <vector>
#include <queue>
#include <stack>
#include <map>
#include <set>
#include <algorithm>
#include <cmath>
#define For(i,m,n)  for(int i=m;i< n;i++)
#define FFor(i,m,n) for(int i=m;i<=n;i++)
#define bug(x) cout<<#x<<"="<<x<<endl;
#define INF 0x3f3f3f3f
#define Pi acos(-1.0) 
#define Pow(a,b) pow(a,b)
using namespace std;
typedef long long ll;

struct Point{
    double x,y;
};

double getS(Point a,Point b,Point c)    //返回三角形面积 
{  
    return ((b.x - a.x) * (c.y - a.y) - (b.y - a.y)*(c.x - a.x))/2;  
}

double getPS(Point p[],int n)    //返回多边形面积。必须确保 n>=3，且多边形是凸多边形 
{
    double sumS=0;
    FFor(i,2,n-1){
        sumS+=getS(p[1],p[i],p[i+1]);
    }
    return sumS;
}

Point getPZ(Point p[],int n)    //返回多边形重心
{
    Point z;
    double sumx = 0,sumy = 0;
    double sumS = 0;
    FFor(i,2,n-1){
        double S = getS(p[1],p[i],p[i+1]);
        sumS += S;
        sumx += (p[1].x+p[i].x+p[i+1].x)*S;
        sumy += (p[1].y+p[i].y+p[i+1].y)*S;
    }
    if(sumS==0){
        z.x = 0,z.y = 0;
        return z;
    }
    z.x = sumx / (sumS );
    z.y = sumy / (sumS );
    return z;
}

Point p[10005];

int main()
{
    int T;
    scanf("%d",&T);
    while(T--){
        int n;
        scanf("%d",&n);
        FFor(i,1,n)
            scanf("%lf%lf",&p[i].x,&p[i].y);
        Point z = getPZ(p,n);
        printf("%.3lf %.3lf\n",fabs(getPS(p,n)),(z.x+z.y)/3);
    }
    return 0;
}
```





