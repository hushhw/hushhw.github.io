<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="hushhw × Wiki"><meta name="google-site-verification"><meta name="baidu-site-verification"><title>全排列算法总结 | hushhw × Wiki</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-132675789-2','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '972cc0516975a00c2c5900eb5e98039d';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();

</script><script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.css" rel="stylesheet"><script>(function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0];if (curProtocol === 'https') {bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';} else {bp.src = 'http://push.zhanzhang.baidu.com/push.js';}var s = document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp, s);})();</script></head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-132675789-2"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());

gtag('config', 'UA-132675789-2');
</script><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">全排列算法总结</h1><a id="logo" href="/.">hushhw × Wiki</a><p class="description"></p></div><div id="nav-menu"><a href="/tech/"><i class="fa fa-battery-full"> 技术</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa fa-tag"> 标签</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"> <h1 class="post-title">全排列算法总结</h1><div class="post-meta">2019-03-18<script src="https://photo.hushhw.cn/busuanzi.pure.mini.js" async></script><span class="busuanzi_container_page_pv"> • <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> • </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 1,295</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> • <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 6</span><span class="post-meta-item-text"> 分钟</span></span></span></div><a class="disqus-comment-count" href="/posts/83505976.html#vcomment"><span class="valine-comment-count" data-xid="/posts/83505976.html"></span><span> 条评论</span></a><div class="post-content"><h2 id="全排列递归算法"><a href="#全排列递归算法" class="headerlink" title="全排列递归算法"></a>全排列递归算法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>求 n 位的字符串的全排列，先确定第 0 位，然后对后面 n-1 位进行全排列，在对 n-1 为进行全排列时，先确定第 1 位，然后对后面的 n-2 位进行全排列…由此得到递归函数和递归的结束条件。全排列也就是交换位置，到 n-2 位时，就是将 n-2 和 n-1 交换位置。</p>
<p>例如输入字符串<code>abc</code>，则打印出 a、b、c 所能排列出来的所有字符串 <code>abc</code>、<code>acb</code>、<code>bac</code>、<code>bca</code>、<code>cab</code> 和 <code>cba</code> 。具体过程如下：</p>
<ul>
<li>第一位是 a 固定，对后面的 bc 交换位置得 abc，acb；</li>
<li>当 a 和 b 交换位置之后，得到 bac，对 ac 进行全排列 bac，bca；</li>
<li>当 a 和 c 交换位置之后，得到 cba，对 ba 进行全排列得cba，cab。</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>于是我们根据这种思想写出第一个版本的算法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perm</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">list</span>, <span class="keyword">int</span> i, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j, temp;</span><br><span class="line">	<span class="keyword">if</span> (i == n) &#123;<span class="comment">//n表示字符串最后一位的下标</span></span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="built_in">list</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="keyword">for</span> (j = i; j &lt;= n; j++)&#123;</span><br><span class="line">        	swap(<span class="built_in">list</span>[i], <span class="built_in">list</span>[j], temp);</span><br><span class="line">        	<span class="comment">//交换位置后，输出以list[j]不变，后面的字母改变的所有排列</span></span><br><span class="line">        	perm(<span class="built_in">list</span>, i + <span class="number">1</span>, n);</span><br><span class="line">        	swap(<span class="built_in">list</span>[i], <span class="built_in">list</span>[j], temp);</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们实现基本的全排列的功能，但是这样我们并不能解决一种情况，即类似于<code>abb</code>去重的问题，<code>abb</code>这种交换后一样的情况在输出时会输出两个，于是我们需要对我们的算法进行改进，得到第二版的算法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSwap</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">list</span>, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt; end; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>[i] == <span class="built_in">list</span>[end])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perm</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">list</span>, <span class="keyword">int</span> i, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j, temp;</span><br><span class="line">    <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\t%s\n"</span>, <span class="built_in">list</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (isSwap(<span class="built_in">list</span>, i, j)) &#123;</span><br><span class="line">                swap(<span class="built_in">list</span>[i], <span class="built_in">list</span>[j], temp);</span><br><span class="line">                <span class="comment">//交互位置后，输出以list[j]不变，后面的字母改变的所有排列</span></span><br><span class="line">                perm(<span class="built_in">list</span>, i + <span class="number">1</span>, n);</span><br><span class="line">                swap(<span class="built_in">list</span>[i], <span class="built_in">list</span>[j], temp);</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在进行交换前进行判断，当第 i 个字符和第 j 个字符交换位置时，判断范围是 [i, j) 是否有和 j 重复的数，如果重复我们跳过这种情况。</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><blockquote>
<p>题目内容：对字符串（数字，字母，符号）进行全排列，并统计全排列的种树</p>
<p>输入描述：输入一个字符串</p>
<p>输出描述：输出字符串的全排列，每种情况占一行，最后一行输出全排列的个数</p>
<p>输入样例</p>
<p>123</p>
<p>输出样例</p>
<p>123<br>132<br>213<br>231<br>312<br>321<br>6</p>
</blockquote>
<p>这题目的坑在于对输出的全排列需要排序，ac代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;  </span><br><span class="line"><span class="built_in">string</span> s[<span class="number">105</span>];</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span>  </span>&#123;  </span><br><span class="line">    <span class="keyword">char</span> temp;</span><br><span class="line">	temp = str[a];</span><br><span class="line">	str[a] = str[b];</span><br><span class="line">	str[b] = temp;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSwap</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> m)</span>  </span>&#123;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;m;i++)  </span><br><span class="line">    <span class="keyword">if</span>(str[m]==str[i])  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Perm</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> m)</span>  </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(k==m)&#123;  </span><br><span class="line">       <span class="comment">// cout&lt;&lt;s&lt;&lt;endl;  </span></span><br><span class="line">        s[sum++] = str;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;=m;i++)&#123;  </span><br><span class="line">            <span class="keyword">if</span>(isSwap(k,i))&#123;  </span><br><span class="line">                swap(k,i);  </span><br><span class="line">                Perm(k+<span class="number">1</span>,m);  </span><br><span class="line">                swap(k,i);  </span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;   </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;str)&#123;  </span><br><span class="line">        sum=<span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">int</span> len=str.length();  </span><br><span class="line">        Perm(<span class="number">0</span>,len<span class="number">-1</span>); </span><br><span class="line">        sort(s,s+sum);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sum;i++)</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;s[i]&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;      </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用next-permutation（排列组合）函数"><a href="#使用next-permutation（排列组合）函数" class="headerlink" title="使用next_permutation（排列组合）函数"></a>使用next_permutation（排列组合）函数</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>对于next_permutation函数，其函数原型为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">next_permutation</span><span class="params">(iterator start,iterator end)</span></span></span><br></pre></td></tr></table></figure>
<p>当当前序列不存在下一个排列时，函数返回 false，否则返回 true。</p>
<p>例如这个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> num[<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;  </span><br><span class="line">    <span class="keyword">do</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;num[<span class="number">0</span>]&lt;&lt;<span class="string">" "</span>&lt;&lt;num[<span class="number">1</span>]&lt;&lt;<span class="string">" "</span>&lt;&lt;num[<span class="number">2</span>]&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    &#125;<span class="keyword">while</span>(next_permutation(num,num+<span class="number">3</span>));  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出的结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">1 3 2</span><br><span class="line">2 1 3</span><br><span class="line">2 3 1</span><br><span class="line">3 1 2</span><br><span class="line">3 2 1</span><br></pre></td></tr></table></figure>
<p>当把 while(next_permutation(num,num+3)) 中的 3 改为 2 时，输出就变为了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">2 1 3</span><br></pre></td></tr></table></figure>
<p>由此可以看出，next_permutation(num,num+n) 函数是对数组 num 中的前 n 个元素进行全排列，同时并改变num数组的值。</p>
<p>另外，需要强调的是，next_permutation() 在使用前需要对欲排列数组按升序排序，否则只能找出该序列之后的全排列数。比如，如果数组 num 初始化为 2，3，1，那么输出就变为了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 3 1</span><br><span class="line">3 1 2</span><br><span class="line">3 2 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>next_permutation() 函数功能是输出所有比当前排列大的排列，顺序是从小到大。</p>
<p>prev_permutation() 函数功能是输出所有比当前排列小的排列，顺序是从大到小。</p>
</blockquote>
<p>此外，next_permutation(node, node+n, cmp) 可以对结构体 num 按照自定义的排序方式 cmp 进行排序。</p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>经典的<code>24点</code>问题就可以用全排列来暴力解决，北邮复试机考就考到了这个题。</p>
<blockquote>
<p>本文参考自：</p>
<p><a href="https://blog.csdn.net/ac_gibson/article/details/45308645" target="_blank" rel="noopener">C++STL中全排列函数next_permutation的使用</a> </p>
</blockquote>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>hushhw</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/posts/83505976.html">全排列算法总结</a></li><li class="post-copyright-date"><strong>发布时间：</strong>2019年03月18日 - 19:16:30</li><li class="post-copyright-updated"><strong>更新时间：</strong>2021年02月03日 - 6:56:56</li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</li></ul></div><br><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="https://wiki.hushhw.cn/posts/83505976.html" data-id="ckkp2xtjq005bf8tln4dokeho" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAK4AAACuCAAAAACKZ2kyAAABxUlEQVR42u3awaoDIQwF0P7/T/dBVw/KODdqZArHVWk7epxFMImvVzzen3H1/f/x/f34qVfHwMXFXea+h+ObO2ZVn80NuLi457nj4BVNFG9m/PnGhouL+zDu+Fgzt3lcXNxf524IQ7i4uD/FTZKfucNNEvJacjVcXNwFbrVg2vG5sb6Li4tb5L6LI2mf5IeY8uq4uLhHuOOJ1ksb1eQnCnO4uLjN3PyxlTRm7gh1GcJwcXGbuflFq44EKV/3Jgbj4uI2c5P0Zi6lyQNW+ZXh4uIe4VaLm8mkc42T8jvGxcVd5q6HpDxsbUh4cHFxD3I3X32Ii6cbMjNcXNyD3DwRyjsdeUHkci1cXNwj3GpWVF1+rjUbpV64uLht3GrzI99MNcWK6Li4uEe41cNKtdw5l2KNAx8uLm43d66Nmm9grgiCi4v7BG61CFK9QlFtx0ZNVlxc3GZuPqoLVNu0G6bGxcVd5u5qmuasveUSXFzcPm61zZkvM3c8uvkVFxf3IDcvfMyVTfMIevMfXFzch3FXrmpVCyWXm8fFxX0wN2/K5mErmgcXF/cgt1rcXHmq+lImczVcXNwF7q5wUz6sFK+C4eLiHuH+ASlg3UTs2ctQAAAAAElFTkSuQmCC">分享</a><div class="tags"><a href="/tags/算法笔记/">算法笔记</a><a href="/tags/全排列/">全排列</a></div><div class="post-nav"><a class="pre" href="/posts/b8222433.html">《数据库系统概论》学习笔记之绪论</a><a class="next" href="/posts/689f6bc0.html">计算几何简单总结</a></div><div class="recommended_posts"><h2>相关文章：</h2><li><a href="https://wiki.hushhw.cn/posts/ac7121e8.html" target="_blank">《数据库系统概论》学习笔记之关系数据库</a></li><li><a href="https://wiki.hushhw.cn/posts/b8222433.html" target="_blank">《数据库系统概论》学习笔记之绪论</a></li><li><a href="https://wiki.hushhw.cn/posts/689f6bc0.html" target="_blank">计算几何简单总结</a></li><li><a href="https://wiki.hushhw.cn/posts/cd2c8225.html" target="_blank">欧几里得算法与拓展欧几里得算法</a></li></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//photo.hushhw.cn/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'YVxvrCNxpTLOcs83UfKCUOaI-gzGzoHsz',
  appKey:'5eaXH2FJm2nxSBIQL4INFBbW',
  placeholder:'居然什么也不说，哼',
  avatar:'robohash',
  guest_info:guest_info,
  pageSize:'10'
})</script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar-toc"><div class="stoc-article" id="sidebar-stoc"><strong class="stoc-title"><i class="fa fa-blind"> Contents </i></strong><div class="toc-nav" id="stoc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#全排列递归算法"><span class="toc-number">1.</span> <span class="toc-text">全排列递归算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#算法思想"><span class="toc-number">1.1.</span> <span class="toc-text">算法思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现"><span class="toc-number">1.2.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例题"><span class="toc-number">1.3.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用next-permutation（排列组合）函数"><span class="toc-number">2.</span> <span class="toc-text">使用next_permutation（排列组合）函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用"><span class="toc-number">2.1.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#举例"><span class="toc-number">2.2.</span> <span class="toc-text">举例</span></a></li></ol></li></ol></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© 2018 - 2021 | <span class="footicon"><i class="fa fa-meh-o"></i></span><a rel="nofollow" target="_blank" href="https://wiki.hushhw.cn">hushhw × Wiki</a> | <a rel="nofollow" target="_blank" href="http://www.miibeian.gov.cn/">鄂ICP备17007175号-1</a><br> 
Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo | </a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho | </a>Accelerated by <a rel="nofollow" target="_blank" href="https://www.upyun.com/index.html"><img class="upyunimg" src="https://photo.hushhw.cn/images/又拍云120180930001119303.png"></a><br> <script src="https://photo.hushhw.cn/busuanzi.pure.mini.js" async="async"></script><span id="busuanzi_container_site_uv"></span><i class="fa fa-user-md"></i><span> 访问人数<span id="busuanzi_value_site_uv"></span></span> | <span id="busuanzi_container_site_pv"> </span><span class="footicon"><i class="fa fa-eye"></i></span><span> 访问量<span id="busuanzi_value_site_pv"></span></span></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script><script type="text/javascript" src="/js/toc.js?v=0.0.0" async></script></div></body></html>