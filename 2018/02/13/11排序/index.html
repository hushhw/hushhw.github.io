<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="aEXOxeJU__4i99aRP765TFHVsu1lDxRKExENESoTDHo" />








  <meta name="baidu-site-verification" content="ndXaD7apwJ" />







  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="算法笔记,排序," />





  <link rel="alternate" href="/atom.xml" title="hushhw's blog" type="application/atom+xml" />






<meta name="description" content="排序算法之前也有总结排序部分，但是总是忘记，这段时间在整理算法笔记，所以借机再整理一份。主要整理的是八大内部排序，分析代码，时间复杂度等 排序分类见图：（图片来源见图片链接） 各排序算法基本性能： 1. 冒泡排序1.1 冒泡排序算法思想及代码实现冒泡排序是一种交换排序，基本算法思想是重复访问要排序的数列，每趟排序过程中通过两两比较相邻元素，按一定顺序交换，直到没有在需要交换即数列排序完成。 123">
<meta name="keywords" content="算法笔记,排序">
<meta property="og:type" content="article">
<meta property="og:title" content="排序算法">
<meta property="og:url" content="https://hushhw.cn/2018/02/13/11排序/index.html">
<meta property="og:site_name" content="hushhw&#39;s blog">
<meta property="og:description" content="排序算法之前也有总结排序部分，但是总是忘记，这段时间在整理算法笔记，所以借机再整理一份。主要整理的是八大内部排序，分析代码，时间复杂度等 排序分类见图：（图片来源见图片链接） 各排序算法基本性能： 1. 冒泡排序1.1 冒泡排序算法思想及代码实现冒泡排序是一种交换排序，基本算法思想是重复访问要排序的数列，每趟排序过程中通过两两比较相邻元素，按一定顺序交换，直到没有在需要交换即数列排序完成。 123">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://cuijiahua.com/wp-content/uploads/2018/01/algorithm_9_2.png">
<meta property="og:image" content="http://cuijiahua.com/wp-content/uploads/2018/01/algorithm_9_3.png">
<meta property="og:image" content="https://61mon.com/images/illustrations/Sort/3.jpg">
<meta property="og:image" content="https://61mon.com/images/illustrations/Sort/4.jpg">
<meta property="og:image" content="https://61mon.com/images/illustrations/Sort/5.jpg">
<meta property="og:image" content="https://61mon.com/images/illustrations/Sort/6.jpg">
<meta property="og:image" content="https://61mon.com/images/illustrations/Sort/7.jpg">
<meta property="og:image" content="https://61mon.com/images/illustrations/Sort/8.jpg">
<meta property="og:image" content="https://61mon.com/images/illustrations/Sort/10.png">
<meta property="og:updated_time" content="2018-02-13T13:17:55.764Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="排序算法">
<meta name="twitter:description" content="排序算法之前也有总结排序部分，但是总是忘记，这段时间在整理算法笔记，所以借机再整理一份。主要整理的是八大内部排序，分析代码，时间复杂度等 排序分类见图：（图片来源见图片链接） 各排序算法基本性能： 1. 冒泡排序1.1 冒泡排序算法思想及代码实现冒泡排序是一种交换排序，基本算法思想是重复访问要排序的数列，每趟排序过程中通过两两比较相邻元素，按一定顺序交换，直到没有在需要交换即数列排序完成。 123">
<meta name="twitter:image" content="http://cuijiahua.com/wp-content/uploads/2018/01/algorithm_9_2.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://hushhw.cn/2018/02/13/11排序/"/>





  <title>排序算法 | hushhw's blog</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">hushhw's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">身经百战见得多了</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-study">
          <a href="/categories/学习" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            学习
          </a>
        </li>
      
        
        <li class="menu-item menu-item-essay">
          <a href="/categories/随笔" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            随笔
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hushhw.cn/2018/02/13/11排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hushhw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hushhw's blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">排序算法</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-13T02:52:47+08:00">
                2018-02-13
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2018-02-13T21:17:55+08:00">
                2018-02-13
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习/" itemprop="url" rel="index">
                    <span itemprop="name">学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 阅读量
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  8,157 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  35 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>之前也有总结排序部分，但是总是忘记，这段时间在整理算法笔记，所以借机再整理一份。<br>主要整理的是八大内部排序，分析代码，时间复杂度等</p>
<p>排序分类见图：（图片来源见图片链接）<br><img src="http://cuijiahua.com/wp-content/uploads/2018/01/algorithm_9_2.png" alt="图片来源见链接"></p>
<p>各排序算法基本性能：<br><img src="http://cuijiahua.com/wp-content/uploads/2018/01/algorithm_9_3.png" alt="图片来源见链接"></p>
<h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h2><h3 id="1-1-冒泡排序算法思想及代码实现"><a href="#1-1-冒泡排序算法思想及代码实现" class="headerlink" title="1.1 冒泡排序算法思想及代码实现"></a>1.1 冒泡排序算法思想及代码实现</h3><p>冒泡排序是一种交换排序，基本算法思想是重复访问要排序的数列，每趟排序过程中通过两两比较相邻元素，按一定顺序交换，直到没有在需要交换即数列排序完成。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bubbleSort(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>)&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">list</span>.empty())&#123;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	result = <span class="built_in">list</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; result.size()<span class="number">-1</span>; ++i)&#123;		<span class="comment">//外层循环仅标记趟数</span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"第"</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">"趟排序:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j &lt; result.size()<span class="number">-1</span>; j++)&#123;	<span class="comment">//内层循环进行相邻数据交换</span></span><br><span class="line">			<span class="keyword">if</span>(result[j+<span class="number">1</span>] &lt; result[j])&#123;</span><br><span class="line">				swap(result[j+<span class="number">1</span>], result[j]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"排序中:"</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>; s&lt;result.size(); s++)&#123;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;result[s]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"排序结果:"</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>; s &lt; result.size(); s++)&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;result[s]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[] = &#123; <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span> &#125;;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]));</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"排序前"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.size(); i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; test[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">	result = bubbleSort(test);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"排序后"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; result[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-冒泡排序算法性能"><a href="#1-2-冒泡排序算法性能" class="headerlink" title="1.2 冒泡排序算法性能"></a>1.2 冒泡排序算法性能</h3><p>若文件的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数C和记录移动次数M均达到最小值：Cmin = N - 1, Mmin = 0。所以，<strong>冒泡排序最好时间复杂度为O(N)</strong>。<br>若初始文件是反序的，需要进行 N -1 趟排序。每趟排序要进行 N - i 次关键字的比较(1 ≤ i ≤ N - 1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：<br>$C_{max} = N(N-1)/2 = O(N^2)$<br>$M_{max} = 3N(N-1)/2 = O(N^2)$<br>冒泡排序的最坏时间复杂度为$O(N^2)$。<br>因此，冒泡排序的平均时间复杂度为$O(N^2)$。<br>总结起来，其实就是一句话：当数据越接近正序时，冒泡排序性能越好。</p>
<p>冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以相同元素的前后顺序并没有改变，所以冒泡排序是一种<strong>稳定排序算法</strong>。</p>
<h3 id="1-3-冒泡排序优化"><a href="#1-3-冒泡排序优化" class="headerlink" title="1.3 冒泡排序优化"></a>1.3 冒泡排序优化</h3><p>在上述代码中测试的数据会发现，早在第三趟就已经完成排序，但是还是执行了后面的四五六趟排序。对冒泡排序常见的改进方法是加入<strong>标志性变量exchange</strong>，用于标志某一趟排序过程中是否有数据交换。如果进行<strong>某一趟排序时并没有进行数据交换，则说明所有数据已经有序</strong>，可立即结束排序，避免不必要的比较过程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bubbleSort(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>)&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">list</span>.empty())&#123;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	result = <span class="built_in">list</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; result.size()<span class="number">-1</span>; ++i)&#123;		<span class="comment">//外层循环仅标记趟数</span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"第"</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">"趟排序:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="comment">/*----------冒泡排序优化代码1-----------*/</span></span><br><span class="line">		<span class="keyword">bool</span> bChanged = <span class="literal">false</span>;	<span class="comment">//交换标记</span></span><br><span class="line">		<span class="comment">/*----------冒泡排序优化代码1-----------*/</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j &lt; result.size()<span class="number">-1</span>; j++)&#123;	<span class="comment">//内层循环进行相邻数据交换</span></span><br><span class="line">			<span class="keyword">if</span>(result[j+<span class="number">1</span>] &lt; result[j])&#123;</span><br><span class="line">				swap(result[j+<span class="number">1</span>], result[j]);</span><br><span class="line">				<span class="comment">/*----------冒泡排序优化代码2-----------*/</span></span><br><span class="line">				bChanged = <span class="literal">true</span>;</span><br><span class="line">				<span class="comment">/*----------冒泡排序优化代码2-----------*/</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"排序中:"</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>; s&lt;result.size(); s++)&#123;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;result[s]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*----------冒泡排序优化代码3-----------*/</span></span><br><span class="line">		<span class="keyword">if</span>(bChanged == <span class="literal">false</span>)	<span class="comment">//如果标志为false,说明本轮遍历没有进行数据交换，即说明已经有序</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">/*----------冒泡排序优化代码3-----------*/</span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"排序结果:"</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>; s &lt; result.size(); s++)&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;result[s]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[] = &#123; <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span> &#125;;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]));</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"排序前"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.size(); i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; test[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">	result = bubbleSort(test);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"排序后"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; result[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-快速排序"><a href="#2-快速排序" class="headerlink" title="2. 快速排序"></a>2. 快速排序</h2><h3 id="2-1-快速排序算法思想及代码实现"><a href="#2-1-快速排序算法思想及代码实现" class="headerlink" title="2.1 快速排序算法思想及代码实现"></a>2.1 快速排序算法思想及代码实现</h3><p>快速排序也是一种交换排序。快速排序由C. A. R. Hoare在1962年提出。</p>
<p>它的基本思想是：通过一趟排序将要排序的数据<strong>分割</strong>成独立的两部分：<strong>分割点左边都是比它小的数，右边都是比它大的数</strong>。然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<p>算法步骤：</p>
<ul>
<li>选取主元</li>
<li>小于等于主元的放左边，大于等于主元的放右边</li>
<li>分别对左右边递归，即重复（1）、（2）步</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">division</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">list</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> base = <span class="built_in">list</span>[left];</span><br><span class="line">	<span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">		<span class="keyword">while</span>(left &lt; right &amp;&amp; <span class="built_in">list</span>[right]&gt;=base)<span class="comment">//从序号右端开始向左遍历，直到找到小于base的数</span></span><br><span class="line">			right--;</span><br><span class="line">		<span class="built_in">list</span>[left] = <span class="built_in">list</span>[right];	<span class="comment">//找到比base小的元素，将这个元素放到最左边的位置</span></span><br><span class="line">		<span class="keyword">while</span>(left &lt; right &amp;&amp; <span class="built_in">list</span>[left]&lt;=base) <span class="comment">//从序号左端开始向右遍历，直到找到大于base的数</span></span><br><span class="line">			left++;</span><br><span class="line">		<span class="built_in">list</span>[right] = <span class="built_in">list</span>[left];	<span class="comment">//找到比base大的元素，将这个元素放到最右边的位置</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">list</span>[left] = base;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"每一轮："</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>.size(); i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">list</span>[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">list</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(left &lt; right)&#123;	<span class="comment">//左下标一定小于右下标，否则越界</span></span><br><span class="line">		<span class="keyword">int</span> base = division(<span class="built_in">list</span>, left, right);<span class="comment">//对数组进行分割，去除下次分割的基准标号</span></span><br><span class="line">		QuickSort(<span class="built_in">list</span>, left, base<span class="number">-1</span>);<span class="comment">//左</span></span><br><span class="line">		QuickSort(<span class="built_in">list</span>, base+<span class="number">1</span>, right);<span class="comment">//右</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[] = &#123; <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test(arr, arr + <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]));</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"排序前"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.size(); i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; test[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result = test;</span><br><span class="line"></span><br><span class="line">	QuickSort(result, <span class="number">0</span>, result.size() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"排序后"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; result[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-快速排序算法性能"><a href="#2-2-快速排序算法性能" class="headerlink" title="2.2 快速排序算法性能"></a>2.2 快速排序算法性能</h3><p>时间复杂度上：</p>
<p>最好的情况，每次我们运行一次分区，我们会把一个数组分为两个几近相等的片段。这个意思就是每次递归调用处理一半大小的数组。则会有关系式：</p>
<script type="math/tex; mode=display">
T(n)=2T(\frac n 2)+O(n)</script><p>解出 $T_{best}(n)=O(nlogn)$。</p>
<p>最坏的情况，在分割后，两子数组总是拥有各为 1 和 n-1 长度的数组，则递归关系式变为：</p>
<script type="math/tex; mode=display">
T(n)=T(n−1)+O(n)+O(1)=T(n−1)+O(n)</script><p>解出 $T_{worst}(n)=O(n^2)$。</p>
<p>空间复杂度上：</p>
<p>快速排序在每次分割的过程中，需要 1 个空间存储基准值。而快速排序的大概需要Nlog2N次的分割处理，所以占用空间也是 Nlog2N 个。</p>
<p>算法稳定性上：</p>
<p>在快速排序中，相等元素可能会因为分区而交换顺序，所以它是不稳定的算法。</p>
<h3 id="2-3-快速排序细节优化"><a href="#2-3-快速排序细节优化" class="headerlink" title="2.3 快速排序细节优化"></a>2.3 快速排序细节优化</h3><p>我们知道主元的大小直接决定快排的效率，因为数组的划分需要依靠主元，理想状态下，给定的主元正好可以把数组分为长度相等的两个子数组，但找到并确定这样的主元还需要耗费额外的时间，如此一来，得不偿失。</p>
<p>快速排序算法有三种选择主元的方法：</p>
<ol>
<li>取序列中的第一个或最后一个元素作为主元<em>（前面实现的就是这种）</em></li>
<li>取序列中任意一个元素作为主元</li>
<li>选取左，中，右三个元素的 “中值” 为主元</li>
</ol>
<h2 id="3-直接插入排序"><a href="#3-直接插入排序" class="headerlink" title="3. 直接插入排序"></a>3. 直接插入排序</h2><h3 id="3-1-插入排序算法思想及代码实现"><a href="#3-1-插入排序算法思想及代码实现" class="headerlink" title="3.1 插入排序算法思想及代码实现"></a>3.1 插入排序算法思想及代码实现</h3><p>每一趟将一个待排序的记录，按照其关键字的大小插入到有序队列的合适位置里，直到全部插入完成。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; insertSort(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>)&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">list</span>.empty())&#123;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	result = <span class="built_in">list</span>;</span><br><span class="line">	<span class="comment">// 第1个数肯定是有序的，从第2个数开始遍历，依次插入有序序列</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line">		<span class="comment">// 取出第i个数，和前i-1个数比较后，插入合适位置</span></span><br><span class="line">		<span class="keyword">int</span> temp = result[i];</span><br><span class="line">		<span class="comment">// 因为前i-1个数都是从小到大的有序序列，所以只要当前比较的数(res[j])比temp大，就把这个数后移一位</span></span><br><span class="line">		<span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (j; j &gt;= <span class="number">0</span> &amp;&amp; result[j] &gt; temp; j--)&#123;</span><br><span class="line">			result[j + <span class="number">1</span>] = result[j];</span><br><span class="line">		&#125;</span><br><span class="line">		result[j + <span class="number">1</span>] = temp;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"第"</span>&lt;&lt;i&lt;&lt;<span class="string">"轮:"</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; result[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[] = &#123; <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span> &#125;;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]));</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"排序前"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.size(); i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; test[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">	result = insertSort(test);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"排序后"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; result[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-插入排序算法性能"><a href="#3-2-插入排序算法性能" class="headerlink" title="3.2 插入排序算法性能"></a>3.2 插入排序算法性能</h3><p>那么它的算法复杂度如下（参考<a href="https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F#.E7.AE.97.E6.B3.95.E5.A4.8D.E6.9D.82.E5.BA.A6" target="_blank" rel="noopener">维基百科</a>）：</p>
<ul>
<li>时间复杂度<ul>
<li>最好情况，序列是升序排列，在这种情况下，只需进行 $n-1$ 比较，即 $T_{best}(n)=O(n)$；</li>
<li>最坏情况，序列是降序排列，那么此时需要进行的比较共有 $\frac 12n(n−1)$ 次，即 $T_{worse}(n)=O(n^2)$；</li>
<li>平均情况，为 $T_{avg}(n)=O(n^2)$。</li>
</ul>
</li>
<li>空间复杂度<ul>
<li>由程序很容易得我们在排序过程中，需要一个临时变量存储要插入的值，所以空间复杂度为 S(n)=O(1)。</li>
</ul>
</li>
</ul>
<p>它的算法稳定性：直接插入排序的过程中，不需要改变相等数值元素的位置，所以它是<strong>稳定的</strong>算法。</p>
<h2 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4. 希尔排序"></a>4. 希尔排序</h2><h3 id="4-1-希尔排序算法思想及代码实现"><a href="#4-1-希尔排序算法思想及代码实现" class="headerlink" title="4.1 希尔排序算法思想及代码实现"></a>4.1 希尔排序算法思想及代码实现</h3><p>希尔(Shell)排序又称为<strong>缩小增量排序</strong>，它是一种<strong>插入排序</strong>。它<strong>是直接插入排序算法的一种威力加强版</strong>。该方法因DL．Shell于1959年提出而得名。</p>
<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：（以下摘自<a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">维基百科</a>）</p>
<ul>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到<a href="https://zh.wikipedia.org/w/index.php?title=%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">线性排序</a>的效率</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</li>
</ul>
<p>希尔排序的<strong>基本思想</strong>是：</p>
<p>把记录按<strong>步长</strong> gap 分组，对每组记录采用<strong>直接插入排序</strong>方法进行排序。<br>随着<strong>步长逐渐减小</strong>，所分成的组包含的记录越来越多，当步长的值减小到 <strong>1</strong> 时，整个数据合成为一组，构成一组有序记录，则完成排序。</p>
<p>举例：假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样：</p>
<p><code>13 14 94 33 82</code><br><code>25 59 94 65 23</code><br><code>45 27 73 25 39</code><br><code>10</code></p>
<p>然后我们对每列进行排序：</p>
<p><code>10 14 73 25 23</code><br><code>13 27 94 33 39</code><br><code>25 59 94 65 82</code><br><code>45</code></p>
<p>将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ].这时10已经移至正确位置了，然后再以3为步长进行排序：</p>
<p><code>10 14 73</code><br><code>25 23 13</code><br><code>27 94 33</code><br><code>39 25 59</code><br><code>94 65 82</code><br><code>45</code></p>
<p>排序之后变为：</p>
<p><code>10 14 13</code><br><code>25 23 33</code><br><code>27 25 59</code><br><code>39 65 73</code><br><code>45 94 82</code><br><code>94</code></p>
<p>最后以1步长进行排序（此时就是简单的插入排序了）。</p>
<p>可想而知，步长的选择是希尔排序的重要部分。算法最开始以一定的步长进行排序，然后会继续以更小的步长进行排序，最终算法以步长为 1 进行排序。当步长为 1 时，算法变为直接插入排序，这就保证了数据一定会被全部排序。</p>
<p>下面以$\frac n{2^i}$作为步长为例进行讲解。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ShellSort(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>)&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">	result = <span class="built_in">list</span>;</span><br><span class="line">	<span class="keyword">int</span> n = result.size();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> gap = n &gt;&gt; <span class="number">1</span>; gap &gt; <span class="number">0</span>; gap &gt;&gt;= <span class="number">1</span>)&#123;	<span class="comment">//对n进行二分除二处理</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=gap; i&lt;n; i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> temp = result[i];	<span class="comment">//记录i所在的数</span></span><br><span class="line">			<span class="keyword">int</span> j;</span><br><span class="line">			<span class="keyword">for</span>(j = i-gap; j&gt;=<span class="number">0</span> &amp;&amp; result[j]&gt;temp; j -= gap)&#123;<span class="comment">//把相距为gap的i,j所在数字比较，相当于隔行判断</span></span><br><span class="line">				result[j+gap] = result[j];</span><br><span class="line">			&#125;</span><br><span class="line">			result[j+gap] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[] = &#123; <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span> &#125;;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]));</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"排序前"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.size(); i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; test[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">	result = ShellSort(test);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"排序后"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; result[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-希尔排序算法性能"><a href="#4-2-希尔排序算法性能" class="headerlink" title="4.2 希尔排序算法性能"></a>4.2 希尔排序算法性能</h3><p>那么它的算法复杂度如下（参考<a href="https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F#.E7.AE.97.E6.B3.95.E5.A4.8D.E6.9D.82.E5.BA.A6" target="_blank" rel="noopener">维基百科</a>）：</p>
<p>步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。</p>
<p>算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为1进行排序。当步长为1时，算法变为插入排序，这就保证了数据一定会被排序。<br>Donald Shell 最初建议步长选择为N/2并且对步长取半直到步长达到1。虽然这样取可以比O(N2)类的算法（插入排序）更好，但这样仍然有减少平均时间和最差时间的余地。可能希尔排序最重要的地方在于当用较小步长排序后，以前用的较大步长仍然是有序的。比如，如果一个数列以步长5进行了排序然后再以步长3进行排序，那么该数列不仅是以步长3有序，而且是以步长5有序。如果不是这样，那么算法在迭代过程中会打乱以前的顺序，那就</p>
<p>不会以如此短的时间完成排序了。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">步长序列</th>
<th style="text-align:center">最坏情况下复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$\frac n{2^i}$</td>
<td style="text-align:center">$O(n^2)$</td>
</tr>
<tr>
<td style="text-align:center">$2^i-1$</td>
<td style="text-align:center">$O(n^{\frac 32})$</td>
</tr>
<tr>
<td style="text-align:center">$2^i3^i$</td>
<td style="text-align:center">$O(nlog^2n)$</td>
</tr>
</tbody>
</table>
</div>
<p>已知的最好步长序列是由Sedgewick提出的(1, 5, 19, 41, 109,…)，该序列的项来自$9<em>4^i-9</em>2^i$和$2^{i+2}*(2^{i+2}-3)+1$这两个算式。这项研究也表明“比较在希尔排序中是最主要的操作，而不是交换。”用这样步长序列的希尔排序比插入排序和堆排序都要快，甚至在小数组中比快速排序还快，但是在涉及大量数据时希尔排序还是比快速排序慢。</p>
<p>它的算法稳定性：希尔排序中相等数据可能会交换位置，所以希尔排序是<strong>不稳定</strong>的算法。</p>
<h3 id="4-3-希尔排序和直接插入排序比较"><a href="#4-3-希尔排序和直接插入排序比较" class="headerlink" title="4.3 希尔排序和直接插入排序比较"></a>4.3 希尔排序和直接插入排序比较</h3><p>直接插入排序是<strong>稳定的</strong>；而希尔排序是<strong>不稳定</strong>的。</p>
<p>直接插入排序更适合于原始记录基本<strong>有序</strong>的集合。</p>
<p>希尔排序的比较次数和移动次数都要比直接插入排序少，当N越大时，效果越明显。   </p>
<p>在希尔排序中，增量序列gap的取法必须满足：<strong>最后一个步长必须是1</strong>。</p>
<p>直接插入排序也<strong>适用于链式存储结构</strong>；希尔排序<strong>不适用于链式结构</strong>。</p>
<h2 id="5-简单选择排序"><a href="#5-简单选择排序" class="headerlink" title="5. 简单选择排序"></a>5. 简单选择排序</h2><h3 id="5-1-简单选择排序算法思想及代码实现"><a href="#5-1-简单选择排序算法思想及代码实现" class="headerlink" title="5.1 简单选择排序算法思想及代码实现"></a>5.1 简单选择排序算法思想及代码实现</h3><p>简单选择排序是一种<strong>选择排序</strong>。</p>
<p><strong>选择排序</strong>：每趟从待排序的记录中选出关键字最小的记录，顺序放在已排序的记录序列末尾，直到全部排序结束为止。</p>
<p>简单排序很简单，它的大致处理流程为：</p>
<ul>
<li>从待排序序列中，找到关键字最小的元素；</li>
<li>如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；</li>
<li>从余下的 N - 1 个元素中，找出关键字最小的元素，重复(1)、(2)步，直到排序结束。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; SelectSort(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>)&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">	result = <span class="built_in">list</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;result.size(); i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> index = i;		<span class="comment">//标记第一个位置</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;result.size(); j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(result[index] &gt; result[j])</span><br><span class="line">				index = j;	<span class="comment">//如果比index位置上的数字小，就标记该数字</span></span><br><span class="line">		&#125;</span><br><span class="line">		swap(result[i], result[index]);	<span class="comment">//循环结束后把标记的最小数字所在位置index和i位置交换</span></span><br><span class="line">		</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"第"</span> &lt;&lt; i + <span class="number">1</span>&lt;&lt; <span class="string">"趟:\t"</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; result[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[] = &#123; <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span> &#125;;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]));</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"排序前"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.size(); i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; test[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">	result = SelectSort(test);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"排序后"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; result[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-2-简单选择排序算法性能"><a href="#5-2-简单选择排序算法性能" class="headerlink" title="5.2 简单选择排序算法性能"></a>5.2 简单选择排序算法性能</h3><p>那么它的算法复杂度如下：</p>
<ul>
<li><p>时间复杂度</p>
<p>简单选择排序的比较次数与序列的初始排序无关。 假设待排序的序列有 N 个元素，则比较次数总是$\frac {N (N - 1) }2$。</p>
<p>简单排序的时间复杂度为 $O(N^2)$。</p>
</li>
<li><p>空间复杂度</p>
<ul>
<li>由程序很容易得我们在排序过程中，需要一个临时变量存储要插入的值，所以空间复杂度为 S(n)=O(1)。</li>
</ul>
</li>
</ul>
<h2 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6. 堆排序"></a>6. 堆排序</h2><h3 id="6-1-堆排序算法思想及代码实现"><a href="#6-1-堆排序算法思想及代码实现" class="headerlink" title="6.1 堆排序算法思想及代码实现"></a>6.1 堆排序算法思想及代码实现</h3><p>堆排序是利用堆的性质进行的一种选择排序。下面先讨论一下堆。</p>
<p>堆实际上是一棵完全二叉树，其满足性质：任何一结点大于等于或者小于等于其左右子树结点。</p>
<p>堆分为大顶堆和小顶堆，满足 “任何一结点大于等于其左右子树结点” 的称为大顶堆，满足 “任何一结点小于等于其左右子树结点” 的称为小顶堆。由上述性质可知：大顶堆的堆顶肯定是最大的，小顶堆的堆顶是最小的。</p>
<p>堆排序可以归纳出两个操作：</p>
<ul>
<li>根据初始数组去<strong>构造初始堆</strong>（构建一个完全二叉树，保证所有的父结点都比它的孩子结点数值大）。</li>
<li>每次<strong>交换第一个和最后一个元素，输出最后一个元素</strong>（最大值），然后把剩下元素<strong>重新调整</strong>为大根堆。</li>
</ul>
<p>下面举个例子（资源来自<a href="http://www.cnblogs.com/dolphin0520/archive/2011/10/06/2199741.html" target="_blank" rel="noopener">堆排序 - 海子</a>）来说明堆排序的过程（以升序为例）：</p>
<p>（1）<br><img src="https://61mon.com/images/illustrations/Sort/3.jpg" alt="img"></p>
<p>给定整型数组：{16, 7, 3, 20, 17, 8}，根据该数组 “构建” 完全二叉树（并不是真的写代码去构建，只是把数组看成完全二叉树去操作）。</p>
<p>程序从最后一个非叶子结点开始，即 3。判断其左右孩子：8，8 比 3 大，把 8 调整上去。</p>
<p>（2）<br><img src="https://61mon.com/images/illustrations/Sort/4.jpg" alt="img"></p>
<p>3 结点下无孩子，判断结束。</p>
<p>继续往前一步，至 7 结点，判断其左右孩子：20 和 17，20 是最大的，将其调整上去。</p>
<p>（3）<br><img src="https://61mon.com/images/illustrations/Sort/5.jpg" alt="img"></p>
<p>7 结点下无孩子，判断结束。</p>
<p>继续往前一步，至 16 结点，判断其左右孩子：20 和 8，20 是最大的，将其调整上去。</p>
<p>（4）<br><img src="https://61mon.com/images/illustrations/Sort/6.jpg" alt="img"></p>
<p>判断 16 结点下左右孩子：7 和 17，17 是最大的，将其调整上去。</p>
<p>（5）<br><img src="https://61mon.com/images/illustrations/Sort/7.jpg" alt="img"></p>
<p>16 结点下无孩子，判断结束。</p>
<p>遍历已至头部，结束。</p>
<p>（6）至此数组已经满足大顶堆的性质，接下来的操作就很简单了。<br><img src="https://61mon.com/images/illustrations/Sort/8.jpg" alt="img"></p>
<p>看完上面所述的流程你至少有两个疑问：</p>
<ul>
<li>如何确定最后一个非叶子结点？</li>
</ul>
<p>其实这是有一个公式的，设二叉树结点总数为 n，则最后一个非叶子结点是第$\frac n2$个。</p>
<ul>
<li>数组当中如何确定当前结点的左右孩子位置？</li>
</ul>
<p>设当前结点下标是 i，则其左孩子的下标是 2i，右孩子的下标是 2i+1。请注意：这是建立在数组下标从 1 开始的情况。若数组下标从 0 开始，则其左右孩子下标还各需多加一个 1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">list</span>, <span class="keyword">int</span> start, <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> parent = start;			<span class="comment">//父节点</span></span><br><span class="line">	<span class="keyword">int</span> child = <span class="number">2</span> * parent + <span class="number">1</span>;	<span class="comment">// 先获得左孩子</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (child &lt;= length)&#123;	</span><br><span class="line">		<span class="comment">// 如果有右子节点，并且右子节点的值大于左子节点，则选取右子节点，否则选取左节点</span></span><br><span class="line">		<span class="keyword">if</span> (child + <span class="number">1</span> &lt;= length &amp;&amp; <span class="built_in">list</span>[child] &lt; <span class="built_in">list</span>[child + <span class="number">1</span>])&#123;</span><br><span class="line">			child++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果父节点大于孩子节点则代表调整完毕，直接跳出函数</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">list</span>[parent] &gt; <span class="built_in">list</span>[child])&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123; <span class="comment">//否则交换父子内容再继续子节点和孙节点比较</span></span><br><span class="line">			swap(<span class="built_in">list</span>[parent], <span class="built_in">list</span>[child]);</span><br><span class="line">			parent = child;<span class="comment">//父更新为子节点位置</span></span><br><span class="line">			child = parent*<span class="number">2</span>+<span class="number">1</span>;<span class="comment">//子节点更新为孙节点位置</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; HeadSort(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>)&#123;</span><br><span class="line">	<span class="keyword">int</span> length = <span class="built_in">list</span>.size();</span><br><span class="line">	<span class="comment">// 循环建立初始堆，i从最后一个父节点开始</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = length/<span class="number">2</span><span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">		HeapAdjust(<span class="built_in">list</span>, i, length<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>.size(); i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">list</span>[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 进行n-1次循环，完成排序</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">		<span class="comment">// 最后一个元素和第一元素进行交换</span></span><br><span class="line">		swap(<span class="built_in">list</span>[<span class="number">0</span>], <span class="built_in">list</span>[i]);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 筛选 R[0] 结点，得到i-1个结点的堆</span></span><br><span class="line">		HeapAdjust(<span class="built_in">list</span>, <span class="number">0</span>, i<span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"第"</span> &lt;&lt; length - i &lt;&lt; <span class="string">"趟排序:"</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>.size(); i++)&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="built_in">list</span>[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[] = &#123; <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span> &#125;;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]));</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"排序前:"</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.size(); i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; test[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">	result = HeadSort(test);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"排序后:"</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; result[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-2-堆排序算法性能"><a href="#6-2-堆排序算法性能" class="headerlink" title="6.2 堆排序算法性能"></a>6.2 堆排序算法性能</h3><p>堆的存储表示是<strong>顺序的</strong>。因为堆所对应的二叉树为完全二叉树，而完全二叉树通常采用顺序存储方式。</p>
<p>当想得到一个序列中第<strong>k</strong>个最小的元素之前的部分排序序列，最好采用堆排序。</p>
<p>时间复杂度为 $O(nlogn)$，证明如下。</p>
<p>首先计算建堆的时间，也就是下面的代码，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环建立初始堆，i从最后一个父节点开始</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = length/<span class="number">2</span><span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">		HeapAdjust(<span class="built_in">list</span>, i, length<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>n 个结点，从第 0 层至第 $log_2n$ 层。对于第$i$层的$2^i$个点如果需要往下走$log_2n−i$步，那么把走的所有步相加得， </p>
<script type="math/tex; mode=display">
T(n) = \sum _{i=0}^{i=log_2n}{2^i(log_2n-i)}= 2n-log_2n-2<2n=O(n)</script><p>接下来就是排序的时间，即下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">	<span class="comment">// 最后一个元素和第一元素进行交换</span></span><br><span class="line">	swap(<span class="built_in">list</span>[<span class="number">0</span>], <span class="built_in">list</span>[i]);</span><br><span class="line">	<span class="comment">// 筛选 R[0] 结点，得到i-1个结点的堆</span></span><br><span class="line">	HeapAdjust(<span class="built_in">list</span>, <span class="number">0</span>, i<span class="number">-1</span>);</span><br></pre></td></tr></table></figure>
<p>HeapAdjust() 耗时$logn$，共$n$次，故排序时间为$O(nlogn)$。</p>
<p>综上所述，堆排序时间复杂度为$T(n)=O(n)+O(nlogn)=O(nlogn)$。</p>
<p>算法稳定度：</p>
<p>堆排序是一种<strong>不稳定</strong>的排序方法。</p>
<p>因为在堆的调整过程中，关键字进行比较和交换所走的是该结点到叶子结点的一条路径，因此对于相同的关键字就可能出现排在后面的关键字被交换到前面来的情况。</p>
<h2 id="7-归并排序"><a href="#7-归并排序" class="headerlink" title="7. 归并排序"></a>7. 归并排序</h2><h3 id="7-1-归并排序算法思想及代码实现"><a href="#7-1-归并排序算法思想及代码实现" class="headerlink" title="7.1 归并排序算法思想及代码实现"></a>7.1 归并排序算法思想及代码实现</h3><p>归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用<strong>分治法（Divide and Conquer）</strong>的一个非常典型的应用。</p>
<p>将待排序序列R[0…n-1]看成是n个长度为1的有序序列，将相邻的有序表成对归并，得到n/2个长度为2的有序表；将这些有序序列再次归并，得到n/4个长度为4的有序序列；如此反复进行下去，最后得到一个长度为n的有序序列。</p>
<p>综上可知：</p>
<p>归并排序其实要做两件事：</p>
<p>（1）“分解”——将序列每次<strong>折半划分</strong>。</p>
<p>（2）“合并”——将划分后的序列段<strong>两两合并后排序</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;input, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=left;</span><br><span class="line">	<span class="keyword">int</span> j=mid+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=right)&#123;</span><br><span class="line">		<span class="keyword">if</span>(input[i]&lt;=input[j])&#123;</span><br><span class="line">			temp[k++] = input[i++];</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			temp[k++] = input[j++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=mid)</span><br><span class="line">		temp[k++]=input[i++];</span><br><span class="line">	<span class="keyword">while</span>(j&lt;=right)</span><br><span class="line">		temp[k++]=input[j++];</span><br><span class="line">	k=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">		input[left++] = temp[k++];</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;input[left<span class="number">-1</span>]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;input, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">		<span class="keyword">int</span> mid = (left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		MergeSort(input, left, mid, temp);</span><br><span class="line">		MergeSort(input, mid+<span class="number">1</span>, right, temp);</span><br><span class="line">		Merge(input, left, mid ,right, temp);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[] = &#123; <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]));</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"排序前:"</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.size(); i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; test[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result = test;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp(result.size());<span class="comment">// 在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间</span></span><br><span class="line">	MergeSort(result, <span class="number">0</span>, result.size()<span class="number">-1</span>, temp);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"排序后:"</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; result[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-2-归并排序算法性能"><a href="#7-2-归并排序算法性能" class="headerlink" title="7.2 归并排序算法性能"></a>7.2 归并排序算法性能</h3><p>归并排序的时间复杂度分析：MergeSort()函数用于数组划分，Merge()函数用于合并。</p>
<ul>
<li>合并函数Merge()的时间复杂度为$O(n)$，因为代码中有2个长度为n的循环（非嵌套）</li>
<li>划分函数MergeSort()中，简单的分析一下元素长度为n的归并排序所消耗的时间为T(n)：调用MergeSort()函数划分两部分，那每一小部分所花销的时间则是$T[\frac n2]$</li>
</ul>
<p>最后两部分合并:（用迭代法进行推导）</p>
<script type="math/tex; mode=display">
\begin{align}
T[n]& = 2T[\frac n2]+O(n)
\\令：n=\frac n2\quad &=2(2T[\frac n4]+\frac n2)+n
\\&=2^2T[\frac n{2^2}]+2n
\\令：n=\frac n{2^2}\quad&=2^2(2T[\frac n{2^3}]+\frac n{2^2})+2n
\\&=2^3T[\frac n{2^3}]+3n
\\&……
\\令：n=\frac n{2^{m-1}}\quad&=2^mT[1]+mn
\\经过m次递归后，&当最后平分的不能再平分
\\到最后得到T[1]时，&说明这个公式已经迭代完了（T[1]是常量了）
\\得到：T[\frac n{2^m}]=T[1]\quad &==>\ n=2^m\quad ==>\ m=logn
\\T[n]&=2^mT[1]+mn\qquad 其中m=logn；
\\T[n]&=2^{logn}T[1]+nlogn
\\&=nT[1]+nlogn
\\&=n+nlogn
\end{align}</script><p>综上所述：归并排序时间复杂度为：$O(nlogn)$。</p>
<p>因为不管元素在什么情况下都要做这些步骤，所以花销的时间是不变的，所以该算法的最优时间复杂度和最差时间复杂度及平均时间复杂度都是一样的为：$O(nlogn)$。</p>
<p>归并排序的空间复杂度：</p>
<p>归并的空间复杂度就是那个临时的数组和递归时压入栈的数据占用的空间：n+logn；所以空间复杂度为: O(n)</p>
<p>归并排序的算法稳定度：</p>
<p>在归并排序中，相等的元素的顺序不会改变，所以它是<strong>稳定的</strong>算法。</p>
<h2 id="8-基数排序"><a href="#8-基数排序" class="headerlink" title="8. 基数排序"></a>8. 基数排序</h2><h3 id="8-1-基数排序算法思想及代码实现"><a href="#8-1-基数排序算法思想及代码实现" class="headerlink" title="8.1 基数排序算法思想及代码实现"></a>8.1 基数排序算法思想及代码实现</h3><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p>
<p>算法步骤：</p>
<ul>
<li>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。</li>
<li>从最低位开始，依次进行一次排序。</li>
<li>这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</li>
</ul>
<p>基数排序的方式可以采用 LSD（Least significant digital）或 MSD（Most significant digital），LSD 的排序方式由键值的最右边开始，而 MSD 则相反，由键值的最左边开始。</p>
<p>不妨通过一个具体的实例来展示一下基数排序是如何进行的。 设有一个初始序列为: R {50, 123, 543, 187, 49, 30, 0, 2, 11, 100}。</p>
<p>我们知道，任何一个阿拉伯数，它的各个位数上的基数都是以 0~9 来表示的，所以我们不妨把 0~9 视为 10 个桶。</p>
<p>我们先根据序列的个位数的数字来进行分类，将其分到指定的桶中。例如：R[0] = 50，个位数上是 0，将这个数存入编号为 0 的桶中。</p>
<p><img src="https://61mon.com/images/illustrations/Sort/10.png" alt="img"></p>
<p>分类后，我们在从各个桶中，将这些数按照从编号 0 到编号 9 的顺序依次将所有数取出来。这时，得到的序列就是个位数上呈递增趋势的序列。</p>
<p>按照个位数排序： {50, 30, 0, 100, 11, 2, 123, 543, 187, 49}。</p>
<p>接下来，可以对十位数、百位数也按照这种方法进行排序，最后就能得到排序完成的序列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求出数组中最大数的位数的函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxBit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 数组最大值</span></span><br><span class="line">	<span class="keyword">int</span> max_data = input[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; input.size(); i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (input[i] &gt; max_data)&#123;</span><br><span class="line">			max_data = input[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"max_data:"</span>&lt;&lt;max_data&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 数组最大值的位数</span></span><br><span class="line">	<span class="keyword">int</span> bits_num = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (max_data)&#123;</span><br><span class="line">		bits_num++;</span><br><span class="line">		max_data /= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"bits_num:"</span>&lt;&lt;bits_num&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> bits_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; RadixSort(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">int</span> n)&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bucket(n);	<span class="comment">//存储排序过程中的数据</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; count(<span class="number">10</span>);	<span class="comment">//位计数器，从第0个元素到第9个元素依次用来记录当前比较位是0的有多少个...是9的有多少个数</span></span><br><span class="line">	<span class="keyword">int</span> bits_num = MaxBit(input); <span class="comment">//求出数组中最大数的位数的函数</span></span><br><span class="line">	<span class="keyword">int</span> radix = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 从低位往高位循环</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">1</span>; d &lt;= bits_num; d++)&#123; </span><br><span class="line">		<span class="comment">// 计数器清0</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">			count[i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">// 统计各个桶中的个数</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> k=(input[i]/radix)%<span class="number">10</span>;<span class="comment">//取每个数字的末尾</span></span><br><span class="line">			count[k]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"before:"</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;count[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"after:   "</span>;</span><br><span class="line">		<span class="comment">//索引重分配</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">			count[i] += count[i - <span class="number">1</span>];<span class="comment">//count[i]表示第i个桶的右边界索引</span></span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;count[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//放入临时数组，从右到左扫描，保证排序稳定性</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">			<span class="keyword">int</span> k = (input[i]/radix)%<span class="number">10</span>;</span><br><span class="line">			bucket[count[k] - <span class="number">1</span>] = input[i];</span><br><span class="line">			count[k]--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"input:"</span>;</span><br><span class="line">		<span class="comment">// 临时数组复制到 input 中</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">			input[i] = bucket[i];</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;input[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		radix *= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> input;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[] = &#123; <span class="number">50</span>, <span class="number">123</span>, <span class="number">543</span>, <span class="number">187</span>, <span class="number">49</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">100</span> &#125;;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]));</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"排序前:"</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.size(); i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; test[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result = test;</span><br><span class="line">	result = RadixSort(result, result.size());</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"排序后:"</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; result[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-2-基数排序算法性能"><a href="#8-2-基数排序算法性能" class="headerlink" title="8.2 基数排序算法性能"></a>8.2 基数排序算法性能</h3><p>基数排序的时间复杂度是$O(k⋅n)$，其中$n$是排序元素个数，$k$是最大的数字位数。</p>
<p>空间复杂度是使用了两个临时的数组：10 + length；所以空间复杂度：$O(n)$</p>
<p>在基数排序过程中，每次都是将当前位数上相同数值的元素统一“装桶”，并不需要交换位置。所以基数排序是<strong>稳定</strong>的算法。</p>
<blockquote>
<p>本文参考整理自：</p>
<p><a href="http://cuijiahua.com/blog/2018/01/alogrithm_9.html" target="_blank" rel="noopener">http://cuijiahua.com/blog/2018/01/alogrithm_9.html</a></p>
<p><a href="https://61mon.com/index.php/archives/193/" target="_blank" rel="noopener">https://61mon.com/index.php/archives/193/</a></p>
<p><a href="http://www.cnblogs.com/jingmoxukong/p/4311237.html" target="_blank" rel="noopener">http://www.cnblogs.com/jingmoxukong/p/4311237.html</a></p>
</blockquote>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    hushhw
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://hushhw.cn/2018/02/13/11排序/" title="排序算法">https://hushhw.cn/2018/02/13/11排序/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/算法笔记/" rel="tag"># 算法笔记</a>
          
            <a href="/tags/排序/" rel="tag"># 排序</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/02/12/10CTGUOJ/" rel="next" title="CTGUOJ刷题目录">
                <i class="fa fa-chevron-left"></i> CTGUOJ刷题目录
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/02/20/12博弈/" rel="prev" title="博弈论总结">
                博弈论总结 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div id="gitalk-container">
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.gif"
                alt="hushhw" />
            
              <p class="site-author-name" itemprop="name">hushhw</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">31</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/hushhw" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:hushhw123@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://plus.google.com/hushhw123" target="_blank" title="Google">
                      
                        <i class="fa fa-fw fa-google"></i>Google</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://instagram.com/hushhw" target="_blank" title="Instagram">
                      
                        <i class="fa fa-fw fa-instagram"></i>Instagram</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://www.zhihu.com/people/hu-song-19" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-tags"></i>知乎</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/1929679982" target="_blank" title="微博">
                      
                        <i class="fa fa-fw fa-weibo"></i>微博</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://blog.csdn.net/hushhw" target="_blank" title="CSDN">
                      
                        <i class="fa fa-fw fa-tags"></i>CSDN</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.heyby.cn/" title="HEYBY" target="_blank">HEYBY</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#排序算法"><span class="nav-number">1.</span> <span class="nav-text">排序算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-冒泡排序"><span class="nav-number">1.1.</span> <span class="nav-text">1. 冒泡排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-冒泡排序算法思想及代码实现"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1 冒泡排序算法思想及代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-冒泡排序算法性能"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.2 冒泡排序算法性能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-冒泡排序优化"><span class="nav-number">1.1.3.</span> <span class="nav-text">1.3 冒泡排序优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-快速排序"><span class="nav-number">1.2.</span> <span class="nav-text">2. 快速排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-快速排序算法思想及代码实现"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1 快速排序算法思想及代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-快速排序算法性能"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.2 快速排序算法性能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-快速排序细节优化"><span class="nav-number">1.2.3.</span> <span class="nav-text">2.3 快速排序细节优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-直接插入排序"><span class="nav-number">1.3.</span> <span class="nav-text">3. 直接插入排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-插入排序算法思想及代码实现"><span class="nav-number">1.3.1.</span> <span class="nav-text">3.1 插入排序算法思想及代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-插入排序算法性能"><span class="nav-number">1.3.2.</span> <span class="nav-text">3.2 插入排序算法性能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-希尔排序"><span class="nav-number">1.4.</span> <span class="nav-text">4. 希尔排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-希尔排序算法思想及代码实现"><span class="nav-number">1.4.1.</span> <span class="nav-text">4.1 希尔排序算法思想及代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-希尔排序算法性能"><span class="nav-number">1.4.2.</span> <span class="nav-text">4.2 希尔排序算法性能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-希尔排序和直接插入排序比较"><span class="nav-number">1.4.3.</span> <span class="nav-text">4.3 希尔排序和直接插入排序比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-简单选择排序"><span class="nav-number">1.5.</span> <span class="nav-text">5. 简单选择排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-简单选择排序算法思想及代码实现"><span class="nav-number">1.5.1.</span> <span class="nav-text">5.1 简单选择排序算法思想及代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-简单选择排序算法性能"><span class="nav-number">1.5.2.</span> <span class="nav-text">5.2 简单选择排序算法性能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-堆排序"><span class="nav-number">1.6.</span> <span class="nav-text">6. 堆排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-堆排序算法思想及代码实现"><span class="nav-number">1.6.1.</span> <span class="nav-text">6.1 堆排序算法思想及代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-堆排序算法性能"><span class="nav-number">1.6.2.</span> <span class="nav-text">6.2 堆排序算法性能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-归并排序"><span class="nav-number">1.7.</span> <span class="nav-text">7. 归并排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-归并排序算法思想及代码实现"><span class="nav-number">1.7.1.</span> <span class="nav-text">7.1 归并排序算法思想及代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-归并排序算法性能"><span class="nav-number">1.7.2.</span> <span class="nav-text">7.2 归并排序算法性能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-基数排序"><span class="nav-number">1.8.</span> <span class="nav-text">8. 基数排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-基数排序算法思想及代码实现"><span class="nav-number">1.8.1.</span> <span class="nav-text">8.1 基数排序算法思想及代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-基数排序算法性能"><span class="nav-number">1.8.2.</span> <span class="nav-text">8.2 基数排序算法性能</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hushhw</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">50.4k</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  







  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_lines.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
   <script type="text/javascript">
        var gitalk = new Gitalk({
          clientID: '66a8ca9ffb45c03358c1',
          clientSecret: 'f8c4f55ca86ac99f07d3194a0a35ea7cdbdfbed9',
          repo: 'hushhw.github.io',
          owner: 'hushhw',
          admin: ['hushhw'],
          id: location.pathname,
          distractionFreeMode: 'true'
        })
        gitalk.render('gitalk-container')
       </script>



  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  


  

  

</body>
</html>
