<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hushhw&#39;s blog</title>
  
  <subtitle>身经百战见得多了</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hushhw.cn/"/>
  <updated>2018-05-22T15:22:04.756Z</updated>
  <id>https://hushhw.cn/</id>
  
  <author>
    <name>hushhw</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>hdu 1143 Tri Tiling</title>
    <link href="https://hushhw.cn/2018/05/22/28hdu1143/"/>
    <id>https://hushhw.cn/2018/05/22/28hdu1143/</id>
    <published>2018-05-21T17:12:26.000Z</published>
    <updated>2018-05-22T15:22:04.756Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1143" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1143</a></p><p><strong>Tri Tiling</strong></p><p>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)</p><p>Total Submission(s): 4746    Accepted Submission(s): 2699</p><p>Problem Description</p><p>In how many ways can you tile a 3xn rectangle with 2x1 dominoes? Here is a sample tiling of a 3x12 rectangle.</p><p> <img src="http://acm.hdu.edu.cn/data/images/1143-1.jpg" alt="img"></p><p>Input</p><p>Input consists of several test cases followed by a line containing -1. Each test case is a line containing an integer 0 ≤ n ≤ 30. </p><p>Output</p><p>For each test case, output one integer number giving the number of possible tilings. </p><p>Sample Input</p><p>2</p><p>8</p><p>12</p><p>-1</p><p>Sample Output</p><p>3</p><p>153</p><p>2131</p><p>Source</p><p>University of Waterloo Local Contest 2005.09.24</p><p>Recommend</p><p>Eddy   |   We have carefully selected several similar problems for you:  1133 1267 1297 1207 1249 </p></blockquote><p>思路：</p><p>​    递推真的是头疼。</p><p>​    首先应该是可以很轻松的知道两点和不太容易知道一点。</p><p>​        其一是奇数列的结果都为0，因为奇数列是填不满的。</p><p>​        其二是dp[2]=3，2X3时可以有3种情况。</p><p>​        其三，不太容易找到的规律，除了2有三种外，之后的偶数列不进行拆分都只有2种。</p><p>​    </p><p>​        面对4X3的情况，首先可以分割成两个2X3，即dp[2]*dp[2]=9，其次4X3整体考虑有两种情况，所以dp[4]=9+2=11。</p><p>​        面对6X3的情况，首先可以分割成三个2X3，即dp[2]^3 = 27,其次可以分割成一个4X3加一个2X3(可以交换位置，所以有两种），得2<em>3</em>2=12，最后对6X3整体考虑有两种，所以dp[6]=27+12+2=41</p><p>​    推到这里，我们大致找到规律了，但是没有递推转化式，但是只要我们稍微转换一下思维就可以得到下面的正确解法了。</p><p>​        用递推的思想来解决的话，可以这样考虑问题。</p><p>​        设dp[n]表示nX3的方块，那么分以下几步考虑：</p><p>​        1.  整体不进行划分（指的是不考虑子问题），前面提到了第三点，共2 种情况，这里我们换一个角度相就是将前n列方块和最后0列方块划分考虑，即2*dp[0]；</p><p>​        2.  将最后面两列和前面的n-2列分开考虑，此时就是一个子问题：dp[2]<em>dp[n-2] = 3</em>dp[n-2]；</p><p>​        3.  继续将最后面的四列和前面的n-4分开考虑，此时就是子问题：dp[4]<em>dp[n-4] = 2</em>dp[n-4];</p><p>​        4.  继续将最后面的六列和前面的n-6分开考虑，此时就是子问题：dp[6]<em>dp[n-6] = 2</em>dp[n-6];</p><p>​            ……</p><p>​        若干次划分后，我们得到dp[n] = 3<em>dp[n-2] + 2</em>(dp[n-4]+dp[n-6]+……+dp[0]);</p><p>​        而进行一下简单的推导可得，dp[n-2] = 3<em>dp[n-4] + 2</em>(dp[n-6]+……+dp[0]);</p><p>​        将两式相减就可以得到 dp[n] = 4*dp[n-2] - dp[n-4]；</p><p>​        其中dp[0]=1;是一个比较容易弄错的点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;  </span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">31</span>+<span class="number">10</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> dp[maxn],n;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;  </span><br><span class="line">    dp[<span class="number">2</span>]=<span class="number">3</span>;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">4</span>;i&lt;=<span class="number">32</span>;i++)  </span><br><span class="line">        dp[i]=<span class="number">4</span>*dp[i<span class="number">-2</span>]-dp[i<span class="number">-4</span>];  </span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)&amp;&amp;n!=<span class="number">-1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>)  <span class="built_in">printf</span>(<span class="string">"0\n"</span>);  </span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[n]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=1143&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://acm.hdu.edu.cn/showproblem.ph
      
    
    </summary>
    
      <category term="学习" scheme="https://hushhw.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="OJ刷题" scheme="https://hushhw.cn/categories/%E5%AD%A6%E4%B9%A0/OJ%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="OJ" scheme="https://hushhw.cn/tags/OJ/"/>
    
      <category term="刷题" scheme="https://hushhw.cn/tags/%E5%88%B7%E9%A2%98/"/>
    
      <category term="hdu" scheme="https://hushhw.cn/tags/hdu/"/>
    
      <category term="递推" scheme="https://hushhw.cn/tags/%E9%80%92%E6%8E%A8/"/>
    
  </entry>
  
  <entry>
    <title>Markdown中Latex数学公式基本语法</title>
    <link href="https://hushhw.cn/2018/05/18/27markdownLatex/"/>
    <id>https://hushhw.cn/2018/05/18/27markdownLatex/</id>
    <published>2018-05-18T06:56:04.000Z</published>
    <updated>2018-05-19T06:40:13.907Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Markdown中Latex-数学公式基本语法"><a href="#Markdown中Latex-数学公式基本语法" class="headerlink" title="Markdown中Latex 数学公式基本语法"></a>Markdown中Latex 数学公式基本语法</h2><h3 id="公式排版"><a href="#公式排版" class="headerlink" title="公式排版"></a>公式排版</h3><p>分为两种排版： </p><ul><li><p>行内公式：用\\或者$包裹公式</p></li><li><p>独立公式：用$$包裹公式</p><p>例如: </p><script type="math/tex; mode=display">\sum_{i=0}^{n}i^2 $$ 表示 $ \sum_{i=0}^{n}i^2 $$$$ \sum_{i=0}^{n}i^2 $$$ 表示</script><p>\sum_{i=0}^{n}i^2</p><script type="math/tex; mode=display">`\boxed`命令给公式加一个方框 $$$ E = mc^2 $$$ =></script><p>E = mc^2<br>$$</p></li></ul><script type="math/tex; mode=display">\boxed{E=mc^2}</script><script type="math/tex; mode=display">\boxed{E=mc^2}</script><h3 id="上下标和根号"><a href="#上下标和根号" class="headerlink" title="上下标和根号"></a>上下标和根号</h3><p>用^来表示上标， 用_来表示下标，根号用\sqrt表示，上下标如果多余一个字符或符号，需要用{}括起来。<br>\sqrt[开方次数，默认为2]{开方公式}， 例如 </p><script type="math/tex; mode=display">\sum_{i=1}^n a_i$$ => $\sum_{i=1}^n a_i$$$f(x) = x^{x^x}$$ => $f(x) = x^{x^x}$$$$ x_{ij}^2\quad \sqrt{x}\quad \sqrt[3]{x} $$$ =></script><p>x_{ij}^2\quad \sqrt{x}\quad \sqrt[3]{x}</p><script type="math/tex; mode=display">其中\quad表示添加空格### 分数分数用\frac表示，字号工具环境设置，\dfrac命令把字号设置为独立公式中的大小，\tfrac则把字号设置为行间公式中的大小。 $$ \frac{1}{2}  \quad \dfrac{1}{2} $$ = > $ \frac{1}{2} \quad \dfrac{1}{2} $$$$ \frac{1}{2} \tfrac{1}{2} $$$ =></script><p>\frac{1}{2} \quad \tfrac{1}{2}</p><script type="math/tex; mode=display">### 运算符\+ - * / = 直接输入，特殊运算则用以下特殊命令 $$ \pm\$$=> $ \pm\ $$$ \times\$$=> $ \times\ $$$ \div\$$=> $ \div\ $$$ \cdot\$$=> $ \cdot\ $$$ \cap\$$=> $ \cap\ $$$ \cup\$$=> $ \cup\ $$$ \geq\$$=> $ \geq\ $$$ \leq\$$=> $ \leq\ $$$ \neq\$$=> $ \neq\ $$$ \approx\$$=> $ \approx\ $$$ \equiv\$$=> $ \equiv\ $和、积、极限、积分等运算符用\sum, \prod, \lim, \int,这些公式在行内公式被压缩，以适应行高，可以通过\limits和\nolimits命令显示制动是否压缩。 $$ \sum\$$=> $ \sum\ $$$ \prod\$$=> $ \prod\ $$$ \lim\$$=> $ \lim\ $$$ \int\$$=> $ \int\ $</script><p>\sum\; \prod\; \lim\; \int\;</p><script type="math/tex; mode=display">多重积分可以用如下形式表示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$ \int\int\quad \int\int\int\quad</span><br><span class="line">   \int\int\int\int\quad \int\dots\int</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">$$</span><br><span class="line">\iint\quad \iiint\quad \iiiint\quad \idotsint</span><br><span class="line">$$</span><br></pre></td></tr></table></figure></script><p>\int\int\quad \int\int\int\quad</p><p>   \int\int\int\int\quad \int\dots\int</p><script type="math/tex; mode=display"></script><p>\iint\quad \iiint\quad \iiiint\quad \idotsint</p><script type="math/tex; mode=display">​    ### 箭头$$ \leftarrow $$ => $ \leftarrow $　　　　 　         $$ \rightarrow $$ 表示$ \rightarrow $$$ \leftrightarrow $$表示　$ \leftrightarrow $　　　     $$\Leftarrow$$表示$\Leftarrow$$$\Rightarrow$$ 表示$\Rightarrow$                    $$ \Leftrightarrow$$表示$ \Leftrightarrow$$$ \longleftarrow $$表示 $ \longleftarrow $             $$ \longleftarrow $$表示$ \longleftarrow $$$\longleftrightarrow$$表示$ \longleftrightarrow $         $$ \Longleftarrow $$表示$ \Longleftarrow $$$\Longrightarrow$$表示$\Longrightarrow$             $$\Longleftrightarrow$$表示$\Longleftrightarrow$`\xleftarrow和\xrightarrow`可根据内容自动调整<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\xleftarrow&#123;x+y+z&#125; \quad \xrightarrow[x&lt;y]&#123;x+y+z&#125;</span><br></pre></td></tr></table></figure>结果如下:</script><p> \xleftarrow{x+y+z} \quad \xrightarrow[x&lt;y]{x+y+z}</p><script type="math/tex; mode=display">### 省略号省略号用 `\dots \cdots \vdots \ddots`表示 ，`\dots和\cdots`的纵向位置不同，前者一般用于有下标的序列$$$ x_1, x_2, \dots, x_n\quad 1,2,\cdots,n\quad \vdots\quad \ddots $</script><p>结果如下：</p><script type="math/tex; mode=display">x_1, x_2, \dots, x_n\quad 1,2,\cdots,n\quad \vdots\quad \ddots</script><h3 id="多行公式"><a href="#多行公式" class="headerlink" title="多行公式"></a>多行公式</h3><h4 id="长公式"><a href="#长公式" class="headerlink" title="长公式"></a>长公式</h4><p>无需对齐可使用<code>multline</code>，需要对齐使用<code>split</code>，用<code>\\和&amp;</code>来分行和设置对齐的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;multline&#125;</span><br><span class="line">x = a+b+c+ \\</span><br><span class="line">    d+e+f+g</span><br><span class="line">  \end&#123;multline&#125;</span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">\begin{multline}    x = a+b+c+ \\            d+e+f+g  \end{multline}</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;split&#125;</span><br><span class="line">x = &#123;&#125; &amp; a + b + c +&#123;&#125;\\</span><br><span class="line">&amp;d + e + f + g</span><br><span class="line">\end&#123;split&#125;</span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">\begin{split}x = {} & a + b + c +{}\\    &d + e + f + g\end{split}</script><h4 id="公式组"><a href="#公式组" class="headerlink" title="公式组"></a>公式组</h4><p>不需要对齐的公式组用<code>gather</code>，需要对齐使用<code>align</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;gather&#125;</span><br><span class="line">a = b+c+d\\</span><br><span class="line">x=y+z</span><br><span class="line">\end&#123;gather&#125;</span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">\begin{gather}a = b+c+d\\x=y+z\end{gather}</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;align&#125;</span><br><span class="line">a &amp;=b+c+d \\</span><br><span class="line">x &amp;=y+z</span><br><span class="line">\end&#123;align&#125;</span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">\begin{align}a &=b+c+d \\x &=y+z\end{align}</script><h4 id="分支公式"><a href="#分支公式" class="headerlink" title="分支公式"></a>分支公式</h4><p>分段函数通常用cases</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">y=\begin&#123;cases&#125;</span><br><span class="line">-x,\quad x\leq 0\\</span><br><span class="line">x, \quad x&gt;0</span><br><span class="line">\end&#123;cases&#125;</span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">y=\begin{cases}-x,\quad x\leq 0\\x, \quad x>0\end{cases}</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Markdown中Latex-数学公式基本语法&quot;&gt;&lt;a href=&quot;#Markdown中Latex-数学公式基本语法&quot; class=&quot;headerlink&quot; title=&quot;Markdown中Latex 数学公式基本语法&quot;&gt;&lt;/a&gt;Markdown中Latex 数学
      
    
    </summary>
    
      <category term="学习" scheme="https://hushhw.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="markdown" scheme="https://hushhw.cn/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>卡特兰数(catalan number)</title>
    <link href="https://hushhw.cn/2018/05/18/26catalan-number/"/>
    <id>https://hushhw.cn/2018/05/18/26catalan-number/</id>
    <published>2018-05-18T06:28:22.000Z</published>
    <updated>2018-05-19T06:41:29.490Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>卡特兰数</strong> 又称卡塔兰数，卡特兰数是组合数学中一个常出现在各种计数问题中的数列。以比利时的数学家欧仁·查理·卡塔兰 (1814–1894)的名字来命名。</p></blockquote><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>令h(0)=1, h(1)=1，catalan数满足递推式：</p><script type="math/tex; mode=display">h(n) = h(0)*h(n-1)+h(1)*h(n-2)+\dots+h(n-1)*h(0) (n>=2)</script><p>例如：$h(2) = h(0)<em>h(1)+h(1)</em>h(0) = 1<em>1+1</em>1 = 2$</p><p>​        $h(3) = h(0)<em>h(2)+h(1)</em>h(1)+h(2)<em>h(0) = 1</em>2+1<em>1+2</em>1 = 5$</p><p>另类推导式：</p><script type="math/tex; mode=display">h(n) = \frac{h(n-1)*(4*n-2)}{n+1};</script><p>递推关系的解为：</p><script type="math/tex; mode=display">h(n) = \frac{C_{2n}^n}{n+1} (n=0,1,2,\dots)</script><p>递推关系的另类解为：</p><script type="math/tex; mode=display">h(n) = C_{2n}^n - C_{2n}^{n-1} (n=0,1,2,\dots)</script><p>其前几项为 : 1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670, 129644790, 477638700, 1767263190, 6564120420, 24466267020, 91482563640, 343059613650, 1289904147324, 4861946401452, …</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p><strong>括号化</strong> ：矩阵连乘： P=a1×a2×a3×……×an，依据乘法结合律，不改变其顺序，只用括号表示成对的乘积，试问有几种括号化的方案？</p><p><strong>出栈次序</strong> ：一个栈(无穷大)的进栈序列为1，2，3，…，n，有多少个不同的出栈序列?</p><p><strong>凸多边形三角划分</strong> ：在一个凸多边形中，通过若干条互不相交的对角线，把这个多边形划分成了若干个三角形。任务是键盘上输入凸多边形的边数n，求不同划分的方案数f（n）。比如当n=6时，f（6）=14。</p><p>更多应用见：<a href="https://blog.csdn.net/jiejinquanil/article/details/52153045" target="_blank" rel="noopener">https://blog.csdn.net/jiejinquanil/article/details/52153045</a></p><p>原始代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">__int64 catalan[<span class="number">40</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">catalan</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(catalan, <span class="number">0</span>, <span class="keyword">sizeof</span>(catalan));</span><br><span class="line">  catalan[<span class="number">0</span>] = catalan[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=<span class="number">35</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++)&#123;</span><br><span class="line">      catalan[i] += catalan[j]*catalan[i-j<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大数代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">catalan</span><span class="params">()</span> <span class="comment">//求卡特兰数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, len, carry, temp;</span><br><span class="line">    a[<span class="number">1</span>][<span class="number">0</span>] = b[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; len; j++) <span class="comment">//乘法</span></span><br><span class="line">        a[i][j] = a[i<span class="number">-1</span>][j]*(<span class="number">4</span>*(i<span class="number">-1</span>)+<span class="number">2</span>);</span><br><span class="line">        carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; len; j++) <span class="comment">//处理相乘结果</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp = a[i][j] + carry;</span><br><span class="line">            a[i][j] = temp % <span class="number">10</span>;</span><br><span class="line">            carry = temp / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(carry) <span class="comment">//进位处理</span></span><br><span class="line">        &#123;</span><br><span class="line">            a[i][len++] = carry % <span class="number">10</span>;</span><br><span class="line">            carry /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = len<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--) <span class="comment">//除法</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp = carry*<span class="number">10</span> + a[i][j];</span><br><span class="line">            a[i][j] = temp/(i+<span class="number">1</span>);</span><br><span class="line">            carry = temp%(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!a[i][len<span class="number">-1</span>]) <span class="comment">//高位零处理</span></span><br><span class="line">        len --;</span><br><span class="line">        b[i] = len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><blockquote><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2067" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=2067</a></p><p>小兔的棋盘</p><p>Time Limit: 1000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)</p><p>Total Submission(s): 12397    Accepted Submission(s): 6201</p><p>Problem Description</p><p>小兔的叔叔从外面旅游回来给她带来了一个礼物，小兔高兴地跑回自己的房间，拆开一看是一个棋盘，小兔有所失望。</p><p>不过没过几天发现了棋盘的好玩之处。</p><p>从起点(0，0)走到终点(n,n)的最短路径数是C(2n,n),现在小兔又想如果不穿越对角线(但可接触对角线上的格点)，这样的路径数有多少?</p><p>小兔想了很长时间都没想出来，现在想请你帮助小兔解决这个问题，对于你来说应该不难吧!</p><p>Input</p><p>每次输入一个数n(1&lt;=n&lt;=35)，当n等于－1时结束输入。</p><p>Output</p><p>对于每个输入数据输出路径数，具体格式看Sample。</p><p>Sample Input</p><p>1</p><p>3</p><p>12</p><p>-1</p><p>Sample Output</p><p>1 1 2</p><p>2 3 10</p><p>3 12 416024</p><p>Author</p><p>Rabbit</p><p>Source</p><p>RPG专场练习赛</p><p>Recommend</p><p>lcy   |   We have carefully selected several similar problems for you:  1133 2068 1267 2069 1134 </p><p>/*</p><p>题目分析：为什么这个题要用卡特兰数呢？因为它的过程可以抽象成前例的样子，</p><p>​         比如说先往下走，在往下走了一步的情况下，就可以往右走一步，这样向下走就等同于进栈，向右走就等同于出栈，有了卡特兰数的知识，这题就相当水了。（别忘了最后要乘2啊，因为只要满足不穿过对角线的话，先往下和先往右都可以的）</p><p>输出: 第一个数字是数据的组数，第二个数是输入的数，第三个则是路径数。</p><p>*/</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll catalan[<span class="number">40</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">catalans</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(catalan, <span class="number">0</span>, <span class="keyword">sizeof</span>(catalan));</span><br><span class="line">    catalan[<span class="number">0</span>] = catalan[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">35</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;i; j++)&#123;</span><br><span class="line">            catalan[i] += catalan[j] * catalan[i - j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    catalans();</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF &amp;&amp; n!=<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d %lld\n"</span>, t++, n, catalan[n] * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;卡特兰数&lt;/strong&gt; 又称卡塔兰数，卡特兰数是组合数学中一个常出现在各种计数问题中的数列。以比利时的数学家欧仁·查理·卡塔兰 (1814–1894)的名字来命名。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;原理&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="学习" scheme="https://hushhw.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法笔记" scheme="https://hushhw.cn/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
      <category term="卡特兰数" scheme="https://hushhw.cn/tags/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>hdu 2056 一个人的旅行（最短路径）</title>
    <link href="https://hushhw.cn/2018/05/17/25hdu2066/"/>
    <id>https://hushhw.cn/2018/05/17/25hdu2066/</id>
    <published>2018-05-17T09:17:48.000Z</published>
    <updated>2018-05-21T17:13:50.941Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2066" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=2066</a></p><p>一个人的旅行</p><p>Time Limit: 1000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)</p><p>Total Submission(s): 47739    Accepted Submission(s): 15835</p><p>Problem Description</p><p>虽然草儿是个路痴（就是在杭电待了一年多，居然还会在校园里迷路的人，汗~),但是草儿仍然很喜欢旅行，</p><p>因为在旅途中 会遇见很多人（白马王子，^0^），很多事，还能丰富自己的阅历，还可以看美丽的风景……草儿想去很多地方，</p><p>她想要去东京铁塔看夜景，去威尼斯看电影，去阳明山上看海芋，去纽约纯粹看雪景，去巴黎喝咖啡写信，去北京探望孟姜女……</p><p>眼看寒么一大段时间，可不能浪费啊，假就快到了，这一定要给自己好好的放个假，可是也不能荒废了训练啊，</p><p>所以草儿决定在要在最短的时间去一个自己想去的地方！</p><p>因为草儿的家在一个小镇上，没有火车经过，所以她只能去邻近的城市坐火车（好可怜啊~）。</p><p>Input</p><p>输入数据有多组，每组的第一行是三个整数T，S和D，表示有T条路，和草儿家相邻的城市的有S个，草儿想去的地方有D个；</p><p>接着有T行，每行有三个整数a，b，time,表示a,b城市之间的车程是time小时；(1=&lt;(a,b)&lt;=1000;a,b 之间可能有多条路)</p><p>接着的第T+1行有S个数，表示和草儿家相连的城市；</p><p>接着的第T+2行有D个数，表示草儿想去地方。</p><p>Output</p><p>输出草儿能去某个喜欢的城市的最短时间。</p><p>Sample Input</p><p>6 2 3</p><p>1 3 5</p><p>1 4 7</p><p>2 8 12</p><p>3 8 4</p><p>4 9 12</p><p>9 10 2</p><p>1 2</p><p>8 9 10</p><p>Sample Output</p><p>9</p><p>Author</p><p>Grass</p><p>Source</p><p>RPG专场练习赛</p><p>Recommend</p><p>lcy   |   We have carefully selected several similar problems for you:  2544 1874 2112 1217 1548 </p><p>/*</p><p>思路：</p><p>​    题目考察最短路径问题，但是题目中有一些小变化。</p><p>​    建表的时候，注意和她的家相邻的点要设为0，然后题目就变成了从0站点到终点的几个点最短距离问题</p><p>*/</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dijkstra</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> start[<span class="number">1001</span>], direction[<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(dis, INF, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    dis[x] = <span class="number">0</span>;</span><br><span class="line">    vis[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;=n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[j] &amp;&amp; dis[j] &gt; <span class="built_in">map</span>[x][j] + dis[x])</span><br><span class="line">                dis[j] = <span class="built_in">map</span>[x][j] + dis[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> minn = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;=n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[j] &amp;&amp; dis[j]&lt;minn)&#123;</span><br><span class="line">                minn = dis[j];</span><br><span class="line">                x = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[x] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct node&#123;</span></span><br><span class="line"><span class="comment">    int id;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    friend bool operator &lt;(node a, node b)&#123;</span></span><br><span class="line"><span class="comment">        return a.val &gt; b.val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125; pre, nt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">void dijkstra(int x)&#123;</span></span><br><span class="line"><span class="comment">    memset(vis, 0, sizeof(vis));</span></span><br><span class="line"><span class="comment">    memset(dis, INF, sizeof(dis));</span></span><br><span class="line"><span class="comment">    dis[x] = 0; //初始化dis[0]=0,其它都还是INF</span></span><br><span class="line"><span class="comment">    priority_queue&lt;node&gt; q; //优先队列q，初始存储x点的信息</span></span><br><span class="line"><span class="comment">    pre.id = x; </span></span><br><span class="line"><span class="comment">    pre.val = 0;</span></span><br><span class="line"><span class="comment">    q.push(pre);</span></span><br><span class="line"><span class="comment">    while(!q.empty())&#123;</span></span><br><span class="line"><span class="comment">        pre = q.top();</span></span><br><span class="line"><span class="comment">        q.pop();</span></span><br><span class="line"><span class="comment">        int id = pre.id, val = pre.val;</span></span><br><span class="line"><span class="comment">        vis[id] = 1;</span></span><br><span class="line"><span class="comment">        for (int i = 1; i &lt;= n; i++)&#123; //遍历每一个城市</span></span><br><span class="line"><span class="comment">            if(!vis[i] &amp;&amp; dis[i]&gt;map[id][i] + val)&#123; //如果该城市未被遍历过，并且dis[i]&gt;map[id][i]+val,更新</span></span><br><span class="line"><span class="comment">                dis[i] = map[id][i] + val;</span></span><br><span class="line"><span class="comment">                nt.id = i;</span></span><br><span class="line"><span class="comment">                nt.val = val + map[id][i]; //这里存储的是到初始点的距离</span></span><br><span class="line"><span class="comment">                q.push(nt);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T, S, D;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;T,&amp;S,&amp;D)!=EOF)&#123;</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1001</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">1001</span>; j++)&#123; <span class="comment">//首先建表</span></span><br><span class="line">                <span class="keyword">if</span>(i==j)</span><br><span class="line">                    <span class="built_in">map</span>[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">map</span>[i][j] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a, b, time;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; i++)&#123; <span class="comment">//相连的城市，更新它们的距离</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;time);</span><br><span class="line">            n = max(max(a, b), n); <span class="comment">//最大的城市</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[a][b]&gt;time)</span><br><span class="line">                <span class="built_in">map</span>[a][b] = <span class="built_in">map</span>[b][a] = time;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;S; i++)&#123; <span class="comment">//起始城市更新它们的map距离与0为0</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;start[i]);</span><br><span class="line">            <span class="built_in">map</span>[<span class="number">0</span>][start[i]] = <span class="built_in">map</span>[start[i]][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;D; i++)&#123; <span class="comment">//终点城市</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;direction[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        dijkstra(<span class="number">0</span>); <span class="comment">//起点从0开始</span></span><br><span class="line">        <span class="keyword">int</span> mi = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; D; i++)&#123;</span><br><span class="line">            mi = min(dis[direction[i]], mi);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, mi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//floyd</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> start[<span class="number">1001</span>], direction[<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T, S, D;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;T,&amp;S,&amp;D)!=EOF)&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1001</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">1001</span>; j++)&#123; <span class="comment">//首先建表</span></span><br><span class="line">                <span class="keyword">if</span>(i==j) <span class="built_in">map</span>[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">map</span>[i][j] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a, b, time;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; i++)&#123; <span class="comment">//相连的城市，更新它们的距离</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;time);</span><br><span class="line">            n = max(max(a, b), n); <span class="comment">//最大的城市</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[a][b]&gt;time)</span><br><span class="line">                <span class="built_in">map</span>[a][b] = <span class="built_in">map</span>[b][a] = time;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(start, <span class="number">0</span>, <span class="keyword">sizeof</span>(start));</span><br><span class="line">        <span class="built_in">memset</span>(direction, <span class="number">0</span>, <span class="keyword">sizeof</span>(direction));</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;S; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;temp);</span><br><span class="line">            start[temp] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;D; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;temp);</span><br><span class="line">            direction[temp] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mi = INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)  &#123;  </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)  &#123;  </span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">map</span>[i][k]==INF) </span><br><span class="line">                    <span class="keyword">continue</span>;  </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)  &#123;  </span><br><span class="line">                    <span class="keyword">if</span>(i==j) </span><br><span class="line">                        <span class="keyword">continue</span>;  </span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">map</span>[i][k]+<span class="built_in">map</span>[k][j]&lt;<span class="built_in">map</span>[i][j])  </span><br><span class="line">                        <span class="built_in">map</span>[i][j]=<span class="built_in">map</span>[j][i]=<span class="built_in">map</span>[i][k]+<span class="built_in">map</span>[k][j];  </span><br><span class="line">                    <span class="keyword">if</span>(start[i] &amp;&amp; direction[j] &amp;&amp; mi&gt;<span class="built_in">map</span>[i][j])</span><br><span class="line">                        mi = <span class="built_in">map</span>[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, mi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=2066&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://acm.hdu.edu.cn/showproblem.ph
      
    
    </summary>
    
      <category term="学习" scheme="https://hushhw.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="OJ刷题" scheme="https://hushhw.cn/categories/%E5%AD%A6%E4%B9%A0/OJ%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="OJ" scheme="https://hushhw.cn/tags/OJ/"/>
    
      <category term="刷题" scheme="https://hushhw.cn/tags/%E5%88%B7%E9%A2%98/"/>
    
      <category term="最短路" scheme="https://hushhw.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="hdu" scheme="https://hushhw.cn/tags/hdu/"/>
    
  </entry>
  
  <entry>
    <title>如何理解 KMP</title>
    <link href="https://hushhw.cn/2018/05/16/24KMP/"/>
    <id>https://hushhw.cn/2018/05/16/24KMP/</id>
    <published>2018-05-16T13:53:44.000Z</published>
    <updated>2018-05-16T14:43:55.412Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：背景"><a href="#一：背景" class="headerlink" title="一：背景"></a>一：背景</h2><p>给定一个主串（以 S 代替）和模式串（以 P 代替），要求找出 P 在 S 中出现的位置，此即串的模式匹配问题。</p><p>Knuth-Morris-Pratt 算法（简称 KMP）是解决这一问题的常用算法之一，这个算法是由高德纳（Donald Ervin Knuth）和沃恩·普拉特在1974年构思，同年詹姆斯·H·莫里斯也独立地设计出该算法，最终三人于1977年联合发表。</p><p>在继续下面的内容之前，有必要在这里介绍下两个概念：<strong>真前缀</strong> 和 <strong>真后缀</strong>。</p><p><img src="http://p86wg7kc2.bkt.clouddn.com/24kmp1.png" alt=""></p><p>由上图所得， “真前缀”指除了自身以外，一个字符串的全部头部组合；”真后缀”指除了自身以外，一个字符串的全部尾部组合。（网上很多博客，应该说是几乎所有的博客，也包括我以前写的，都是“前缀”。严格来说，“真前缀”和“前缀”是不同的，既然不同，还是不要混为一谈的好！）</p><h2 id="二：朴素字符串匹配算法"><a href="#二：朴素字符串匹配算法" class="headerlink" title="二：朴素字符串匹配算法"></a>二：朴素字符串匹配算法</h2><p>初遇串的模式匹配问题，我们脑海中的第一反应，就是朴素字符串匹配（即所谓的暴力匹配），代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 字符串下标始于 0 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NaiveStringSearch</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;    <span class="comment">// S 的下标</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;    <span class="comment">// P 的下标</span></span><br><span class="line"><span class="keyword">int</span> s_len = S.size();</span><br><span class="line"><span class="keyword">int</span> p_len = P.size();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; s_len &amp;&amp; j &lt; p_len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (S[i] == P[j])  <span class="comment">// 若相等，都前进一步</span></span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>               <span class="comment">// 不相等</span></span><br><span class="line">&#123;</span><br><span class="line">i = i - j + <span class="number">1</span>;</span><br><span class="line">j = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (j == p_len)        <span class="comment">// 匹配成功</span></span><br><span class="line"><span class="keyword">return</span> i - j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>暴力匹配的时间复杂度为 $O(nm)$，其中 $n$ 为 S 的长度，$m$ 为 P 的长度。很明显，这样的时间复杂度很难满足我们的需求。</p><p>接下来进入正题：时间复杂度为 $Θ(n+m)$ 的 KMP 算法。</p><h2 id="三：KMP字符串匹配算法"><a href="#三：KMP字符串匹配算法" class="headerlink" title="三：KMP字符串匹配算法"></a>三：KMP字符串匹配算法</h2><h3 id="3-1-算法流程"><a href="#3-1-算法流程" class="headerlink" title="3.1 算法流程"></a>3.1 算法流程</h3><p>以下摘自阮一峰的<a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">字符串匹配的KMP算法</a>，并作稍微修改。</p><p>（1）</p><p><img src="http://p86wg7kc2.bkt.clouddn.com/20180402_02.png" alt=""></p><p>首先，主串”BBC ABCDAB ABCDABCDABDE”的第一个字符与模式串”ABCDABD”的第一个字符，进行比较。因为B与A不匹配，所以模式串后移一位。</p><p>（2）</p><p><img src="http://p86wg7kc2.bkt.clouddn.com/20180402_03.png" alt=""></p><p>因为B与A又不匹配，模式串再往后移。</p><p>（3）</p><p><img src="http://p86wg7kc2.bkt.clouddn.com/20180402_04.png" alt=""></p><p>就这样，直到主串有一个字符，与模式串的第一个字符相同为止。</p><p>（4）</p><p><img src="http://p86wg7kc2.bkt.clouddn.com/20180402_05.png" alt=""></p><p>接着比较主串和模式串的下一个字符，还是相同。</p><p>（5）</p><p><img src="http://p86wg7kc2.bkt.clouddn.com/20180402_06.png" alt=""></p><p>直到主串有一个字符，与模式串对应的字符不相同为止。</p><p>（6）</p><p><img src="http://p86wg7kc2.bkt.clouddn.com/20180402_07.png" alt=""></p><p>这时，最自然的反应是，将模式串整个后移一位，再从头逐个比较。这样做虽然可行，但是效率很差，因为你要把”搜索位置”移到已经比较过的位置，重比一遍。</p><p>（7）</p><p><img src="http://p86wg7kc2.bkt.clouddn.com/20180402_08.png" alt=""></p><p>一个基本事实是，当空格与D不匹配时，你其实是已经知道前面六个字符是”ABCDAB”。KMP算法的想法是，设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，而是继续把它向后移，这样就提高了效率。</p><p>（8）</p><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th></tr></thead><tbody><tr><td style="text-align:center">模式串</td><td style="text-align:center">A</td><td style="text-align:center">B</td><td style="text-align:center">C</td><td style="text-align:center">D</td><td style="text-align:center">A</td><td style="text-align:center">B</td><td style="text-align:center">D</td><td style="text-align:center">‘\\0’</td></tr><tr><td style="text-align:center">next[i]</td><td style="text-align:center">-1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">0</td></tr></tbody></table></div><p>怎么做到这一点呢？可以针对模式串，设置一个跳转数组<code>int next[]</code>，这个数组是怎么计算出来的，后面再介绍，这里只要会用就可以了。</p><p>（9）</p><p><img src="http://p86wg7kc2.bkt.clouddn.com/20180402_09.png" alt=""></p><p>已知空格与D不匹配时，前面六个字符”ABCDAB”是匹配的。根据跳转数组可知，不匹配处D的next值为2，因此接下来<strong>从模式串下标为2的位置开始匹配</strong>。</p><p>（10）</p><p><img src="http://p86wg7kc2.bkt.clouddn.com/20180402_10.png" alt=""></p><p>因为空格与Ｃ不匹配，C处的next值为0，因此接下来模式串从下标为0处开始匹配。</p><p>（11）</p><p><img src="http://p86wg7kc2.bkt.clouddn.com/20180402_11.png" alt=""></p><p>因为空格与A不匹配，此处next值为-1，表示模式串的第一个字符就不匹配，那么直接往后移一位。</p><p>（12）</p><p><img src="http://p86wg7kc2.bkt.clouddn.com/20180402_12.png" alt=""></p><p>逐位比较，直到发现C与D不匹配。于是，下一步从下标为2的地方开始匹配。</p><p>（13）</p><p><img src="http://p86wg7kc2.bkt.clouddn.com/20180402_13.png" alt=""></p><p>逐位比较，直到模式串的最后一位，发现完全匹配，于是搜索完成。</p><h3 id="3-2-next数组是如何求出的"><a href="#3-2-next数组是如何求出的" class="headerlink" title="3.2 next数组是如何求出的"></a>3.2 next数组是如何求出的</h3><p>next数组的求解基于“真前缀”和“真后缀”，即<code>next[i]</code>等于<code>P[0]...P[i - 1]</code>最长的相同真前后缀的长度（请暂时忽视i等于0时的情况，下面会有解释）。我们依旧以上述的表格为例，为了方便阅读，我复制在下方了。</p><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th></tr></thead><tbody><tr><td style="text-align:center">模式串</td><td style="text-align:center">A</td><td style="text-align:center">B</td><td style="text-align:center">C</td><td style="text-align:center">D</td><td style="text-align:center">A</td><td style="text-align:center">B</td><td style="text-align:center">D</td><td style="text-align:center">‘\\0’</td></tr><tr><td style="text-align:center">next[ i ]</td><td style="text-align:center">-1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">0</td></tr></tbody></table></div><p>（1）：i = 0，对于模式串的首字符，我们统一为<code>next[0] = -1</code>；<br>（2）：i = 1，前面的字符串为<code>A</code>，其最长相同真前后缀长度为0，即<code>next[1] = 0</code>；<br>（3）：i = 2，前面的字符串为<code>AB</code>，其最长相同真前后缀长度为0，即<code>next[2] = 0</code>；<br>（4）：i = 3，前面的字符串为<code>ABC</code>，其最长相同真前后缀长度为0，即<code>next[3] = 0</code>；<br>（5）：i = 4，前面的字符串为<code>ABCD</code>，其最长相同真前后缀长度为0，即<code>next[4] = 0</code>；<br>（6）：i = 5，前面的字符串为<code>ABCDA</code>，其最长相同真前后缀为<code>A</code>，即<code>next[5] = 1</code>；<br>（7）：i = 6，前面的字符串为<code>ABCDAB</code>，其最长相同真前后缀为<code>AB</code>，即<code>next[6] = 2</code>；<br>（8）：i = 7，前面的字符串为<code>ABCDABD</code>，其最长相同真前后缀长度为0，即<code>next[7] = 0</code>。</p><p>那么，为什么根据最长相同真前后缀的长度就可以实现在不匹配情况下的跳转呢？举个代表性的例子：假如<code>i = 6</code>时不匹配，此时我们是知道其位置前的字符串为<code>ABCDAB</code>，仔细观察这个字符串，首尾都有一个<code>AB</code>，既然在<code>i = 6</code>处的D不匹配，我们为何不直接把<code>i = 2</code>处的C拿过来继续比较呢，因为都有一个<code>AB</code>啊，而这个<code>AB</code>就是<code>ABCDAB</code>的最长相同真前后缀，其长度2正好是跳转的下标位置。</p><p>有的读者可能存在疑问，若在<code>i = 5</code>时匹配失败，按照我讲解的思路，此时应该把<code>i = 1</code>处的字符拿过来继续比较，但是这两个位置的字符是一样的啊，都是<code>B</code>，既然一样，拿过来比较不就是无用功了么？其实不是我讲解的有问题，也不是这个算法有问题，而是这个算法还未优化，关于这个问题在下面会详细说明，不过建议读者不要在这里纠结，跳过这个，下面你自然会恍然大悟。</p><p>思路如此简单，接下来就是代码实现了，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* P 为模式串，下标从 0 开始 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNext</span><span class="params">(<span class="built_in">string</span> P, <span class="keyword">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> p_len = P.size();</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;   <span class="comment">// P 的下标</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">-1</span>;  </span><br><span class="line">next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; p_len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">-1</span> || P[i] == P[j])</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">next[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">j = next[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一脸懵逼，是不是。。。上述代码就是用来求解模式串中每个位置的<code>next[]</code>值。</p><p>下面具体分析，我把代码分为两部分来讲：</p><p><strong>（1）：i和j的作用是什么？</strong></p><p>i和j就像是两个”指针“，一前一后，通过移动它们来找到最长的相同真前后缀。</p><p><strong>（2）：if…else…语句里做了什么？</strong></p><p><img src="http://p86wg7kc2.bkt.clouddn.com/20180402_14.png" alt=""></p><p>假设i和j的位置如上图，由<code>next[i] = j</code>得，也就是对于位置i来说，<strong>区段[0, i - 1]的最长相同真前后缀分别是[0, j - 1]和[i - j, i - 1]，即这两区段内容相同</strong>。</p><p>按照算法流程，<code>if (P[i] == P[j])</code>，则<code>i++; j++; next[i] = j;</code>；若不等，则<code>j = next[j]</code>，见下图：</p><p><img src="http://p86wg7kc2.bkt.clouddn.com/20180402_15.png" alt=""></p><p><code>next[j]</code>代表[0, j - 1]区段中最长相同真前后缀的长度。如图，用左侧两个椭圆来表示这个最长相同真前后缀，即这两个椭圆代表的区段内容相同；同理，右侧也有相同的两个椭圆。所以else语句就是利用第一个椭圆和第四个椭圆内容相同来加快得到[0, i - 1]区段的相同真前后缀的长度。</p><p>细心的朋友会问if语句中<code>j == -1</code>存在的意义是何？第一，程序刚运行时，j是被初始为-1，直接进行<code>P[i] == P[j]</code>判断无疑会边界溢出；第二，else语句中<code>j = next[j]</code>，j是不断后退的，若j在后退中被赋值为-1（也就是<code>j = next[0]</code>），在<code>P[i] == P[j]</code>判断也会边界溢出。综上两点，其意义就是为了特殊边界判断。</p><h2 id="四：完整代码"><a href="#四：完整代码" class="headerlink" title="四：完整代码"></a>四：完整代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* P 为模式串，下标从 0 开始 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNext</span><span class="params">(<span class="built_in">string</span> P, <span class="keyword">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> p_len = P.size();</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;   <span class="comment">// P 的下标</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">-1</span>;  </span><br><span class="line">next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; p_len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">-1</span> || P[i] == P[j])</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">next[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">j = next[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在 S 中找到 P 第一次出现的位置 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> P, <span class="keyword">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">GetNext(P, next);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;  <span class="comment">// S 的下标</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;  <span class="comment">// P 的下标</span></span><br><span class="line"><span class="keyword">int</span> s_len = S.size();</span><br><span class="line"><span class="keyword">int</span> p_len = P.size();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; s_len &amp;&amp; j &lt; p_len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">-1</span> || S[i] == P[j])  <span class="comment">// P 的第一个字符不匹配或 S[i] == P[j]</span></span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">j = next[j];  <span class="comment">// 当前字符匹配失败，进行跳转</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (j == p_len)  <span class="comment">// 匹配成功</span></span><br><span class="line"><span class="keyword">return</span> i - j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> next[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; KMP(<span class="string">"bbc abcdab abcdabcdabde"</span>, <span class="string">"abcdabd"</span>, next) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 15</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五：算法复杂度分析"><a href="#五：算法复杂度分析" class="headerlink" title="五：算法复杂度分析"></a>五：算法复杂度分析</h2><p>在<code>GetNext()</code>和<code>KMP()</code>中，我们观察<code>i</code> 的移动，一直往前不回溯，所以它们所耗的时间都是线性的，两者相加为$Θ(m+n)$。</p><p>KMP算法的时间复杂度还是很稳定的。</p><ul><li>平均时间复杂度为$Θ(m+n)$。</li><li>最好时间复杂度为$O(m+(n-m))=O(n)$。它发生在主串和模式串字符都不相同的情况下，例如，主串为<code>abcdefghijk</code>，模式串为<code>+-*/</code>。</li><li>最差时间复杂度为$O(m+n)$。它发生在主串和模式串都为相同的字符的情况下，例如，主串为<code>aaaaaaaaaaaaaaaaaaaaa</code>，模式串为<code>aaaa</code>。</li></ul><h2 id="六：KMP优化"><a href="#六：KMP优化" class="headerlink" title="六：KMP优化"></a>六：KMP优化</h2><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th></tr></thead><tbody><tr><td style="text-align:center">模式串</td><td style="text-align:center">A</td><td style="text-align:center">B</td><td style="text-align:center">C</td><td style="text-align:center">D</td><td style="text-align:center">A</td><td style="text-align:center">B</td><td style="text-align:center">D</td><td style="text-align:center">‘\\0’</td></tr><tr><td style="text-align:center">next[ i ]</td><td style="text-align:center">-1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">0</td></tr></tbody></table></div><p>以3.2的表格为例（已复制在上方），若在<code>i = 5</code>时匹配失败，按照3.2的代码，此时应该把<code>i = 1</code>处的字符拿过来继续比较，但是这两个位置的字符是一样的，都是<code>B</code>，既然一样，拿过来比较不就是无用功了么？这我在3.2已经解释过，之所以会这样是因为KMP不够完美。那怎么改写代码就可以解决这个问题呢？很简单。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* P 为模式串，下标从 0 开始 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNextval</span><span class="params">(<span class="built_in">string</span> P, <span class="keyword">int</span> nextval[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> p_len = P.size();</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;   <span class="comment">// P 的下标</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">-1</span>;  </span><br><span class="line">nextval[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; p_len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">-1</span> || P[i] == P[j])</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">          </span><br><span class="line"><span class="keyword">if</span> (P[i] != P[j])</span><br><span class="line">    nextval[i] = j;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    nextval[i] = nextval[j];  <span class="comment">// 既然相同就继续往前找真前缀</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">j = nextval[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在此也给各位读者提个醒，KMP算法严格来说分为KMP算法（未优化版）和KMP算法（优化版），所以建议读者在表述KMP算法时，最好告知你的版本，因为两者在某些情况下区别很大，这里简单说下。</p><p><strong>KMP算法（未优化版）：</strong> next数组表示最长的相同真前后缀的长度，我们不仅可以利用next来解决模式串的匹配问题，也可以用来解决类似字符串重复问题等等，这类问题大家可以在各大OJ找到，这里不作过多表述。</p><p><strong>KMP算法（优化版）：</strong> 根据代码很容易知道（名称也改为了nextval），优化后的next仅仅表示相同真前后缀的长度，但<strong>不一定是最长</strong>（我个人称之为“最优相同真前后缀”）。此时我们利用优化后的next可以在模式串匹配问题中以更快的速度得到我们的答案（相较于未优化版），但是上述所说的字符串重复问题，优化版本则束手无策。</p><p>所以，该采用哪个版本，取决于你在现实中遇到的实际问题。</p><h2 id="七：参考文献"><a href="#七：参考文献" class="headerlink" title="七：参考文献"></a>七：参考文献</h2><ul><li>严蔚敏. 数据结构（C语言版）</li><li>阮一峰. <a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">字符串匹配的KMP算法</a></li></ul><blockquote><p>本文转载自：<a href="https://subetter.com/articles/2018/04/how-to-understand-kmp.html" target="_blank" rel="noopener">https://subetter.com/articles/2018/04/how-to-understand-kmp.html</a></p><p>作者：刘毅</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一：背景&quot;&gt;&lt;a href=&quot;#一：背景&quot; class=&quot;headerlink&quot; title=&quot;一：背景&quot;&gt;&lt;/a&gt;一：背景&lt;/h2&gt;&lt;p&gt;给定一个主串（以 S 代替）和模式串（以 P 代替），要求找出 P 在 S 中出现的位置，此即串的模式匹配问题。&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="学习" scheme="https://hushhw.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法笔记" scheme="https://hushhw.cn/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
      <category term="匈牙利算法" scheme="https://hushhw.cn/tags/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>匈牙利算法（二分图）</title>
    <link href="https://hushhw.cn/2018/05/16/23Hungarian-method/"/>
    <id>https://hushhw.cn/2018/05/16/23Hungarian-method/</id>
    <published>2018-05-16T08:25:58.000Z</published>
    <updated>2018-05-23T12:54:37.597Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>匈牙利算法是由匈牙利数学家Edmonds于1965年提出，因而得名。匈牙利算法是基于Hall定理中充分性证明的思想，它是部图匹配最常见的算法，该算法的核心就是寻找增广路径，它是一种用增广路径求二分图最大匹配的算法。（来自百度百科）</p></blockquote><p><strong>二分图</strong> ：是图论中的一种特殊模型。若能将无向图G=(V,E)的顶点V划分为两个交集为空的顶点集，并且任意边的两个端点都分别属于两个集合，则称图G为一个二分图。</p><p><img src="http://p86wg7kc2.bkt.clouddn.com/892758-20160610155729418-59307900.png" alt="img"></p><p><strong>匹配</strong>：在图论中，一个「匹配」（matching）是一个边的集合，其中任意两条边都没有公共顶点。例如，图 3、图 4 中红色的边就是图 2 的匹配。</p><p><img src="http://ww2.sinaimg.cn/large/7cc829d3gw1f89lnvfc6pj20g8057wfd.jpg" alt="img"></p><p>我们定义<strong>匹配点</strong>、<strong>匹配边</strong>、<strong>未匹配点</strong>、<strong>非匹配边</strong>，它们的含义非常显然。例如图 3 中 1、4、5、7 为匹配点，其他顶点为未匹配点；1-5、4-7为匹配边，其他边为非匹配边。</p><p><strong>最大匹配</strong>：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。图 4 是一个最大匹配，它包含 4 条匹配边。</p><p><strong>完美匹配</strong>：如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。图 4 是一个完美匹配。显然，完美匹配一定是最大匹配（完美匹配的任何一个点都已经匹配，添加一条新的匹配边一定会与已有的匹配边冲突）。但并非每个图都存在完美匹配。</p><p>基本概念讲完了。求解最大匹配问题的一个算法是<strong>匈牙利算法</strong>，下面讲的概念都为这个算法服务。</p><p><img src="http://ww2.sinaimg.cn/large/7cc829d3gw1f89lnzbetkj204j04u74f.jpg" alt="img"></p><p><strong>交替路</strong>：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边…形成的路径叫交替路。</p><p><strong>增广路</strong>：从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替路称为增广路（agumenting path）。例如，图 5 中的一条增广路如图 6 所示（图中的匹配点均用红色标出）：</p><p><img src="http://ww2.sinaimg.cn/mw690/7cc829d3gw1f89lo04o2wj207y01y3yi.jpg" alt="img"></p><p>增广路有一个重要特点：非匹配边比匹配边多一条。因此，研究增广路的意义是<strong>改进匹配</strong>。只要把增广路中的匹配边和非匹配边的身份交换即可。由于中间的匹配节点不存在其他相连的匹配边，所以这样做不会破坏匹配的性质。交换后，图中的匹配边数目比原来多了 1 条。</p><p>我们可以通过不停地找增广路来增加匹配中的匹配边和匹配点。找不到增广路时，达到最大匹配（这是增广路定理）。匈牙利算法正是这么做的。</p><p>一个比较有趣且易懂的过程可以参考这篇博文：<a href="https://blog.csdn.net/dark_scope/article/details/8880547" target="_blank" rel="noopener">https://blog.csdn.net/dark_scope/article/details/8880547</a></p><blockquote><p>过山车</p><p>Time Limit: 1000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)</p><p>Total Submission(s): 27673    Accepted Submission(s): 11954</p><p>Problem Description</p><p>RPG girls今天和大家一起去游乐场玩，终于可以坐上梦寐以求的过山车了。</p><p>可是，过山车的每一排只有两个座位，而且还有条不成文的规矩，就是每个女生必须找个个男生做partner和她同坐。</p><p>但是，每个女孩都有各自的想法，举个例子把，Rabbit只愿意和XHD或PQK做partner，Grass只愿意和linle或LL做partner，</p><p>PrincessSnow愿意和水域浪子或伪酷儿做partner。</p><p>考虑到经费问题，boss刘决定只让找到partner的人去坐过山车，其他的人，嘿嘿，就站在下面看着吧。</p><p>聪明的Acmer，你可以帮忙算算最多有多少对组合可以坐上过山车吗？</p><p>Input</p><p>输入数据的第一行是三个整数K , M , N，分别表示可能的组合数目，女生的人数，男生的人数。0&lt;K&lt;=1000</p><p>1&lt;=N 和M&lt;=500.接下来的K行，每行有两个数，分别表示女生Ai愿意和男生Bj做partner。最后一个0结束输入。</p><p>Output</p><p>对于每组数据，输出一个整数，表示可以坐上过山车的最多组合数。</p><p>Sample Input</p><p>6 3 3</p><p>1 1</p><p>1 2</p><p>1 3</p><p>2 1</p><p>2 3</p><p>3 1</p><p>0</p><p>Sample Output</p><p>3</p><p>Author</p><p>PrincessSnow</p><p>Source</p><p>RPG专场练习赛</p><p>Recommend</p><p>lcy   |   We have carefully selected several similar problems for you:  1068 1083 2444 1281 1150 </p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> line[<span class="number">510</span>][<span class="number">510</span>]; <span class="comment">//记录i和j有关系</span></span><br><span class="line"><span class="keyword">int</span> boy[<span class="number">510</span>];</span><br><span class="line"><span class="keyword">int</span> used[<span class="number">510</span>];  <span class="comment">//用于记录是否已经被匹配</span></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++)&#123;   <span class="comment">//遍历所有被选者</span></span><br><span class="line">        <span class="keyword">if</span>(line[x][i]==<span class="number">1</span> &amp;&amp; used[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//如果x对i有好感且在一个递归选取阶段没有被选取</span></span><br><span class="line">            used[i] = <span class="number">1</span>; <span class="comment">//标记已被选取</span></span><br><span class="line">            <span class="keyword">if</span>(boy[i]==<span class="number">0</span> || Find(boy[i]))&#123;</span><br><span class="line">                <span class="comment">//如果被选者没有归属或他的归属可以调换</span></span><br><span class="line">                boy[i] = x; <span class="comment">//将归属定为x</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, k, x, y, sum;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k)!=EOF &amp;&amp; k)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="built_in">memset</span>(line, <span class="number">0</span>, <span class="keyword">sizeof</span>(line));</span><br><span class="line">        <span class="built_in">memset</span>(boy, <span class="number">0</span>, <span class="keyword">sizeof</span>(boy));</span><br><span class="line">        <span class="built_in">memset</span>(used, <span class="number">0</span>, <span class="keyword">sizeof</span>(used));</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;x, &amp;y);</span><br><span class="line">            line[x][y] = <span class="number">1</span>; <span class="comment">//表示x希望与y有关系</span></span><br><span class="line">        &#125;</span><br><span class="line">        sum = <span class="number">0</span>; <span class="comment">//记录能组合的对数</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="built_in">memset</span>(used, <span class="number">0</span>, <span class="keyword">sizeof</span>(used)); <span class="comment">//每次都要清0</span></span><br><span class="line">            <span class="keyword">if</span>(Find(i))</span><br><span class="line">                sum++; <span class="comment">//找到一对就记录</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;匈牙利算法是由匈牙利数学家Edmonds于1965年提出，因而得名。匈牙利算法是基于Hall定理中充分性证明的思想，它是部图匹配最常见的算法，该算法的核心就是寻找增广路径，它是一种用增广路径求二分图最大匹配的算法。（来自百度百科）&lt;/p&gt;
&lt;/bl
      
    
    </summary>
    
      <category term="学习" scheme="https://hushhw.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法笔记" scheme="https://hushhw.cn/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
      <category term="匈牙利算法" scheme="https://hushhw.cn/tags/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>欧拉函数（Euler&#39;s totient function）</title>
    <link href="https://hushhw.cn/2018/05/05/22oulahanshu/"/>
    <id>https://hushhw.cn/2018/05/05/22oulahanshu/</id>
    <published>2018-05-05T12:12:35.000Z</published>
    <updated>2018-05-05T13:01:00.093Z</updated>
    
    <content type="html"><![CDATA[<p><strong>欧拉函数的定义：</strong></p><p>​    在数论中，对于正整数N,少于或等于N ([1,N]),且与N互质的正整数(包括1)的个数，记作φ(n)。</p><p>​     φ函数的值：</p><p>​    φ(x)=x(1-1/p(1))(1-1/p(2))(1-1/p(3))(1-1/p(4))…..(1-1/p(n)) 其中p(1),p(2)…p(n)为x</p><p>的所有质因数;x是正整数; φ(1)=1(唯一和1互质的数，且小于等于1)。注意：每种质因数只有一个。</p><p>​     例如:</p><p>​         φ(10)=10×(1-1/2)×(1-1/5)=4;</p><p>​         1 3 7 9</p><p>​         φ(30)=30×(1-1/2)×(1-1/3)×(1-1/5)=8;</p><p>​         φ(49)=49×(1-1/7)=42;</p><p><strong>欧拉函数的性质：</strong></p><p>(1)   p^k型欧拉函数:</p><p>若N是质数p(即N=p), φ(n)= φ(p)=p-p^(k-1)=p-1。</p><p>若N是质数p的k次幂(即N=p^k)，φ(n)=p^k-p^(k-1)=(p-1)p^(k-1)。</p><p>(2)mn型欧拉函数</p><p>设n为正整数，以φ(n)表示不超过n且与n互素的正整数的个数，称为n的欧拉函数值。若m,n互质，φ(mn)=(m-1)(n-1)=φ(m)φ(n)。</p><p>(3)特殊性质:</p><p>若n为奇数时，φ(2n)=φ(n)。</p><p>对于任何两个互质 的正整数a,n(n&gt;2)有:a^φ(n)=1 mod n (恒等于)此公式即 <strong>欧拉定理</strong></p><p>当n=p 且 a与素数p互质(即:gcd(a,p)=1)则上式有: a^(p-1)=1 mod n (恒等于)此公式即 <strong>费马小定理</strong></p><p>欧拉函数模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//直接求小于或等于n,且与n互质的个数:</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">Euler</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(n);i++)</span><br><span class="line">     <span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">        ret=ret/i*(i<span class="number">-1</span>);<span class="comment">//先进行除法防止溢出(ret=ret*(1-1/p(i)))</span></span><br><span class="line">        <span class="keyword">while</span>(n%i==<span class="number">0</span>)</span><br><span class="line">          n/=i;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1</span>)</span><br><span class="line">          ret=ret/n*(n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">//筛选模板:求[1,n]之间每个数的质因数的个数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> size 1000001</span></span><br><span class="line"><span class="keyword">int</span> euler[size];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="built_in">memset</span>(euler,<span class="number">0</span>,<span class="keyword">sizeof</span>(euler));</span><br><span class="line">     euler[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;size;i++)</span><br><span class="line">       <span class="keyword">if</span>(!euler[i])</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;size;j+=i)&#123;</span><br><span class="line">              <span class="keyword">if</span>(!euler[j])</span><br><span class="line">               euler[j]=j;</span><br><span class="line">               euler[j]=euler[j]/i*(i<span class="number">-1</span>);<span class="comment">//先进行除法是为了防止中间数据的溢出</span></span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>找新朋友</p><p>Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)</p><p>Total Submission(s): 4409 Accepted Submission(s): 1999</p><p>Problem Description</p><p>新年快到了，“猪头帮协会”准备搞一个聚会，已经知道现有会员N人，把会员从1到N编号，</p><p>其中会长的号码是N号，凡是和会长是老朋友的，那么该会员的号码肯定和N有大于1的公约数，否则都是新朋友，</p><p>现在会长想知道究竟有几个新朋友？请你编程序帮会长计算出来。</p><p>Input</p><p>第一行是测试数据的组数CN（Case number，1&lt;CN&lt;10000），接着有CN行正整数N（1&lt;n&lt;32768），表示会员人数。</p><p>Output</p><p>对于每一个N，输出一行新朋友的人数，这样共有CN行输出。</p><p>Sample Input</p><p>2</p><p>25608</p><p>24027</p><p>Sample Output</p><p>7680</p><p>16016</p><p>Author</p><p>SmallBeer(CML)</p><p>Source</p><p>杭电ACM集训队训练赛（VII）</p><p>Recommend</p><p>lcy</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">euler</span><span class="params">( <span class="keyword">int</span> x )</span>  </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> res = x;  </span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">2</span>; i*i &lt;= x; i ++ )  </span><br><span class="line">        <span class="keyword">if</span>( x%i == <span class="number">0</span> )  &#123;  </span><br><span class="line">            res =res/i*(i<span class="number">-1</span>);  </span><br><span class="line">            <span class="keyword">while</span>(x%i==<span class="number">0</span>) x/=i;  </span><br><span class="line">        &#125;  </span><br><span class="line">    <span class="keyword">if</span>( x &gt; <span class="number">1</span> ) res = res/x*(x<span class="number">-1</span>);  </span><br><span class="line">    <span class="keyword">return</span> res;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> T;  </span><br><span class="line">    <span class="built_in">scanf</span> ( <span class="string">"%d"</span>, &amp;T );  </span><br><span class="line">    <span class="keyword">while</span>( T-- )  &#123;  </span><br><span class="line">        <span class="keyword">int</span> n;  </span><br><span class="line">        <span class="built_in">scanf</span> ( <span class="string">"%d"</span>, &amp;n );  </span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">"%d\n"</span>, euler(n) );  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;欧拉函数的定义：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​    在数论中，对于正整数N,少于或等于N ([1,N]),且与N互质的正整数(包括1)的个数，记作φ(n)。&lt;/p&gt;
&lt;p&gt;​     φ函数的值：&lt;/p&gt;
&lt;p&gt;​    φ(x)=x(1-1/p(1
      
    
    </summary>
    
      <category term="学习" scheme="https://hushhw.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法笔记" scheme="https://hushhw.cn/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
      <category term="图论" scheme="https://hushhw.cn/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>数学错题汇总目录</title>
    <link href="https://hushhw.cn/2018/04/27/21math/"/>
    <id>https://hushhw.cn/2018/04/27/21math/</id>
    <published>2018-04-27T06:48:04.000Z</published>
    <updated>2018-05-10T07:46:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数学错题汇总目录"><a href="#数学错题汇总目录" class="headerlink" title="数学错题汇总目录"></a>数学错题汇总目录</h1><h3 id="函数、极限、连续"><a href="#函数、极限、连续" class="headerlink" title="函数、极限、连续"></a>函数、极限、连续</h3><ul><li>概念题 <code>21 660NO.11</code></li><li>数列收敛的性质  <code>1 1000P3A1.1</code>  <code>660NO.9 概念题</code></li><li>极限(不)存在及推广 <code>2 1000P3A1.2</code> <code>3 1000P4A1.11</code></li><li>无界与无穷大 <code>4 1000P4A1.8</code> <code>5 1000P4A1.10</code> <code>660NO.8 概念题</code></li><li>函数有界性的判别 <code>6 18P33例2.7</code> </li><li>夹逼准则 <code>7 18P36例2.10</code> <code>7.1 1000P4A1.18</code> </li><li>求极限 <code>10 18P51习题2.7</code> <code>11 18P51习题2.8</code> <code>14 1000P5A1.19(16)有积分</code> <code>19 660NO.4</code></li><li>已知函数极限求参数 <code>12 1000P5A1.30</code></li><li>间断点 <code>13</code>  <code>22 660NO.18</code> </li><li>洛必达法则概念 <code>20 660NO.7</code></li><li>定积分的精确定义</li></ul><h3 id="一元函数微分学"><a href="#一元函数微分学" class="headerlink" title="一元函数微分学"></a>一元函数微分学</h3><ul><li>导数定义求导数 <code>8 1000P9A2.1</code> <code>15 1000P11A2.21</code></li><li>导数定义判定可导性 <code>9 18P64例3.4(笔记本1有详解)</code> </li><li>反函数求导 <code>16 1000P12A2.33</code> </li><li>常数不等式证明 <code>17 1000P12A2.41</code></li><li>不等式证明 <code>18 1000P12A2.39</code></li><li>f(x)和|f(x)|可导性 <code>24 660NO.36</code></li></ul><h3 id="一元函数积分学"><a href="#一元函数积分学" class="headerlink" title="一元函数积分学"></a>一元函数积分学</h3><ul><li>求不定积分 <code>25 1000P20A3.2</code> <code>1000P20A3.3</code>  <code>教材P217例7</code><ul><li>抽象或半抽象函数的不定积分计算 <code>18P131例7.10</code> <code>18P131例7.9</code></li><li>三角函数恒等变形 <code>18P132例7.14</code> <code>18P133例7.18</code> <code>教材P215例4</code></li></ul></li><li>被积函数有导数、变限积分 <code>26 1000P21A3.20</code></li><li>变限积分判断奇偶性 <code>27 1000P20A3.5</code> <code>证明见 18P129例7.6</code></li><li>原函数存在定理 <code>18P128例7.5</code></li><li>平均值应用 <code>1000P21A3.25</code></li></ul><h3 id="多元函数微分学"><a href="#多元函数微分学" class="headerlink" title="多元函数微分学"></a>多元函数微分学</h3><ul><li>连续、偏导数连续、可微、偏导数存在的关系 <code>1000P35A5.3</code></li><li>取极值的条件 <code>1000P35A5.4</code></li><li>多元函数极限值 <code>30 1000P35A5.5</code></li><li>定义求偏导数 <code>1000P36PA5.9</code></li><li>二元函数无条件极值 </li></ul><h3 id="易错题"><a href="#易错题" class="headerlink" title="易错题"></a>易错题</h3><p><code>23 660NO.23</code></p><h3 id="常识题"><a href="#常识题" class="headerlink" title="常识题"></a>常识题</h3><ul><li>常见求导 <code>1000P21A3.13</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数学错题汇总目录&quot;&gt;&lt;a href=&quot;#数学错题汇总目录&quot; class=&quot;headerlink&quot; title=&quot;数学错题汇总目录&quot;&gt;&lt;/a&gt;数学错题汇总目录&lt;/h1&gt;&lt;h3 id=&quot;函数、极限、连续&quot;&gt;&lt;a href=&quot;#函数、极限、连续&quot; class=&quot;head
      
    
    </summary>
    
      <category term="学习" scheme="https://hushhw.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="考研数学" scheme="https://hushhw.cn/tags/%E8%80%83%E7%A0%94%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>优先队列 priority_queue</title>
    <link href="https://hushhw.cn/2018/04/15/20priority-queue/"/>
    <id>https://hushhw.cn/2018/04/15/20priority-queue/</id>
    <published>2018-04-15T02:31:54.000Z</published>
    <updated>2018-04-15T02:33:21.350Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://blog.csdn.net/c20182030/article/details/70757660" target="_blank" rel="noopener">https://blog.csdn.net/c20182030/article/details/70757660</a></p></blockquote><h2 id="优先队列的头文件-amp-amp-声明"><a href="#优先队列的头文件-amp-amp-声明" class="headerlink" title="优先队列的头文件&amp;&amp;声明"></a>优先队列的头文件&amp;&amp;声明</h2><p>首先，你需要</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt; //如果要用到后面的greater&lt;int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure><p>这两个头文件。</p><p>其次，一个优先队列声明的基本格式是：<br><strong>priority_queue&lt;结构类型&gt; 队列名;</strong><br>比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">priority_queue &lt;<span class="keyword">int</span>&gt; i;</span><br><span class="line">priority_queue &lt;<span class="keyword">double</span>&gt; d;</span><br></pre></td></tr></table></figure><p>不过，我们最为常用的是这几种：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">priority_queue &lt;node&gt; q;</span><br><span class="line"><span class="comment">//node是一个结构体</span></span><br><span class="line"><span class="comment">//结构体里重载了‘&lt;’小于符号</span></span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"><span class="comment">//不需要#include&lt;vector&gt;头文件</span></span><br><span class="line"><span class="comment">//注意后面两个“&gt;”不要写在一起，“&gt;&gt;”是右移运算符</span></span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt; &gt;q;</span><br></pre></td></tr></table></figure><p>我们将在下文来讲讲这几种声明方式的不同。</p><h2 id="优先队列的基本操作"><a href="#优先队列的基本操作" class="headerlink" title="优先队列的基本操作"></a>优先队列的基本操作</h2><p>与队列的基本操作如出一辙。 </p><p>以一个名为q的优先队列为例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">q.size();//返回q里元素个数</span><br><span class="line">q.empty();//返回q是否为空，空则返回1，否则返回0</span><br><span class="line">q.push(k);//在q的末尾插入k</span><br><span class="line">q.pop();//删掉q的第一个元素</span><br><span class="line">q.top();//返回q的第一个元素</span><br><span class="line">q.back();//返回q的末尾元素</span><br></pre></td></tr></table></figure><h2 id="优先队列的特性"><a href="#优先队列的特性" class="headerlink" title="优先队列的特性"></a>优先队列的特性</h2><p><strong>自动排序</strong><br>怎么个排法呢？<br>在这里介绍一下：</p><h3 id="默认的优先队列（非结构体结构）"><a href="#默认的优先队列（非结构体结构）" class="headerlink" title="默认的优先队列（非结构体结构）"></a>默认的优先队列（非结构体结构）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue &lt;int&gt; q;</span><br></pre></td></tr></table></figure><p>这样的优先队列是怎样的？让我们写程序验证一下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[]=&#123;<span class="number">10</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) q.push(a[i]);</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,q.top()); <span class="comment">//14 12 10 8 6</span></span><br><span class="line">q.pop();</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序大意就是在这个优先队列里依次插入10、8、12、14、6，再输出。<br>结果是什么呢？<br><code>14 12 10 8 6</code><br>也就是说，它是按从大到小排序的！</p><h3 id="默认的优先队列（结构体，重载小于）"><a href="#默认的优先队列（结构体，重载小于）" class="headerlink" title="默认的优先队列（结构体，重载小于）"></a>默认的优先队列（结构体，重载小于）</h3><p>先看看这个结构体是什么。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line">node(<span class="keyword">int</span> xx, <span class="keyword">int</span> yy)&#123;</span><br><span class="line">x=xx;</span><br><span class="line">y=yy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp; a) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &lt; a.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个node结构体有两个成员，x和y，它的小于规则是x小者小。<br>再来看看验证程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line">node(<span class="keyword">int</span> xx, <span class="keyword">int</span> yy)&#123;</span><br><span class="line">x=xx;</span><br><span class="line">y=yy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp; a) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &lt; a.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">priority_queue &lt;node&gt; q;</span><br><span class="line">q.push(node(<span class="number">10</span>, <span class="number">100</span>));</span><br><span class="line">q.push(node(<span class="number">12</span>,<span class="number">60</span>));</span><br><span class="line">q.push(node(<span class="number">14</span>,<span class="number">40</span>));</span><br><span class="line">q.push(node(<span class="number">6</span>,<span class="number">80</span>));</span><br><span class="line">q.push(node(<span class="number">8</span>,<span class="number">20</span>));</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"(%d,%d) "</span>,q.top().x,q.top().y); <span class="comment">//(14,40) (12,60) (10,100) (8,20) (6,80)</span></span><br><span class="line">q.pop();</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序大意就是插入(10,100),(12,60),(14,40),(6,20),(8,20)这五个node。<br>再来看看它的输出：<br><code>(14,40) (12,60) (10,100) (8,20) (6,80)</code></p><p>它也是按照<strong>重载后的小于规则</strong>，从大到小排序的。</p><h3 id="less和greater优先队列"><a href="#less和greater优先队列" class="headerlink" title="less和greater优先队列"></a>less和greater优先队列</h3><p>还是以int为例，先来声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">priority_queue &lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt; &gt; p;</span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt; q;</span><br></pre></td></tr></table></figure><p>话不多说，上程序和结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt; //因为用了greater&lt;int&gt;() </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt; &gt; p;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>]=&#123;<span class="number">10</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">p.push(a[i]),q.push(a[i]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"less&lt;int&gt;:"</span>);</span><br><span class="line"><span class="keyword">while</span>(!p.empty())</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,p.top()),p.pop();  </span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\ngreater&lt;int&gt;:"</span>);</span><br><span class="line"><span class="keyword">while</span>(!q.empty())</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,q.top()),q.pop();</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br><code>less&lt;int&gt;:14 12 10 8 6 greater&lt;int&gt;:6 8 10 12 14</code></p><p>所以，我们可以知道，<strong>less是从大到小，greater是从小到大</strong>。</p><h3 id="作个总结"><a href="#作个总结" class="headerlink" title="作个总结"></a>作个总结</h3><p>为了<del>装13</del>方便，在平时，建议大家写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt;q;</span><br><span class="line">priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q;12</span><br></pre></td></tr></table></figure><p>平时如果用从大到小不用后面的<code>vector&lt;int&gt;,less&lt;int&gt;</code>，可能到时候要改成从小到大，你反而会搞忘怎么写<code>greater&lt;int&gt;</code>，反而得不偿失。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://blog.csdn.net/c20182030/article/details/70757660&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.ne
      
    
    </summary>
    
      <category term="学习" scheme="https://hushhw.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法笔记" scheme="https://hushhw.cn/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
      <category term="STL" scheme="https://hushhw.cn/tags/STL/"/>
    
      <category term="优先队列" scheme="https://hushhw.cn/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>写在蓝桥杯省赛后</title>
    <link href="https://hushhw.cn/2018/04/09/19lanqiaobei/"/>
    <id>https://hushhw.cn/2018/04/09/19lanqiaobei/</id>
    <published>2018-04-09T13:19:53.000Z</published>
    <updated>2018-05-04T06:00:13.126Z</updated>
    
    <content type="html"><![CDATA[<p>前天是我开通GitHub一周年，一年里从开始不会使用到后来用来存我的编程代码，到后来学习git把本地的Cocos、Qt工程传上去，之后利用hexo框架搭了这个博客。一年过得很快，我也在这个社区学到了很多，见识到了更大的世界。 </p><p><img src="http://p86wg7kc2.bkt.clouddn.com/hushhwblog01" alt="github"></p><p>上图是昨天截下来的一年的贡献图，最密集的那一段是刚刚过去的寒假，几乎每一天都有很认真的把自己当天做的算法题传到GitHub，靠这个图来鼓励自己加油下去，至少可以感动自己吧。</p><p>上了大学之后，爸爸就开始跟不上我了，他不知道我在学些什么，他不知道我可能和他一样迷茫以后要做什么，但是他总会跟我说一定要把路走对，多问问别人总不会错的。对于他的教育，我总是用敷衍回应，因为我非常自信自己走的路是对的，我走的是我喜欢的路，怎么会不对呢？大学不就是做自己喜欢做的事吗？</p><p>现在是大三下，我大概在大二结束的暑假才想清楚我应该走的路。</p><p>那个暑假应班主任的邀请，给大一的学弟学妹做Cocos引擎培训，用两个星期的时间教他们引擎的基本使用和做出一个小游戏来，我们专业这个暑假培训是个传统，一代传一代，所以到我教他们的时候已经过去一年了，C++和Cocos2d-x该忘的都忘得差不多了，所以那两个星期基本上都是白天教晚上学习，整理好明天要讲的内容和笔记代码，大学我应该从来都没有这样逼过自己，也没有这样感受编程给我带来的快乐。</p><p>从那个暑假开始，我才算真正的是个计算机专业的学生吧，开始认真的刷OJ的题，看算法书，别人大一就开始做的事情，我大三才开始做，毫无意外的大三上的校赛落榜，没办法证明自己真的是一件很难受的事情，之后每周都会参与学校的刷题比赛，默默地对比自己和别人的差距，别人开始准备考研的寒假，我花了所有时间去做算法，这个学期一边准备考研，每天还会留晚上的时间来刷题。</p><p>蓝桥杯如期而至，第一次参加这个别人眼里很水的比赛，对我而言这是一次证明自己的机会吧，只是是给自己看的，可是当天又给我开了个玩笑，我用的机器和系统时间相差五分钟，我以为还有五分钟的时候实际上已经结束了，所以我戏剧性的最后一题没有交上去，考完出来就跟班主任诉苦，感觉自己应该是没希望了。</p><p>之间这段时间的学习状态不太好，但是我不会放下算法的学习，慢慢地调整，每周还是会去牛客网看看有没有可以打的比赛，还是会多整理笔记，我喜欢这种有目标的感觉。</p><p>今天中午趴在自习室午休醒来，班主任的消息：上了，可以国赛。</p><p>北京见。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前天是我开通GitHub一周年，一年里从开始不会使用到后来用来存我的编程代码，到后来学习git把本地的Cocos、Qt工程传上去，之后利用hexo框架搭了这个博客。一年过得很快，我也在这个社区学到了很多，见识到了更大的世界。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http:/
      
    
    </summary>
    
      <category term="随笔" scheme="https://hushhw.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://hushhw.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>01分数规划</title>
    <link href="https://hushhw.cn/2018/04/07/18fenshuguihua/"/>
    <id>https://hushhw.cn/2018/04/07/18fenshuguihua/</id>
    <published>2018-04-07T08:51:42.000Z</published>
    <updated>2018-04-09T12:42:30.425Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>链接：<a href="https://www.nowcoder.com/acm/contest/93/I" target="_blank" rel="noopener">https://www.nowcoder.com/acm/contest/93/I</a><br>来源：牛客网</p><p>时间限制：C/C++ 5秒，其他语言10秒<br>空间限制：C/C++ 262144K，其他语言524288K<br>64bit IO Format: %lld</p><p>题目描述<br>wyh学长现在手里有n个物品，这n个物品的重量和价值都告诉你，然后现在让你从中选取k个，问你在所有可能选取的方案中，最大的单位价值为多少（单位价值为选取的k个物品的总价值和总重量的比值）</p><p>输入描述:<br>输入第一行一个整数T(1&lt;=T&lt;=10)<br>接下来有T组测试数据，对于每组测试数据，第一行输入两个数n和k(1&lt;=k&lt;=n&lt;=100000)<br>接下来有n行，每行两个是a和b，代表这个物品的重量和价值</p><p>输出描述:<br>对于每组测试数据，输出对应答案，结果保留两位小数</p><p>示例1<br>输入<br>1<br>3 2<br>2 2<br>5 3<br>2 1</p><p>输出<br>0.75</p><p>说明<br>对于样例来说，我们选择第一个物品和第三个物品，达到最优目的</p></blockquote><p>做法:<br>二分，对于每一个答案C，有 s[i] = w[i]-c*v[i]<br>排序，取最大前k个，如果大于等于0则可行，否则不可行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> n,k; <span class="comment">//n件物品取k件</span></span><br><span class="line"><span class="keyword">int</span> wi[maxn],vi[maxn];<span class="comment">//物品的重量和价值</span></span><br><span class="line"><span class="keyword">double</span> y[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">y[i]=vi[i]-x*wi[i];</span><br><span class="line">sort(y,y+n);</span><br><span class="line"><span class="keyword">double</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++)&#123;</span><br><span class="line">sum += y[n-i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum&gt;=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;wi[i],&amp;vi[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> left=<span class="number">0</span>, right=maxn;</span><br><span class="line"><span class="keyword">while</span>(right-left&gt;<span class="number">1e-6</span>)&#123;</span><br><span class="line"><span class="keyword">double</span> mid = (right+left)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(cmp(mid)) left=mid;</span><br><span class="line"><span class="keyword">else</span> right = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.nowcoder.com/acm/contest/93/I&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.nowcoder.com/acm/contest/9
      
    
    </summary>
    
      <category term="学习" scheme="https://hushhw.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法笔记" scheme="https://hushhw.cn/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
      <category term="01分数规划" scheme="https://hushhw.cn/tags/01%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>树状数组和归并排序求逆序数</title>
    <link href="https://hushhw.cn/2018/02/28/17%E9%80%86%E5%BA%8F%E6%95%B0/"/>
    <id>https://hushhw.cn/2018/02/28/17逆序数/</id>
    <published>2018-02-28T11:38:26.000Z</published>
    <updated>2018-02-28T11:40:02.273Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树状数组和归并排序求逆序数"><a href="#树状数组和归并排序求逆序数" class="headerlink" title="树状数组和归并排序求逆序数"></a>树状数组和归并排序求逆序数</h1><h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><p>树状数组，具体的说是 离散化+树状数组。</p><p>算法的大体流程就是：</p><ol><li>先对输入的数组离散化，使得各个元素比较接近，而不是离散的</li><li>接着，运用树状数组的标准操作来累计数组的逆序数。</li></ol><p>算法详细解释：</p><ol><li>解释为什么要有离散的这么一个过程？</li></ol><p>刚开始以为999.999.999这么一个数字，对于int存储类型来说是足够了。还有只有500000个数字，何必要离散化呢？刚开始一直想不通，后来明白了，后面在运用树状数组操作的时候，用到的树状数组C[i]是建立在一个有点像位存储的数组的基础之上的，不是单纯的建立在输入数组之上。</p><p>比如输入一个9 1 0 5 4，那么C[i]树状数组的建立是在，</p><p>​    下标 0 1 2 3 4 5 6 7 8 9</p><p>​    数组 1 1 0 0 1 1 0 0 0 1</p><p>现在由于999999999这个数字相对于500000这个数字来说是很大的，所以如果用数组位存储的话，那么需要999999999的空间来存储输入的数据。这样是很浪费空间的，题目也是不允许的，所以这里想通过离散化操作，使得离散化的结果可以更加的密集。</p><ol><li>怎么对这个输入的数组进行离散操作？</li></ol><p>离散化是一种常用的技巧，有时数据范围太大，可以用来放缩到我们能处理的范围；因为其中需排序的数的范围0—-999 999 999；显然数组不肯能这么大；而N的最大范围是500 000；故给出的数一定可以与1.。。。N建立一个一一映射；</p><p>   ①当然用map可以建立，效率可能低点；</p><p>   ②这里用一个结构体</p><p>   struct Node</p><p>   {</p><p>​      int v,ord;</p><p>   }p[510000];和一个数组a[510000];</p><p>   其中v就是原输入的值，ord是下标；然后对结构体按v从小到大排序；此时，v和结构体的下标就是一个一一对应关系，而且满足原来的大小关系；</p><p>   for(i=1;i&lt;=N;i++) a[p[i].ord]=i;</p><p>然后a数组就存储了原来所有的大小信息；比如 9 1 0 5 4 ———- 离散后aa数组就是 5 2 1 4 3；具体的过程可以自己用笔写写就好了。</p><ol><li>离散之后，怎么使用离散后的结果数组来进行树状数组操作，计算出逆序数？</li></ol><p>如果数据不是很大， 可以一个个插入到树状数组中，每插入一个数， 统计比他小的数的个数，对应的逆序为 i- getsum( aa[i] )，其中 i 为当前已经插入的数的个数，getsum( aa[i] ）为比 aa[i] 小的数的个数，i- sum( aa[i] ) 即比 aa[i] 大的个数， 即逆序的个数。</p><p>但如果数据比较大，就必须采用离散化方法。</p><p>假设输入的数组是9 1 0 5 4， 离散后的结果aa[] = {5,2,1,4,3};</p><p>在离散结果中间结果的基础上，那么其计算逆序数的过程是这么一个过程。</p><ol><li>输入5，   调用upDate(5, 1),把第5位设置为1</li></ol><p>1 2 3 4 5</p><p>0 0 0 0 1</p><p>计算1-5上比5小的数字存在么？ 这里用到了树状数组的getSum（5） = 1操作，现在用输入的下标1 - getSum(5) = 0 就可以得到对于5的逆序数为0。</p><ol><li>输入2， 调用upDate(2, 1),把第2位设置为1</li></ol><p>1 2 3 4 5</p><p>0 1 0 0 1</p><p>计算1-2上比2小的数字存在么？ 这里用到了树状数组的getSum（2） = 1操作，现在用输入的下标2 - getSum(2) = 1 就可以得到对于2的逆序数为1。</p><ol><li>输入1， 调用upDate(1, 1),把第1位设置为1</li></ol><p>1 2 3 4 5</p><p>1 1 0 0 1</p><p>计算1-1上比1小的数字存在么？ 这里用到了树状数组的getSum（1） = 1操作，现在用输入的下标 3 - getSum(1) = 2 就可以得到对于1的逆序数为2。</p><ol><li>输入4， 调用upDate(4, 1),把第5位设置为1</li></ol><p>1 2 3 4 5</p><p>1 1 0 1 1</p><p>计算1-4上比4小的数字存在么？ 这里用到了树状数组的getSum（4） = 3操作，现在用输入的下标4 - getSum(4) = 1 就可以得到对于4的逆序数为1。</p><ol><li>输入3， 调用upDate(3, 1),把第3位设置为1</li></ol><p>1 2 3 4 5</p><p>1 1 1 1 1</p><p>计算1-3上比3小的数字存在么？ 这里用到了树状数组的getSum（3） = 3操作，现在用输入的下标5 - getSum(3) = 2 就可以得到对于3的逆序数为2。</p><ol><li>0+1+2+1+2 = 6 这就是最后的逆序数</li></ol><p>分析一下时间复杂度，首先用到快速排序，时间复杂度为O(NlogN),</p><p>后面是循环插入每一个数字，每次插入一个数字，分别调用一次upData()和getSum()</p><p>外循环N, upData()和getSum()时间O(logN) =&gt; 时间复杂度还是O(NlogN).</p><p>最后总的还是O(NlogN).</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">500005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> aa[maxn];<span class="comment">//离散后的数组</span></span><br><span class="line"><span class="keyword">int</span> c[maxn];<span class="comment">//树状数组</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> v;</span><br><span class="line"><span class="keyword">int</span> order;</span><br><span class="line">&#125;in[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&amp;(-x);</span><br><span class="line"><span class="comment">//求出2^p(其中p: x 的二进制表示数中， 右向左数第一个1的位置)</span></span><br><span class="line"><span class="comment">//如6的二进制表示为110，向左数第零个为0，第一个为1，则p=1，故Lowbit(6) = 2^1 = 2。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node a, Node b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.v&lt;b.v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=t; i&lt;=n; i+=lowbit(i))</span><br><span class="line">c[i]+=value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=x; i&gt;=<span class="number">1</span>; i-=lowbit(i))</span><br><span class="line">temp+=c[i];</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)==<span class="number">1</span> &amp;&amp; n)&#123;</span><br><span class="line"><span class="comment">//离散化</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;in[i].v);</span><br><span class="line">in[i].order=i;</span><br><span class="line">&#125;</span><br><span class="line">sort(in+<span class="number">1</span>, in+n+<span class="number">1</span>, cmp);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">aa[in[i].order] = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树状数组求逆序</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span>(c));</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">update(aa[i],<span class="number">1</span>);</span><br><span class="line">ans += i-getsum(aa[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>对于一个数组{5，3，7，4，6，2，1，8}，如果我们以中间（或者左中）为界限将其分成两个数组，只要知道这两个数组中的逆序对数和两边的数所组成的逆序对数就是它所有的逆序对数了。而数组划分的递归结束点在两个数组都只有一个元素的时候，因此两数组中的逆序对数可以要去求分裂的两数组中的逆序对数可以这样去做：先将两数组按升序排序，若前一个数组的第一个元素比后一个的大，则说明前一组的后面所有都要比后一组的第一个元素大，这样将较小的第一个元素去掉后，继续比较两个数组的第一个元素可以把所有的逆序对找到。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right,<span class="keyword">int</span> temp[],<span class="keyword">long</span> <span class="keyword">long</span> *count)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>,i,j;</span><br><span class="line">i = left; j = mid+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>((i&lt;=mid) &amp;&amp; (j&lt;=right))&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i] &lt;= arr[j])&#123;</span><br><span class="line">temp[k++] = arr[i++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">temp[k++] = arr[j++];</span><br><span class="line"><span class="comment">//ans+=e1-p1+1;</span></span><br><span class="line">(*count) = (*count) + mid - i + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//在归并排序的过程中，可以一步步来计算逆序数的值，由于归并排序的过程一直都是升序在排序，所以如果a[i]&gt;a[j]的话，那么a[i]后面的数一定都大于a[j]，加上后面的数的个数；</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid)</span><br><span class="line">temp[k++] = arr[i++];</span><br><span class="line"><span class="keyword">while</span>(j&lt;=right)</span><br><span class="line">temp[k++] = arr[j++];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">arr[left+i] = temp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> temp[],<span class="keyword">long</span> <span class="keyword">long</span> *count)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(left&lt;right)&#123; <span class="comment">// 递归出口</span></span><br><span class="line"><span class="keyword">int</span> mid = (left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">mergeSort(arr,left,mid,temp,count);</span><br><span class="line">mergeSort(arr,mid+<span class="number">1</span>,right,temp,count);</span><br><span class="line">merge(arr,left,mid,right,temp,count);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line"><span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *temp = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">mergeSort(a,<span class="number">0</span>,m<span class="number">-1</span>,temp,&amp;count);</span><br><span class="line"><span class="keyword">delete</span> []a;</span><br><span class="line"><span class="keyword">delete</span> []temp;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;count;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>本文参考整理自：</p><p><a href="http://www.360doc.com/content/12/0925/21/9615799_238155264.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/12/0925/21/9615799_238155264.shtml</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;树状数组和归并排序求逆序数&quot;&gt;&lt;a href=&quot;#树状数组和归并排序求逆序数&quot; class=&quot;headerlink&quot; title=&quot;树状数组和归并排序求逆序数&quot;&gt;&lt;/a&gt;树状数组和归并排序求逆序数&lt;/h1&gt;&lt;h2 id=&quot;树状数组&quot;&gt;&lt;a href=&quot;#树状数组&quot;
      
    
    </summary>
    
      <category term="学习" scheme="https://hushhw.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法笔记" scheme="https://hushhw.cn/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
      <category term="树状数组" scheme="https://hushhw.cn/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="归并排序" scheme="https://hushhw.cn/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>线段树总结</title>
    <link href="https://hushhw.cn/2018/02/23/16%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>https://hushhw.cn/2018/02/23/16线段树/</id>
    <published>2018-02-22T17:21:28.000Z</published>
    <updated>2018-02-22T17:22:43.819Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线段树基本概念"><a href="#线段树基本概念" class="headerlink" title="线段树基本概念"></a>线段树基本概念</h3><p>线段树/区间树是一种非常常用的对区间数据进行操作的数据结构。 </p><p>线段树是一棵二叉树（但不一定是完全二叉树！），它的每个节点均代表一个区间，且父节点代表的区间为左右子节点代表的区间之和。特别的，根节点代表的区间为所有节点代表区间之和，各个叶节点代表区间为单个点（即长度为1的区间）。</p><h3 id="线段树结构"><a href="#线段树结构" class="headerlink" title="线段树结构"></a>线段树结构</h3><p>树中的每一个结点表示了一个区间[a,b]。 a,b通常是整数。每一个叶子节点表示了一个单位区间(长度为1)。对于每一个非叶结点所表示的结点[a,b]，其左儿子表示的区间为[a,(a+b)/2]，右儿子表示的区间为[(a+b)/2+1,b](除法去尾取整）。 </p><p>如下图为区间[1, 9]的线段树：<br><img src="http://7xkwr3.com1.z0.glb.clouddn.com/interval_tree1.PNG" alt="线段树"></p><h3 id="线段树性质"><a href="#线段树性质" class="headerlink" title="线段树性质"></a>线段树性质</h3><ol><li>线段树为二分构造，若根节点对应区间为[a,b]，则其深度为 log2(b−a+1)(向上取整）。这样在进行更新查询操作的时候，操作的复杂度就可以为log(n)量级</li><li>叶子节点的数目和根节点表示的区间长度相同</li><li>若叶子节点的数目为N，则线段树的总节点数目为2*N-1。因为线段树的节点要么是0度，要么为2度，根据二叉树的性质可知。</li><li>若叶子节点为N，要想用连续的数组表示一棵线段树，则数组的大小应该为<strong>4N</strong>。<br>因为，根据性质3，线段树总节点数目为2<em>N-1，又由于线段树不是完全二叉树，因此其最低的叶子一层并不是紧靠最左边，这样在其倒数第二层上的索引号接近2N的位置，按照2</em>index+1和2<em>index+2的方式来访问其左右子节点，这就导致整个数组的大小要约为 4</em>N.</li><li>线段树上，任何一个区间被分解后得到的“终止”节点的数目都是log(n)量级。<br>因为每一层最多有两个“终止”节点，共log(n)层，这样在线段树上进行更新叶子节点和进行区间分解的时间复杂度都是O(logn)。</li></ol><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>以<a href="http://lx.lanqiao.cn/problem.page?gpid=T18" target="_blank" rel="noopener">ALGO-8 操作格子</a> 为例，线段树的一些基本操作：</p><ul><li>建树</li><li>区间求和</li><li>区间取最值</li><li>区间单点修改</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> left,right;<span class="comment">//保存左右边界</span></span><br><span class="line"><span class="keyword">int</span> sum,max;<span class="comment">//权值和最大值</span></span><br><span class="line">&#125;a[MAXN*<span class="number">3</span>+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">imax</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="comment">//判断大小的函数   </span></span><br><span class="line"><span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qMax</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;<span class="comment">//que=3，求l到r最大权值</span></span><br><span class="line"><span class="keyword">if</span>(l == a[n].left &amp;&amp; r == a[n].right)<span class="comment">//所求范围与左右范围相等 ，直接输出最大值   </span></span><br><span class="line"><span class="keyword">return</span> a[n].max;  </span><br><span class="line"><span class="keyword">int</span> middle = (a[n].left + a[n].right) / <span class="number">2</span>;  </span><br><span class="line"><span class="keyword">if</span>(r &lt;= middle)  </span><br><span class="line"><span class="keyword">return</span> qMax(n*<span class="number">2</span>, l, r);<span class="comment">//若所求范围在左孩子范围内，从左孩子寻找   </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(l &gt; middle)  </span><br><span class="line"><span class="keyword">return</span> qMax(n*<span class="number">2</span>+<span class="number">1</span>, l, r);<span class="comment">//若所求范围在右孩子范围内，从右孩子寻找  </span></span><br><span class="line"><span class="keyword">else</span>   </span><br><span class="line"><span class="keyword">return</span> imax(qMax(n*<span class="number">2</span>, l, middle), qMax(n*<span class="number">2</span>+<span class="number">1</span>, middle+<span class="number">1</span>, r));<span class="comment">//若范围在左右孩子之间，分别求最大值，然后求最终最大值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qSum</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;<span class="comment">//que=2，计算l到r的权值和</span></span><br><span class="line"><span class="keyword">if</span>(l==a[n].left &amp;&amp; r==a[n].right)<span class="comment">//若是叶子节点，左右相等，直接返回sum</span></span><br><span class="line"><span class="keyword">return</span> a[n].sum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> middle = (a[n].left+a[n].right)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(r &lt;= middle)&#123; <span class="comment">//下面分情况讨论</span></span><br><span class="line"><span class="keyword">return</span> qSum(n*<span class="number">2</span>, l, r);<span class="comment">//若在左孩子范围，从左孩子寻找</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(l &gt; middle)&#123;</span><br><span class="line"><span class="keyword">return</span> qSum(n*<span class="number">2</span>+<span class="number">1</span>, l, r);<span class="comment">//若在右孩子范围，从右孩子寻找</span></span><br><span class="line">&#125; <span class="keyword">else</span>&#123;<span class="comment">//若在之间，分别求解相加</span></span><br><span class="line"><span class="keyword">return</span> (qSum(n*<span class="number">2</span>, l, middle) + qSum(n*<span class="number">2</span>+<span class="number">1</span>, middle+<span class="number">1</span>, r));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> num)</span></span>&#123; </span><br><span class="line"><span class="comment">//que=1,在区间[l,r]中将r的权值改为num，这题l==r</span></span><br><span class="line"><span class="keyword">if</span>(l==a[n].left &amp;&amp; r==a[n].right)&#123;<span class="comment">//下标与左右范围相等，存本数</span></span><br><span class="line">a[n].sum = num;</span><br><span class="line">a[n].max = num;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> middle = (a[n].left+a[n].right)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(r&lt;=middle)</span><br><span class="line">change(n*<span class="number">2</span>, l, r, num);<span class="comment">//更新左孩子</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(r&gt;middle)</span><br><span class="line">change(n*<span class="number">2</span>+<span class="number">1</span>, l, r, num);<span class="comment">//更新右孩子</span></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">change(n*<span class="number">2</span>, l, middle, num);</span><br><span class="line">change(n*<span class="number">2</span>+<span class="number">1</span>, middle+<span class="number">1</span>, r, num);</span><br><span class="line">&#125;</span><br><span class="line">a[n].sum = a[n*<span class="number">2</span>].sum + a[n*<span class="number">2</span>+<span class="number">1</span>].sum;<span class="comment">//更新总和</span></span><br><span class="line">a[n].max = imax(a[n*<span class="number">2</span>].max, a[n*<span class="number">2</span>+<span class="number">1</span>].max);<span class="comment">//更新最大值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;<span class="comment">//如果左右间距相等,说明是叶子节点</span></span><br><span class="line">a[n].left = l;</span><br><span class="line">a[n].right = r;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[n].sum);</span><br><span class="line">a[n].max = a[n].sum;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> middle = (l+r)/<span class="number">2</span>;</span><br><span class="line">a[n].left = l;<span class="comment">//左边距</span></span><br><span class="line">a[n].right = r;<span class="comment">//右边距</span></span><br><span class="line">build(n*<span class="number">2</span>, l, middle);<span class="comment">//构建l至mid的左孩子</span></span><br><span class="line">build(n*<span class="number">2</span>+<span class="number">1</span>, middle+<span class="number">1</span>, r);<span class="comment">//构建mid+1到r的右孩子</span></span><br><span class="line"></span><br><span class="line">a[n].sum = a[n*<span class="number">2</span>].sum + a[n*<span class="number">2</span>+<span class="number">1</span>].sum;</span><br><span class="line">a[n].max = imax(a[n*<span class="number">2</span>].max, a[n*<span class="number">2</span>+<span class="number">1</span>].max);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">build(<span class="number">1</span>,<span class="number">1</span>,n);<span class="comment">//构建一个范围为1到n的线段树</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> que,b,c;</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;que, &amp;b, &amp;c);</span><br><span class="line"><span class="keyword">switch</span>(que)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">change(<span class="number">1</span>,b,b,c); <span class="keyword">break</span>;<span class="comment">//改变节点b的权值为c  </span></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, qSum(<span class="number">1</span>,b,c)); <span class="keyword">break</span>;<span class="comment">//计算b至c范围内的权值和   </span></span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, qMax(<span class="number">1</span>,b,c)); <span class="keyword">break</span>;<span class="comment">//计算b至c范围内的最大权值   </span></span><br><span class="line"><span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>本文整理参考自：</p><p><a href="https://www.cnblogs.com/gtarcoder/p/4786734.html" target="_blank" rel="noopener">https://www.cnblogs.com/gtarcoder/p/4786734.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;线段树基本概念&quot;&gt;&lt;a href=&quot;#线段树基本概念&quot; class=&quot;headerlink&quot; title=&quot;线段树基本概念&quot;&gt;&lt;/a&gt;线段树基本概念&lt;/h3&gt;&lt;p&gt;线段树/区间树是一种非常常用的对区间数据进行操作的数据结构。 &lt;/p&gt;
&lt;p&gt;线段树是一棵二叉树（但
      
    
    </summary>
    
      <category term="学习" scheme="https://hushhw.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法笔记" scheme="https://hushhw.cn/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
      <category term="线段树" scheme="https://hushhw.cn/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>LQOJ刷题总结</title>
    <link href="https://hushhw.cn/2018/02/21/16LQOJ/"/>
    <id>https://hushhw.cn/2018/02/21/16LQOJ/</id>
    <published>2018-02-21T15:19:04.000Z</published>
    <updated>2018-02-21T15:20:50.178Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LQOJ"><a href="#LQOJ" class="headerlink" title="LQOJ"></a>LQOJ</h1><h3 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h3><ol><li><a href="https://github.com/hushhw/LQOJ/blob/master/BASIC/BASIC-29%20%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95.cpp" target="_blank" rel="noopener">高精度加法</a>  <code>BASIC-29</code> <code>高精度加法</code> </li><li><a href="https://github.com/hushhw/LQOJ/blob/master/BASIC/BASIC-30%20%E9%98%B6%E4%B9%98%E8%AE%A1%E7%AE%97.cpp" target="_blank" rel="noopener">阶乘计算</a> <code>BASIC-30</code>  <code>高精度乘法</code></li></ol><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><ol><li><a href="https://github.com/hushhw/LQOJ/blob/master/BASIC/BASIC-27%202n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98.cpp" target="_blank" rel="noopener">2n皇后问题</a> <code>BASIC-27</code> <code>八皇后问题</code> <code>搜索</code></li></ol><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><ol><li><a href="https://github.com/hushhw/LQOJ/blob/master/BASIC/BASIC-19%20%E5%AE%8C%E7%BE%8E%E7%9A%84%E4%BB%A3%E4%BB%B7.cpp" target="_blank" rel="noopener">完美的代价</a> <code>BASIC-19</code></li><li><a href="https://github.com/hushhw/LQOJ/blob/master/ALGO/ALGO-002%20%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0(%E8%B4%AA%E5%BF%83" target="_blank" rel="noopener">最大最小公倍数</a>.cpp) <code>ALGO-2</code> </li></ol><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><ol><li><a href="https://github.com/hushhw/LQOJ/blob/master/ALGO/ALGO-003%20K%E5%A5%BD%E6%95%B0.cpp" target="_blank" rel="noopener">K好数</a> <code>ALGO-3</code> <code>数位dp</code></li><li><a href="https://github.com/hushhw/LQOJ/blob/master/ALGO/ALGO-004%20%E7%BB%93%E7%82%B9%E9%80%89%E6%8B%A9.cpp" target="_blank" rel="noopener">结点选择</a> <code>ALGO-4</code> <code>树形dp</code></li></ol><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li>图论<ul><li><a href="https://github.com/hushhw/LQOJ/blob/master/ALGO/ALGO-005%20%E6%9C%80%E7%9F%AD%E8%B7%AF.cpp" target="_blank" rel="noopener">最短路</a> <code>ALGO-5</code> <code>SPFA算法</code></li></ul></li><li>矩阵<ul><li><a href="https://github.com/hushhw/LQOJ/blob/master/BASIC/BASIC-17%20%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95.cpp" target="_blank" rel="noopener">矩阵乘法</a> <code>BASIC-17</code> <code>矩阵</code></li></ul></li><li>树&amp;二叉树</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LQOJ&quot;&gt;&lt;a href=&quot;#LQOJ&quot; class=&quot;headerlink&quot; title=&quot;LQOJ&quot;&gt;&lt;/a&gt;LQOJ&lt;/h1&gt;&lt;h3 id=&quot;高精度&quot;&gt;&lt;a href=&quot;#高精度&quot; class=&quot;headerlink&quot; title=&quot;高精度&quot;&gt;&lt;/a&gt;高精
      
    
    </summary>
    
      <category term="学习" scheme="https://hushhw.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="OJ刷题" scheme="https://hushhw.cn/categories/%E5%AD%A6%E4%B9%A0/OJ%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="OJ" scheme="https://hushhw.cn/tags/OJ/"/>
    
      <category term="刷题" scheme="https://hushhw.cn/tags/%E5%88%B7%E9%A2%98/"/>
    
      <category term="LQOJ" scheme="https://hushhw.cn/tags/LQOJ/"/>
    
  </entry>
  
  <entry>
    <title>最小生成树算法</title>
    <link href="https://hushhw.cn/2018/02/21/15%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <id>https://hushhw.cn/2018/02/21/15生成树/</id>
    <published>2018-02-21T12:45:22.000Z</published>
    <updated>2018-02-21T18:05:38.942Z</updated>
    
    <content type="html"><![CDATA[<p>关于图的几个概念定义：</p><ul><li><strong>连通图</strong>：在无向图中，若任意两个顶点vi与vj都有路径相通，则称该无向图为连通图。</li><li><strong>强连通图</strong>：在有向图中，若任意两个顶点vi与vj都有路径相通，则称该有向图为强连通图。</li><li><strong>连通网</strong>：在连通图中，若图的边具有一定的意义，每一条边都对应着一个数，称为权；权代表着连接连个顶点的代价，称这种连通图叫做连通网。</li><li><strong>生成树</strong>：一个连通图的生成树是指一个连通子图，它含有图中全部n个顶点，但只有足以构成一棵树的n-1条边。一颗有n个顶点的生成树有且仅有n-1条边，如果生成树中再添加一条边，则必定成环。</li><li><p><strong>最小生成树</strong>：在连通网的所有生成树中，所有边的代价和最小的生成树，称为最小生成树。</p><p><img src="http://img.blog.csdn.net/20160714130435508" alt="这里写图片描述"></p></li></ul><p>下面介绍两种求最小生成树算法</p><h2 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h2><p>此算法可以称为“加边法”，初始最小生成树边数为0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里。 </p><ol><li>把图中的所有边按代价从小到大排序； </li><li>把图中的n个顶点看成独立的n棵树组成的森林； </li><li>按权值从小到大选择边，所选的边连接的两个顶点ui,vi,应属于两颗不同的树，则成为最小生成树的一条边，并将这两颗树合并作为一颗树。 </li><li>重复(3),直到所有顶点都在一颗树内或者有n-1条边为止。</li></ol><p>实际上代码中就是并查集思想</p><p><img src="http://img.blog.csdn.net/20160714144315409" alt="这里写图片描述"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> from,to,val;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge &amp;x)<span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> val &lt; x.val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;e[MAXN * MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[MAXN],len=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line">r=x;</span><br><span class="line"><span class="keyword">while</span>(r!=pre[r]) <span class="comment">//如果不是根，就去找</span></span><br><span class="line">r=pre[r];</span><br><span class="line"></span><br><span class="line"><span class="comment">//路径压缩</span></span><br><span class="line"><span class="keyword">int</span> i=x;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">while</span>(i!=r)&#123;<span class="comment">//如果当前查找的结点x不是根</span></span><br><span class="line">j=pre[i];<span class="comment">//用j临时存储</span></span><br><span class="line">pre[i]=r;<span class="comment">//更新x的pre前导点直接指向r(前面已经搜过，r即根)</span></span><br><span class="line">i=j;<span class="comment">//让i指向其前导点，在下一次循环里面就会更新其前导点指向根</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) fa[i] = i;</span><br><span class="line">    sort(e,e+len);</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> rootx=find(e[i].from);<span class="comment">//分别查找根</span></span><br><span class="line">        <span class="keyword">int</span> rooty=find(e[i].to);</span><br><span class="line">        <span class="keyword">if</span>(rootx==rooty) <span class="keyword">continue</span>;</span><br><span class="line">        fa[rootx]=rooty; <span class="comment">//没有连接就更新连在一起</span></span><br><span class="line">        ans += e[i].val;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h2><p>Prim算法是一种产生最小生成树的算法。该算法于<code>1930</code>年由捷克数学家沃伊捷赫·亚尔尼克（英语：<code>Vojtěch Jarník</code>）发现；并在<code>1957</code>年由美国计算机科学家罗伯特·普里姆（英语：<code>Robert C. Prim</code>）独立发现；<code>1959</code>年，艾兹格·迪科斯彻再次发现了该算法。</p><p><code>Prim</code>算法从任意一个顶点开始，每次选择一个与当前顶点集最近的一个顶点，并将两顶点之间的边加入到树中。<code>Prim</code>算法在找当前最近顶点时使用到了贪婪算法。</p><p>算法描述：</p><ol><li>在一个加权连通图中，顶点集合<code>V</code>，边集合为<code>E</code></li><li>任意选出一个点作为初始顶点,标记为<code>visit</code>,计算所有与之相连接的点的距离，选择距离最短的，标记<code>visit</code>.</li><li>重复以下操作，直到所有点都被标记为<code>visit</code>：</li></ol><p>在剩下的点中，计算与已标记<code>visit</code>点距离最小的点，标记<code>visit</code>,证明加入了最小生成树。</p><p><img src="http://img.blog.csdn.net/20160714161107576" alt="这里写图片描述"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> dis[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) dis[i] = INF;</span><br><span class="line"><span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">dis[cur]=<span class="number">0</span>;vis[cur]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        <span class="keyword">if</span>(!vis[j] &amp;&amp; dis[j] &gt; <span class="built_in">map</span>[cur][j])</span><br><span class="line">             dis[j] = <span class="built_in">map</span>[cur][j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mini = INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            <span class="keyword">if</span>(!vis[j] &amp;&amp; dis[j] &lt; mini)</span><br><span class="line">                mini = dis[cur = j];</span><br><span class="line">        vis[cur] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) ans+=dis[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>本文参考整理自：<br>勿在浮沙筑高台<a href="http://blog.csdn.net/luoshixian099/article/details/51908175" target="_blank" rel="noopener">http://blog.csdn.net/luoshixian099/article/details/51908175</a></p><p><a href="https://www.hrwhisper.me/algorithm-graph-dijkstra-spfa-bellmanford-prim-kruskal/#_MST" target="_blank" rel="noopener">https://www.hrwhisper.me/algorithm-graph-dijkstra-spfa-bellmanford-prim-kruskal/#_MST</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于图的几个概念定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;连通图&lt;/strong&gt;：在无向图中，若任意两个顶点vi与vj都有路径相通，则称该无向图为连通图。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;强连通图&lt;/strong&gt;：在有向图中，若任意两个顶点vi与vj都有路径相
      
    
    </summary>
    
      <category term="学习" scheme="https://hushhw.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法笔记" scheme="https://hushhw.cn/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
      <category term="图论" scheme="https://hushhw.cn/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最小生成树" scheme="https://hushhw.cn/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>最短路径</title>
    <link href="https://hushhw.cn/2018/02/21/14%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    <id>https://hushhw.cn/2018/02/21/14最短路/</id>
    <published>2018-02-21T08:52:43.000Z</published>
    <updated>2018-02-21T08:54:12.070Z</updated>
    
    <content type="html"><![CDATA[<ul><li>dijkstra</li><li>SPFA</li><li>floyd</li></ul><h2 id="dijkstra-单源最短路径"><a href="#dijkstra-单源最短路径" class="headerlink" title="dijkstra(单源最短路径)"></a>dijkstra(单源最短路径)</h2><p>Dijkstra单源最短路算法，即计算从起点出发到每个点的最短路。Dijkstra常常作为其他算法的预处理。</p><ul><li>使用邻接矩阵的时间复杂度为O(n^2)</li><li>用邻接表+优先队列（堆）的时间复杂度为O((m+n)logn)近似为O(mlogn)</li></ul><p>这个算法只能计算单元最短路，而且不能计算负权值，这个算法是贪心的思想， dis数组用来储存起始点到其他点的最短路，但开始时却是存的起始点到其他点的初始路程。通过n-1遍的遍历找最短。<br>比如1到3的最短路就是比较dis[3]与dis[2]+e[2][3]，如果大于的话就更新dis[3]位dis[2]+e[2][3]，这个专业术语叫松弛，这种算法的核心思想就是通过边来松弛一号顶点到其他定点的路程，这也就能解释为什么要遍历n-1遍了。<br>book数组用来标记，被标记的是已经找过的最短路，没被标记的没有被找过的最短路，当全部找过以后算法结束，也就是说dis数组中的数是起始点到其他所有点的最短路 。</p><p>以下为以 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1874" target="_blank" rel="noopener">HDU 1874 畅通工程续</a> 完整代码：</p><ol><li>dijkstra+邻接矩阵</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">200</span>+<span class="number">10</span>;  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[MAXN][MAXN];<span class="comment">//e用来记录数组</span></span><br><span class="line"><span class="keyword">int</span> dis[MAXN];<span class="comment">//dis用来记录初始点到个点的位置</span></span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];<span class="comment">//标记是否被访问</span></span><br><span class="line"><span class="keyword">int</span> n,m;<span class="comment">//n表示顶点个数，m表示边的条数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));<span class="comment">//初始化判断数组</span></span><br><span class="line"><span class="keyword">int</span> cur=s;</span><br><span class="line">dis[cur]=<span class="number">0</span>;</span><br><span class="line">vis[cur]=<span class="number">1</span>; <span class="comment">//把起点标记为已访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Dijkstra算法核心语句</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!vis[j] &amp;&amp; dis[j] &gt; dis[cur] + <span class="built_in">map</span>[cur][j])&#123;  <span class="comment">//更新cur到j的距离</span></span><br><span class="line">dis[j]=dis[cur] + <span class="built_in">map</span>[cur][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mini=inf;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!vis[j] &amp;&amp; dis[j]&lt;mini)&#123;<span class="comment">//更新当前未访问的最小的dis[cur]</span></span><br><span class="line">mini=dis[j];</span><br><span class="line">cur = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">vis[cur]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m))&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">dis[i]=inf;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line"><span class="built_in">map</span>[i][j]=inf;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> from,to,val;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++)&#123;<span class="comment">//读入边</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;from,&amp;to,&amp;val);</span><br><span class="line"><span class="built_in">map</span>[from][to] = <span class="built_in">map</span>[to][from] = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s,t;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;s,&amp;t); <span class="comment">//输入起点和终点</span></span><br><span class="line">dijkstra(s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dis[t]==inf)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dis[t]);</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>dijkstra+优先队列</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">200</span>+<span class="number">10</span>;  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[MAXN],len;<span class="comment">//记录数组</span></span><br><span class="line"><span class="keyword">int</span> dis[MAXN];<span class="comment">//dis用来记录初始点到个点的位置</span></span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];<span class="comment">//标记是否被访问</span></span><br><span class="line"><span class="keyword">int</span> n,m;<span class="comment">//n表示顶点个数，m表示边的条数</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to, val, next;</span><br><span class="line">&#125;e[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">e[len].to=to;</span><br><span class="line">e[len].val=val;</span><br><span class="line">e[len].next=head[from];</span><br><span class="line">head[from]=len++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> val, id;</span><br><span class="line">point(<span class="keyword">int</span> id,<span class="keyword">int</span> val):id(id),val(val)&#123;&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> point &amp;x)<span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> val&gt;x.val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));<span class="comment">//初始化判断数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">dis[i] = inf;</span><br><span class="line">priority_queue&lt;point&gt; q;</span><br><span class="line">q.push(point(s,<span class="number">0</span>));</span><br><span class="line">dis[s]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> cur=q.top().id;</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">if</span>(vis[cur]) <span class="keyword">continue</span>;</span><br><span class="line">vis[cur]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[cur]; i!=<span class="number">-1</span>; i=e[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> id=e[i].to;</span><br><span class="line"><span class="keyword">if</span>(!vis[id] &amp;&amp; dis[cur]+e[i].val &lt; dis[id])&#123;</span><br><span class="line">dis[id]=dis[cur]+e[i].val;</span><br><span class="line">q.push(point(id, dis[id]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m))&#123;</span><br><span class="line">len=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line"><span class="keyword">int</span> from, to, val;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;from,&amp;to,&amp;val);</span><br><span class="line">add(from, to, val);</span><br><span class="line">add(to, from, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> s,t;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;s,&amp;t); <span class="comment">//输入起点和终点</span></span><br><span class="line">dijkstra(s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dis[t]==inf)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dis[t]);</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SPFA（bellman-ford）"><a href="#SPFA（bellman-ford）" class="headerlink" title="SPFA（bellman-ford）"></a>SPFA（bellman-ford）</h2><p>SPFA是bellman-ford算法的队列实现版本（貌似也改进了点）</p><p>SPFA的实现如下：</p><p>用数组dis记录更新后的状态，cnt记录更新的次数，队列q记录更新过的顶点，算法依次从q中取出顶点v,按照dis(k)[u]=min{dis(k-1)[v]+e(v,u)}的递归式更新。在计算过程中，一旦发现顶点K有cnt[k]&gt;n，说明有一个从顶点K出发的负权圈，此时没有最短路，应终止算法。否则，队列为空的时候，算法得到G的各顶点的最短路径长度。</p><p> 下面举一个实例来说明SFFA算法是怎样进行的：<br><img src="http://www.layz.net/LAOJ/suanfa/pic/s9-4-1.jpg" alt="img"><br><img src="http://www.layz.net/LAOJ/suanfa/pic/s9-4-2.jpg" alt="img"></p><p>1.邻接矩阵的SPFA <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1874" target="_blank" rel="noopener">HDU 1874 畅通工程续</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">200</span>+<span class="number">10</span>;  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[MAXN][MAXN];<span class="comment">//记录数组</span></span><br><span class="line"><span class="keyword">int</span> dis[MAXN];<span class="comment">//dis用来记录初始点到个点的位置</span></span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];<span class="comment">//标记是否被访问</span></span><br><span class="line"><span class="keyword">int</span> n,m;<span class="comment">//n表示顶点个数，m表示边的条数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">dis[i]=inf;</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">vis[s]=<span class="number">1</span>;</span><br><span class="line">dis[s]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.push(s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> cur=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">vis[cur]=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[i] &gt; dis[cur] + <span class="built_in">map</span>[cur][i])&#123;</span><br><span class="line">dis[i] = dis[cur] + <span class="built_in">map</span>[cur][i];</span><br><span class="line"><span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">q.push(i);</span><br><span class="line">vis[i]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m))&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line"><span class="built_in">map</span>[i][j]=inf;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> from,to,val;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++)&#123;<span class="comment">//读入边</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;from,&amp;to,&amp;val);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>[from][to]&gt;val)</span><br><span class="line"><span class="built_in">map</span>[from][to] = <span class="built_in">map</span>[to][from] = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s,t;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;s,&amp;t); <span class="comment">//输入起点和终点</span></span><br><span class="line">SPFA(s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dis[t]==inf)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dis[t]);</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>邻接表的SPFA（推荐）<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1874" target="_blank" rel="noopener">HDU 1874 畅通工程续</a></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">const int inf=0x3f3f3f3f;</span><br><span class="line">const int MAXN=200+10;  </span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int head[MAXN],len;</span><br><span class="line">int dis[MAXN];//dis用来记录初始点到个点的位置</span><br><span class="line">bool vis[MAXN];//标记是否被访问</span><br><span class="line">int n,m;//n表示顶点个数，m表示边的条数</span><br><span class="line"></span><br><span class="line">struct edge&#123;</span><br><span class="line">int to, val, next;</span><br><span class="line">&#125;e[MAXN];</span><br><span class="line"></span><br><span class="line">void add(int from, int to, int val)&#123;</span><br><span class="line">e[len].to=to;</span><br><span class="line">e[len].val=val;</span><br><span class="line">e[len].next=head[from];</span><br><span class="line">head[from]=len++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void SPFA(int s)&#123;</span><br><span class="line">memset(vis, 0, sizeof(vis));//初始化判断数组</span><br><span class="line">for(int i=0; i&lt;n; i++)</span><br><span class="line">dis[i] = inf;</span><br><span class="line"></span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">q.push(s);</span><br><span class="line">vis[s]=true;</span><br><span class="line">dis[s]=0;</span><br><span class="line"></span><br><span class="line">while(!q.empty())&#123;</span><br><span class="line">int cur=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">vis[cur]=false;</span><br><span class="line">for(int i=head[cur]; i!=-1; i=e[i].next)&#123;</span><br><span class="line">int id=e[i].to;</span><br><span class="line">if(dis[id] &gt; dis[cur]+e[i].val)&#123;</span><br><span class="line">dis[id] = dis[cur]+e[i].val;</span><br><span class="line">if(!vis[id])&#123;</span><br><span class="line">vis[id]=true;</span><br><span class="line">q.push(id);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))&#123;</span><br><span class="line">len=0;</span><br><span class="line">memset(head, -1, sizeof(head));</span><br><span class="line"></span><br><span class="line">for(int i=0; i&lt;m; i++)&#123;</span><br><span class="line">int from, to, val;</span><br><span class="line">scanf(&quot;%d%d%d&quot;,&amp;from,&amp;to,&amp;val);</span><br><span class="line">add(from, to, val);</span><br><span class="line">add(to, from, val);</span><br><span class="line">&#125;</span><br><span class="line">int s,t;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;s,&amp;t); //输入起点和终点</span><br><span class="line">SPFA(s);</span><br><span class="line"></span><br><span class="line">if(dis[t]==inf)</span><br><span class="line">printf(&quot;-1\n&quot;);</span><br><span class="line">else</span><br><span class="line">printf(&quot;%d\n&quot;,dis[t]);</span><br><span class="line">&#125;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="floyd"><a href="#floyd" class="headerlink" title="floyd"></a>floyd</h2><p><strong>Floyd-Warshall算法</strong>（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包。Floyd-Warshall算法的时间复杂度为$O(N^3)$，空间复杂度为$O(N^2)$。</p><p>这是一个dp（动态规划的过程）<br>dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);<br>即从顶点i到j且经过顶点k的最短路径长度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">200</span>+<span class="number">10</span>;  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> n,m;<span class="comment">//n表示顶点个数，m表示边的条数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;n; k++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">dis[i][j]=min(dis[i][j], dis[i][k]+dis[k][j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m))&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">dis[i][j]=inf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line"><span class="keyword">int</span> from, to, val;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;from,&amp;to,&amp;val);</span><br><span class="line"><span class="keyword">if</span>(dis[from][to] &gt; val)  </span><br><span class="line">dis[to][from]=dis[from][to]=val; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> s,t;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;s,&amp;t); <span class="comment">//输入起点和终点</span></span><br><span class="line"><span class="keyword">if</span>(s==t)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">floyd();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dis[s][t]==inf)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dis[s][t]);</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>本文整理自：</p><p><a href="http://blog.csdn.net/acm_1361677193/article/details/48211319" target="_blank" rel="noopener">http://blog.csdn.net/acm_1361677193/article/details/48211319</a></p><p><a href="http://blog.csdn.net/xunalove/article/details/70045815" target="_blank" rel="noopener">http://blog.csdn.net/xunalove/article/details/70045815</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;dijkstra&lt;/li&gt;
&lt;li&gt;SPFA&lt;/li&gt;
&lt;li&gt;floyd&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;dijkstra-单源最短路径&quot;&gt;&lt;a href=&quot;#dijkstra-单源最短路径&quot; class=&quot;headerlink&quot; title=&quot;dijk
      
    
    </summary>
    
      <category term="学习" scheme="https://hushhw.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法笔记" scheme="https://hushhw.cn/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
      <category term="图论" scheme="https://hushhw.cn/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最短路" scheme="https://hushhw.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>数位dp总结</title>
    <link href="https://hushhw.cn/2018/02/20/13%E6%95%B0%E4%BD%8Ddp/"/>
    <id>https://hushhw.cn/2018/02/20/13数位dp/</id>
    <published>2018-02-20T10:15:49.000Z</published>
    <updated>2018-02-21T08:54:20.411Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>“在信息学竞赛中，有一类与数位相关的区间统计问题。这类问题往往具有比较浓厚的数学味道，无法暴力求解，需要在数位上进行地推等操作。”——刘聪《浅谈数位类统计问题》</p></blockquote><p>这类问题往往需要一些预处理，这里就要用到数位dp。</p><p>数位DP是解决把一个数字区间里所有数字按位拆分再进行计算或计数的问题的动态规划算法。</p><h2 id="基本思想与方法"><a href="#基本思想与方法" class="headerlink" title="基本思想与方法"></a>基本思想与方法</h2><p>题目中经常需要统计区间[l, r]的满足题意的数的个数，这往往可以转换成求[0,r] - [0,l)的问题。对于求区间[0,n]有一个通用的方法：</p><p>​    对于一个小于n的数，肯定是从高位到低位出现某一位&lt;n的那一位，比如n=58(n为十进制)，x=49时，此时x的十位小于n，x=51时，此时x的个位小于n。</p><p>有了这个性质，我们可以从高位到低位枚举第一次&lt;n对应位是哪一位。这样之前的位确定了，之后的位就不受n的限制即从00…0~99…9，可以先预处理，然后这时就可以直接统计答案。</p><p>预处理f数组。$F[i, st]$代表的是位数为i，状态为st的方案数。这里的st根据题目需要确定。如i=4，$F[i, st]$也就是0000~9999的符合条件的数的个数。</p><p>决策第i位是多少（0~9），F[i, st] = F[i, st] + F[i-1, st’]，st’为相对应的状态。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="【Hdu2089-吉利数】"><a href="#【Hdu2089-吉利数】" class="headerlink" title="【Hdu2089 吉利数】"></a>【Hdu2089 吉利数】</h3><blockquote><p>题意：</p><p>区间[l,r]内数字的数位不含62且不含4的数的个数，0&lt;l&lt;=r&lt;1000000</p><p>如62315包含62，所以不合法</p></blockquote><p>参照前面提到的思路，先预处理一个f数组，然后统计[0, m] - [0, n)。</p><p>f[i, j]表示开头为j 的i 位数中不包含”62”或”4”的数有多少个。如f[2, 6]包含60，61，63，65，66，67，68，69。我们这里再举个栗子f[3, 0]：表示从1~100中满足条件的个数、（这里就不枚举了、、、）【0,99】</p><p>那么f[3, 1]呢？表示从100~200中满足条件的个数【100,199】</p><p>具体看代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">7</span>; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">10</span>; j++)&#123;<span class="comment">//枚举第i位数上的数字</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">10</span>; k++)&#123;<span class="comment">//枚举第i-1为数上的数字</span></span><br><span class="line"><span class="keyword">if</span>(j!=<span class="number">4</span> &amp;&amp; !(j==<span class="number">6</span> &amp;&amp; k==<span class="number">2</span>))<span class="comment">//满足条件</span></span><br><span class="line">dp[i][j] += dp[i<span class="number">-1</span>][k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">7</span>; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">10</span>; j++)&#123;<span class="comment">//枚举第i位数上的数字</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">10</span>; k++)&#123;<span class="comment">//枚举第i-1为数上的数字</span></span><br><span class="line"><span class="keyword">if</span>(j!=<span class="number">4</span> &amp;&amp; !(j==<span class="number">6</span> &amp;&amp; k==<span class="number">2</span>))<span class="comment">//满足条件</span></span><br><span class="line">dp[i][j] += dp[i<span class="number">-1</span>][k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">int</span> digit[<span class="number">10</span>];<span class="comment">//存储每位数字</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="number">1</span>;<span class="comment">//位数</span></span><br><span class="line"><span class="keyword">while</span>(n)&#123;</span><br><span class="line">digit[len++]=n%<span class="number">10</span>;</span><br><span class="line">n /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;<span class="comment">//记录满足条件的结果</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=len; i&gt;=<span class="number">1</span>; i--)&#123;<span class="comment">//从最高为开始遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;digit[i]; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(j!=<span class="number">4</span> &amp;&amp; !(digit[i+<span class="number">1</span>]==<span class="number">6</span> &amp;&amp; j==<span class="number">2</span>))</span><br><span class="line">ans += dp[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(digit[i]==<span class="number">4</span> || (digit[i+<span class="number">1</span>]==<span class="number">6</span> &amp;&amp; digit[i]==<span class="number">2</span>)) <span class="comment">////第i位已经不满足条件，则i位以后都不可能满足条件，结束循环  </span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r)&#123;</span><br><span class="line"><span class="keyword">if</span>(l+r==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;solve(r+<span class="number">1</span>)-solve(l)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外一种方法：<code>记忆化的数位dp</code></p><p>通常而言，有四个参数必须 dp( pos, flag, limit )<br>pos表示当前<strong>正在</strong>枚举的数位。<br>flag标志已经枚举的前缀是否某种性质（前面的数位和，是否含有某个数，前一个枚举的数等等。。），当然flag可以有多个。<br>limit表示当前是否为上限，有时还会记录是否有前导0。<br>相较而言，记忆化搜索更容易编写，需要维护的细节更少。</p><p>回到这题上面来，数位上不能有4也不能有连续的62，没有4的话在枚举的时候判断一下，不枚举4就可以保证状态合法了，所以这个约束没有记忆化的必要，而对于62的话，涉及到两位，当前一位是6或者不是6这两种不同情况我计数是不相同的，所以要用状态来记录不同的方案数。</p><p>dp[pos][sta]表示当前第pos位，前一位是否是6的状态，这里sta只需要去0和1两种状态就可以了，不是6的情况可视为同种，不会影响计数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">10</span>][<span class="number">2</span>]; <span class="comment">//dp[i][j]表示，当前第i位，前一位是否是6的状态</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> l,r,tot;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pos表示当前位置，pre表示前一个数，sta表示当前状态，也就是之前是否为6</span></span><br><span class="line"><span class="comment">//lim表示当前是否是有限制的，比如967，当我们第一个数选择9时，第二个数就只能选择0-6了</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> pre, <span class="keyword">int</span> sta, <span class="keyword">int</span> lim)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cur=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(pos==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//如果执行到0了，当前构成的数可行</span></span><br><span class="line"><span class="keyword">if</span>(!lim &amp;&amp; dp[pos][sta]!=<span class="number">-1</span>) <span class="keyword">return</span> dp[pos][sta];</span><br><span class="line"><span class="keyword">int</span> up = lim? a[pos]:<span class="number">9</span>; <span class="comment">//是否有限制判断</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=up; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">4</span> || (pre==<span class="number">6</span> &amp;&amp; i==<span class="number">2</span>)) <span class="comment">//如果当前数字为4，或者前一个数字为6，当前位2，排除</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">cur += dfs(pos<span class="number">-1</span>, i, i==<span class="number">6</span>, lim&amp;&amp;i==a[pos]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!lim) dp[pos][sta]=cur;</span><br><span class="line"><span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">tot = <span class="number">0</span>;<span class="comment">//tot用来记录位数</span></span><br><span class="line"><span class="keyword">while</span>(x)&#123;</span><br><span class="line">a[++tot]=x%<span class="number">10</span>;</span><br><span class="line">x /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dfs(tot,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r)&amp;&amp;(l+r))&#123;</span><br><span class="line"><span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, solve(r)-solve(l<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;“在信息学竞赛中，有一类与数位相关的区间统计问题。这类问题往往具有比较浓厚的数学味道，无法暴力求解，需要在数位上进行地推等操作。”——刘聪《浅谈数位类统计问题》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这类问题往往需要一些预处理，这里就要用到数位
      
    
    </summary>
    
      <category term="学习" scheme="https://hushhw.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法笔记" scheme="https://hushhw.cn/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
      <category term="动态规划" scheme="https://hushhw.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="数位dp" scheme="https://hushhw.cn/tags/%E6%95%B0%E4%BD%8Ddp/"/>
    
  </entry>
  
  <entry>
    <title>博弈论总结</title>
    <link href="https://hushhw.cn/2018/02/20/12%E5%8D%9A%E5%BC%88/"/>
    <id>https://hushhw.cn/2018/02/20/12博弈/</id>
    <published>2018-02-19T17:32:25.000Z</published>
    <updated>2018-02-19T17:37:05.455Z</updated>
    
    <content type="html"><![CDATA[<p>今天开始总结博弈这块的知识点，博弈论真的是一门非常神奇的学科。博弈是信息学和数学试题中常会出现的一种类型，算法灵活多变是其最大特点，而其中有一类试题更是完全无法用常见的博弈树来进行解答。 <strong>寻找必败态</strong>即为针对此类试题给出一种解题思路。</p><p>常见的几种博弈：</p><h2 id="巴什博弈（Bash-Game）"><a href="#巴什博弈（Bash-Game）" class="headerlink" title="巴什博弈（Bash Game）"></a>巴什博弈（Bash Game）</h2><blockquote><p>问题模型：只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取m个。最后取光者得胜。</p></blockquote><p>显然，如果n=m+1，那么由于一次最多只能取m个，所以，无论先取者拿走多少个，后取者都能够一次拿走剩余的物品，后者取胜。因此我们发现了如何取胜的法则：</p><script type="math/tex; mode=display">如果n=(m+1)r+s，（r为任意自然数，s≤m)</script><p>那么先取者要拿走s个物品，如果后取者拿走k（≤m)个，那么先取者再拿走m+1-k个，结果剩下(m+1)(r-1)个，以后保持这样的取法，那么先取者肯定获胜。</p><p>总之，要保持给对手留下(m+1)的倍数，那么最后就能获胜。</p><script type="math/tex; mode=display">取石子（一)\\时间限制：3000 ms   |   内存限制：65535 KB \\难度：2\\</script><p>描述<br>​    一天，TT在寝室闲着无聊，和同寝的人玩起了取石子游戏，而由于条件有限，他/她们是用旺仔小馒头当作石子。游戏的规则是这样的。设有一堆石子，数量为N（1&lt;=N&lt;=1000000），两个人轮番取出其中的若干个，每次最多取M（1&lt;=M&lt;=1000000），最先把石子取完者胜利。我们知道，TT和他/她的室友都十分的聪明，那么如果是TT先取，他/她会取得游戏的胜利么？ </p><p>输入<br>​    第一行是一个正整数n表示有n组测试数据<br>​    输入有不到1000组数据，每组数据一行，有两个数N和M,之间用空格分隔。 </p><p>输出<br>​    对于每组数据，输出一行。如果先取的TT可以赢得游戏，则输出“Win”，否则输出“Lose”（引号不用输出） </p><p>样例输入 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1000 1</span><br><span class="line">1 100</span><br></pre></td></tr></table></figure><p>样例输出 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Lose</span><br><span class="line"></span><br><span class="line">Win</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 巴什博弈</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> N, num, limit;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line"><span class="keyword">while</span>(N--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;num, &amp;limit);</span><br><span class="line"><span class="keyword">if</span>(num%(limit+<span class="number">1</span>)!=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Win\n"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Lose\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>巴什博弈变形： </p><script type="math/tex; mode=display">取石子（七） \\时间限制：1000 ms  |  内存限制：65535 KB \\难度：1</script><p>描述<br>​    Yougth和Hrdv玩一个游戏，拿出n个石子摆成一圈，Yougth和Hrdv分别从其中取石子，谁先取完者胜，每次可以从中取一个或者相邻两个，Hrdv先取，输出胜利着的名字。 </p><p>输入<br>​    输入包括多组测试数据。<br>​    每组测试数据一个n，数据保证int范围内。 </p><p>输出<br>​    输出胜利者的名字。 </p><p>样例输入 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>样例输出 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hrdv</span><br><span class="line">Yougth</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解题思路：假设石子数等于5，如果先者先取一个，那么后者拿走两个，将剩下的两个石子分成两堆，后者赢。如果先者先取二个，那么后者取一个使剩下的两个石子分成两堆，后者赢。假设石子数等于6，如果先者先取一个，那么后者拿走一个，将剩下的石子分成两段，每段两个，如果先者再拿两个，那么后者赢，如果先者再拿一个，那么后者再取另一堆中的一个，这样剩下的两个石子被分成两堆， 后者赢。         如果先者先取两个，那么后者也取两个使剩下的两个石子分成两堆，后者赢。所以当先者取走后，后者取走一个或者两个，将剩下的石子分成对称的两段，以此类推，那么如果石子数大于2后者一定赢。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"><span class="keyword">int</span> n;  </span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF)  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">if</span>(n &gt; <span class="number">2</span>)  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Yougth\n"</span>);  </span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Hrdv\n"</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="威佐夫博弈（Wythoff-Game）"><a href="#威佐夫博弈（Wythoff-Game）" class="headerlink" title="威佐夫博弈（Wythoff Game）"></a>威佐夫博弈（Wythoff Game）</h2><blockquote><p>问题模型：有两堆各若干个物品，两个人轮流从某一堆或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜。</p></blockquote><p>我们用（ak，bk）（ak ≤ bk ,k=0，1，2，…,n)表示两堆物品的数量并称其为局势，如果甲面对（0，0），那么甲已经输了，这种局势我们称为奇异局势。前几个奇异局势是：（0，0）、（1，2）、（3，5）、（4，7）、（6，10）、（8，13）、（9，15）、（11，18）、（12，20）。 可以看出,a0=b0=0,ak是未在前面出现过的最小自然数,而 bk= ak + k，奇异局势有如下三条性质： </p><ul><li>任何自然数都包含在一个且仅有一个奇异局势中。 </li><li>任意操作都可将奇异局势变为非奇异局势。 </li><li>采用适当的方法，可以将非奇异局势变为奇异局势。</li></ul><p>从如上性质可知，两个人如果都采用正确操作，那么面对非奇异局势，先拿者必胜；反之，则后拿者取胜。<br> 那么任给一个局势（a，b），怎样判断它是不是奇异局势呢？我们有如下公式： </p><script type="math/tex; mode=display">a_k =[\frac {k(1+√5)}2]，b_k= a_k + k（k=0，1，2，...,n 方括号表示取整函数)</script><script type="math/tex; mode=display">取石子 (四） \\时间限制：1000 ms  |  内存限制：65535 KB \\难度：4</script><p>描述<br>​    有两堆石子，数量任意，可以不同。游戏开始由两个人轮流取石子。游戏规定，每次有两种不同的取法，一是可以在任意的一堆中取走任意多的石子；二是可以在两堆中同时取走相同数量的石子。最后把石子全部取完者为胜者。现在给出初始的两堆石子的数目，如果轮到你先取，假设双方都采取最好的策略，问最后你是胜者还是败者。 </p><p>输入<br>​    输入包含若干行，表示若干种石子的初始情况，其中每一行包含两个非负整数a和b，表示两堆石子的数目，a和b都不大于1,000,000,000。 </p><p>输出<br>​    输出对应也有若干行，每行包含一个数字1或0，如果最后你是胜者，则为1，反之，则为0。 </p><p>样例输入 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 1</span><br><span class="line">8 4</span><br><span class="line">4 7</span><br></pre></td></tr></table></figure><p>样例输出 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n)&#123;</span><br><span class="line"><span class="keyword">if</span>(m&gt;n)</span><br><span class="line">swap(m,n);</span><br><span class="line"><span class="keyword">int</span> k = n-m;</span><br><span class="line"><span class="keyword">int</span> data = <span class="built_in">floor</span>(k*(<span class="number">1.0</span>+<span class="built_in">sqrt</span>(<span class="number">5.0</span>))/<span class="number">2.0</span>);</span><br><span class="line"><span class="keyword">if</span>(data==m)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">Wythoff Game \\时间限制：1000 ms  |  内存限制：65535 KB \\难度：1</script><p>描述<br>​    最近ZKC同学在学博弈，学到了一个伟大的博弈问题—威佐夫博弈。<br>​    相信大家都学过了吧？没学过？没问题。我将要为你讲述一下这个伟大的博弈问题。 有两堆石子，数量任意，可以不同。游戏开始由两个人轮流取石子。 游戏规定，每次有两种不同的取法：<br>一是可以在任意的一堆中取走任意多的石子； 二是可以在两堆中同时取走相同数量的石子。 最后把石子全部取完者为胜者。<br>​    我们今天要做的是求前n个必败态。<br>​    什么是必败态？比如我们把（a，b）称为一种状态，a，b分别为两堆石子中所剩的数目。如果a=0，b=0，我们说该种状态为必败态，因为我不能再进行游戏，即使是可以进行，那也是必败的，你知道，游戏的我们都是非常聪明的。（0,0）（1,2）（3,5）…都是必败态，我们今天要做的就是求前n个必败态。不会？好吧！<br>​    我再告诉你：假设第n个必败态为（a，b）a为前n-1个必败态中没有出现的最小自然数，b=a+n。这下大家应该明白了吧。好吧，我们的任务就的要前n个必败态。规定第0个必败态为（0,0）。 </p><p>输入<br>​    多组数据。<br>​    输入为一个数n（0&lt;=n&lt;=100000）。 </p><p>输出<br>​    按照要求求出前n个必败态。输出格式看下面样例。<br>样例输入 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>样例输出 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(0,0)(1,2)(3,5)(4,7)</span><br><span class="line">(0,0)(1,2)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line">&#125;N;</span><br><span class="line"></span><br><span class="line">N res[<span class="number">100001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">res[<span class="number">0</span>].a = <span class="number">0</span>;</span><br><span class="line">res[<span class="number">0</span>].b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">100001</span>; i++)&#123;</span><br><span class="line">res[i].a = (<span class="number">1</span>+<span class="built_in">sqrt</span>(<span class="number">5</span>))*i/<span class="number">2</span>;</span><br><span class="line">res[i].b = res[i].a+i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"(%d,%d)"</span>, res[i].a, res[i].b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尼姆博弈（Nimm-Game）"><a href="#尼姆博弈（Nimm-Game）" class="headerlink" title="尼姆博弈（Nimm Game）"></a>尼姆博弈（Nimm Game）</h2><blockquote><p>问题模型：有三堆各若干个物品，两个人轮流从某一堆取任意多的物品，规定每次至少取一个，多者不限，最后取光者得胜。</p></blockquote><p>用（a，b，c）表示某种局势，显证（0，0，0）是第一种奇异局势，无论谁面对奇异局势，都必然失败。第二种奇异局势是（0，n，n），只要与对手拿走一样多的物品，最后都将导致（0，0，0）。搞定这个问题需要把必败态的规律找出：(a,b,c)是必败态等价于a^b^c=0(^表示异或运算）。</p><script type="math/tex; mode=display">取石子（二） \\时间限制：3000 ms  |  内存限制：65535 KB \\难度：5</script><p>描述<br>​    小王喜欢与同事玩一些小游戏，今天他们选择了玩取石子。 游戏规则如下：共有N堆石子，已知每堆中石子的数量，并且规定好每堆石子最多可以取的石子数（最少取1颗）。 </p><p>​    两个人轮流取子，每次只能选择N堆石子中的一堆，取一定数量的石子(最少取一个），并且取的石子数量不能多于该堆石子规定好的最多取子数，等哪个人无法取子时就表示此人输掉了游戏。 </p><p>​    假设每次都是小王先取石子，并且游戏双方都绝对聪明，现在给你石子的堆数、每堆石子的数量和每堆石子规定的单次取子上限，请判断出小王能否获胜。 </p><p>输入<br>​    第一行是一个整数T表示测试数据的组数(T&lt;100)<br>​    每组测试数据的第一行是一个整数N(1&lt;N&lt;100),表示共有N堆石子，随后的N行每行表示一堆石子，这N行中每行有两个数整数m,n表示该堆石子共有m个石子，该堆石子每次最多取n个。(0&lt;=m,n&lt;=2^31) </p><p>输出<br>​    对于每组测试数据，输出Win表示小王可以获胜，输出Lose表示小王必然会败。 </p><p>样例输入 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1 </span><br><span class="line">1000 1</span><br><span class="line">2</span><br><span class="line">1 1</span><br><span class="line">1 1</span><br></pre></td></tr></table></figure><p>样例输出 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Lose</span><br><span class="line">Lose</span><br></pre></td></tr></table></figure><p> 提示<br>​    注意下面一组测试数据 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 </span><br><span class="line">1 1</span><br><span class="line">2 2</span><br></pre></td></tr></table></figure><p>​    正确的结果应该是<code>Win</code><br>​    因为小王会先从第二堆石子中取一个石子，使状态变为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> 1 1</span><br><span class="line"> 1 2</span><br></pre></td></tr></table></figure><p>​    这种状态下，无论对方怎么取，小王都能获胜。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line"><span class="keyword">int</span> m,n,g,sum=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;g;</span><br><span class="line"><span class="keyword">while</span>(g--)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n;</span><br><span class="line">sum ^= m%(n+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(sum? <span class="string">"Win"</span>:<span class="string">"Lose"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">取石子（三）\\时间限制：1000 ms  |  内存限制：1000 KB\\难度：6</script><p>描述<br>​    小王喜欢与同事玩一些小游戏，今天他们选择了玩取石子。游戏规则如下：共有N堆石子，已知每堆中石子的数量，两个人轮流取子，每次只能选择N堆石子中的一堆，取一定数量的石子（最少取一个），取过子之后，还可以将该堆石子中剩下的任意多个石子中随意选取几个放到其它的任意一堆或几堆上。等哪个人无法取子时就表示此人输掉了游戏。注意，一堆石子没有子之后，就不能再往此处放石子了。<br>​    假设每次都是小王先取石子，并且游戏双方都绝对聪明，现在给你石子的堆数、每堆石子的数量，请判断出小王能否获胜。<br>​    例如：如果最开始有4堆石子，石子个数分别为3 1 4 2，而小王想决定要先拿走第三堆石子中的两个石子（石子堆状态变为3 1 2 2），然后他可以使石子堆达到的状态有以下几种：<br>​    3 1 2 2（不再移动石子）<br>​    4 1 1 2（移动到第一堆一个）<br>​    3 2 1 2（移动到第二堆一个）<br>​    3 1 1 3（移动到第四堆一个）<br>​    5 1 0 2（全部移动到第一堆）<br>​    3 3 0 2（全部移动到第二堆）<br>​    3 1 0 4（全部移动到最后）</p><p>输入<br>​    可能有多组测试数据(测试数据组数不超过1000)<br>​    每组测试数据的第一行是一个整数，表示N(1&lt;=N&lt;=10)<br>​    第二行是N个整数分别表示该堆石子中石子的数量。（每堆石子数目不超过100）<br>​    当输入的N为0时，表示输入结束</p><p>输出<br>​    对于每组测试数据，输出Win表示小王可以获胜，输出Lose表示小王必然会败。</p><p>样例输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2 1 3</span><br><span class="line">2</span><br><span class="line">1 1</span><br><span class="line">0</span><br></pre></td></tr></table></figure></p><p>样例输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Win</span><br><span class="line">Lose</span><br></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, ans, a;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n), n)&#123;</span><br><span class="line"><span class="keyword">while</span>(n--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">++arr[a];</span><br><span class="line">&#125;</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1001</span>; ++i)</span><br><span class="line"><span class="keyword">if</span>(arr[i] &amp; <span class="number">1</span>)&#123;</span><br><span class="line">ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(ans ? <span class="string">"Win\n"</span> : <span class="string">"Lose\n"</span>);</span><br><span class="line"><span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="keyword">sizeof</span>(arr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天开始总结博弈这块的知识点，博弈论真的是一门非常神奇的学科。博弈是信息学和数学试题中常会出现的一种类型，算法灵活多变是其最大特点，而其中有一类试题更是完全无法用常见的博弈树来进行解答。 &lt;strong&gt;寻找必败态&lt;/strong&gt;即为针对此类试题给出一种解题思路。&lt;/p&gt;
      
    
    </summary>
    
      <category term="学习" scheme="https://hushhw.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法笔记" scheme="https://hushhw.cn/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
      <category term="博弈" scheme="https://hushhw.cn/tags/%E5%8D%9A%E5%BC%88/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="https://hushhw.cn/2018/02/13/11%E6%8E%92%E5%BA%8F/"/>
    <id>https://hushhw.cn/2018/02/13/11排序/</id>
    <published>2018-02-12T18:52:47.000Z</published>
    <updated>2018-02-13T13:17:55.764Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>之前也有总结排序部分，但是总是忘记，这段时间在整理算法笔记，所以借机再整理一份。<br>主要整理的是八大内部排序，分析代码，时间复杂度等</p><p>排序分类见图：（图片来源见图片链接）<br><img src="http://cuijiahua.com/wp-content/uploads/2018/01/algorithm_9_2.png" alt="图片来源见链接"></p><p>各排序算法基本性能：<br><img src="http://cuijiahua.com/wp-content/uploads/2018/01/algorithm_9_3.png" alt="图片来源见链接"></p><h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h2><h3 id="1-1-冒泡排序算法思想及代码实现"><a href="#1-1-冒泡排序算法思想及代码实现" class="headerlink" title="1.1 冒泡排序算法思想及代码实现"></a>1.1 冒泡排序算法思想及代码实现</h3><p>冒泡排序是一种交换排序，基本算法思想是重复访问要排序的数列，每趟排序过程中通过两两比较相邻元素，按一定顺序交换，直到没有在需要交换即数列排序完成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bubbleSort(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>)&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">list</span>.empty())&#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result = <span class="built_in">list</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; result.size()<span class="number">-1</span>; ++i)&#123;<span class="comment">//外层循环仅标记趟数</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"第"</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">"趟排序:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j &lt; result.size()<span class="number">-1</span>; j++)&#123;<span class="comment">//内层循环进行相邻数据交换</span></span><br><span class="line"><span class="keyword">if</span>(result[j+<span class="number">1</span>] &lt; result[j])&#123;</span><br><span class="line">swap(result[j+<span class="number">1</span>], result[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"排序中:"</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>; s&lt;result.size(); s++)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;result[s]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"排序结果:"</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>; s &lt; result.size(); s++)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;result[s]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序前"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.size(); i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; test[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">result = bubbleSort(test);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序后"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; result[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-冒泡排序算法性能"><a href="#1-2-冒泡排序算法性能" class="headerlink" title="1.2 冒泡排序算法性能"></a>1.2 冒泡排序算法性能</h3><p>若文件的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数C和记录移动次数M均达到最小值：Cmin = N - 1, Mmin = 0。所以，<strong>冒泡排序最好时间复杂度为O(N)</strong>。<br>若初始文件是反序的，需要进行 N -1 趟排序。每趟排序要进行 N - i 次关键字的比较(1 ≤ i ≤ N - 1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：<br>$C_{max} = N(N-1)/2 = O(N^2)$<br>$M_{max} = 3N(N-1)/2 = O(N^2)$<br>冒泡排序的最坏时间复杂度为$O(N^2)$。<br>因此，冒泡排序的平均时间复杂度为$O(N^2)$。<br>总结起来，其实就是一句话：当数据越接近正序时，冒泡排序性能越好。</p><p>冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以相同元素的前后顺序并没有改变，所以冒泡排序是一种<strong>稳定排序算法</strong>。</p><h3 id="1-3-冒泡排序优化"><a href="#1-3-冒泡排序优化" class="headerlink" title="1.3 冒泡排序优化"></a>1.3 冒泡排序优化</h3><p>在上述代码中测试的数据会发现，早在第三趟就已经完成排序，但是还是执行了后面的四五六趟排序。对冒泡排序常见的改进方法是加入<strong>标志性变量exchange</strong>，用于标志某一趟排序过程中是否有数据交换。如果进行<strong>某一趟排序时并没有进行数据交换，则说明所有数据已经有序</strong>，可立即结束排序，避免不必要的比较过程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bubbleSort(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>)&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">list</span>.empty())&#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result = <span class="built_in">list</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; result.size()<span class="number">-1</span>; ++i)&#123;<span class="comment">//外层循环仅标记趟数</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"第"</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">"趟排序:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">/*----------冒泡排序优化代码1-----------*/</span></span><br><span class="line"><span class="keyword">bool</span> bChanged = <span class="literal">false</span>;<span class="comment">//交换标记</span></span><br><span class="line"><span class="comment">/*----------冒泡排序优化代码1-----------*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j &lt; result.size()<span class="number">-1</span>; j++)&#123;<span class="comment">//内层循环进行相邻数据交换</span></span><br><span class="line"><span class="keyword">if</span>(result[j+<span class="number">1</span>] &lt; result[j])&#123;</span><br><span class="line">swap(result[j+<span class="number">1</span>], result[j]);</span><br><span class="line"><span class="comment">/*----------冒泡排序优化代码2-----------*/</span></span><br><span class="line">bChanged = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">/*----------冒泡排序优化代码2-----------*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"排序中:"</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>; s&lt;result.size(); s++)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;result[s]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*----------冒泡排序优化代码3-----------*/</span></span><br><span class="line"><span class="keyword">if</span>(bChanged == <span class="literal">false</span>)<span class="comment">//如果标志为false,说明本轮遍历没有进行数据交换，即说明已经有序</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">/*----------冒泡排序优化代码3-----------*/</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"排序结果:"</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>; s &lt; result.size(); s++)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;result[s]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序前"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.size(); i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; test[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">result = bubbleSort(test);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序后"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; result[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-快速排序"><a href="#2-快速排序" class="headerlink" title="2. 快速排序"></a>2. 快速排序</h2><h3 id="2-1-快速排序算法思想及代码实现"><a href="#2-1-快速排序算法思想及代码实现" class="headerlink" title="2.1 快速排序算法思想及代码实现"></a>2.1 快速排序算法思想及代码实现</h3><p>快速排序也是一种交换排序。快速排序由C. A. R. Hoare在1962年提出。</p><p>它的基本思想是：通过一趟排序将要排序的数据<strong>分割</strong>成独立的两部分：<strong>分割点左边都是比它小的数，右边都是比它大的数</strong>。然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><p>算法步骤：</p><ul><li>选取主元</li><li>小于等于主元的放左边，大于等于主元的放右边</li><li>分别对左右边递归，即重复（1）、（2）步</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">division</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">list</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> base = <span class="built_in">list</span>[left];</span><br><span class="line"><span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line"><span class="keyword">while</span>(left &lt; right &amp;&amp; <span class="built_in">list</span>[right]&gt;=base)<span class="comment">//从序号右端开始向左遍历，直到找到小于base的数</span></span><br><span class="line">right--;</span><br><span class="line"><span class="built_in">list</span>[left] = <span class="built_in">list</span>[right];<span class="comment">//找到比base小的元素，将这个元素放到最左边的位置</span></span><br><span class="line"><span class="keyword">while</span>(left &lt; right &amp;&amp; <span class="built_in">list</span>[left]&lt;=base) <span class="comment">//从序号左端开始向右遍历，直到找到大于base的数</span></span><br><span class="line">left++;</span><br><span class="line"><span class="built_in">list</span>[right] = <span class="built_in">list</span>[left];<span class="comment">//找到比base大的元素，将这个元素放到最右边的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>[left] = base;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"每一轮："</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>.size(); i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">list</span>[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">list</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(left &lt; right)&#123;<span class="comment">//左下标一定小于右下标，否则越界</span></span><br><span class="line"><span class="keyword">int</span> base = division(<span class="built_in">list</span>, left, right);<span class="comment">//对数组进行分割，去除下次分割的基准标号</span></span><br><span class="line">QuickSort(<span class="built_in">list</span>, left, base<span class="number">-1</span>);<span class="comment">//左</span></span><br><span class="line">QuickSort(<span class="built_in">list</span>, base+<span class="number">1</span>, right);<span class="comment">//右</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test(arr, arr + <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序前"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.size(); i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; test[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result = test;</span><br><span class="line"></span><br><span class="line">QuickSort(result, <span class="number">0</span>, result.size() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序后"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; result[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-快速排序算法性能"><a href="#2-2-快速排序算法性能" class="headerlink" title="2.2 快速排序算法性能"></a>2.2 快速排序算法性能</h3><p>时间复杂度上：</p><p>最好的情况，每次我们运行一次分区，我们会把一个数组分为两个几近相等的片段。这个意思就是每次递归调用处理一半大小的数组。则会有关系式：</p><script type="math/tex; mode=display">T(n)=2T(\frac n 2)+O(n)</script><p>解出 $T_{best}(n)=O(nlogn)$。</p><p>最坏的情况，在分割后，两子数组总是拥有各为 1 和 n-1 长度的数组，则递归关系式变为：</p><script type="math/tex; mode=display">T(n)=T(n−1)+O(n)+O(1)=T(n−1)+O(n)</script><p>解出 $T_{worst}(n)=O(n^2)$。</p><p>空间复杂度上：</p><p>快速排序在每次分割的过程中，需要 1 个空间存储基准值。而快速排序的大概需要Nlog2N次的分割处理，所以占用空间也是 Nlog2N 个。</p><p>算法稳定性上：</p><p>在快速排序中，相等元素可能会因为分区而交换顺序，所以它是不稳定的算法。</p><h3 id="2-3-快速排序细节优化"><a href="#2-3-快速排序细节优化" class="headerlink" title="2.3 快速排序细节优化"></a>2.3 快速排序细节优化</h3><p>我们知道主元的大小直接决定快排的效率，因为数组的划分需要依靠主元，理想状态下，给定的主元正好可以把数组分为长度相等的两个子数组，但找到并确定这样的主元还需要耗费额外的时间，如此一来，得不偿失。</p><p>快速排序算法有三种选择主元的方法：</p><ol><li>取序列中的第一个或最后一个元素作为主元<em>（前面实现的就是这种）</em></li><li>取序列中任意一个元素作为主元</li><li>选取左，中，右三个元素的 “中值” 为主元</li></ol><h2 id="3-直接插入排序"><a href="#3-直接插入排序" class="headerlink" title="3. 直接插入排序"></a>3. 直接插入排序</h2><h3 id="3-1-插入排序算法思想及代码实现"><a href="#3-1-插入排序算法思想及代码实现" class="headerlink" title="3.1 插入排序算法思想及代码实现"></a>3.1 插入排序算法思想及代码实现</h3><p>每一趟将一个待排序的记录，按照其关键字的大小插入到有序队列的合适位置里，直到全部插入完成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; insertSort(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>)&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">list</span>.empty())&#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">result = <span class="built_in">list</span>;</span><br><span class="line"><span class="comment">// 第1个数肯定是有序的，从第2个数开始遍历，依次插入有序序列</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line"><span class="comment">// 取出第i个数，和前i-1个数比较后，插入合适位置</span></span><br><span class="line"><span class="keyword">int</span> temp = result[i];</span><br><span class="line"><span class="comment">// 因为前i-1个数都是从小到大的有序序列，所以只要当前比较的数(res[j])比temp大，就把这个数后移一位</span></span><br><span class="line"><span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (j; j &gt;= <span class="number">0</span> &amp;&amp; result[j] &gt; temp; j--)&#123;</span><br><span class="line">result[j + <span class="number">1</span>] = result[j];</span><br><span class="line">&#125;</span><br><span class="line">result[j + <span class="number">1</span>] = temp;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"第"</span>&lt;&lt;i&lt;&lt;<span class="string">"轮:"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; result[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序前"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.size(); i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; test[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">result = insertSort(test);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序后"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; result[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-插入排序算法性能"><a href="#3-2-插入排序算法性能" class="headerlink" title="3.2 插入排序算法性能"></a>3.2 插入排序算法性能</h3><p>那么它的算法复杂度如下（参考<a href="https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F#.E7.AE.97.E6.B3.95.E5.A4.8D.E6.9D.82.E5.BA.A6" target="_blank" rel="noopener">维基百科</a>）：</p><ul><li>时间复杂度<ul><li>最好情况，序列是升序排列，在这种情况下，只需进行 $n-1$ 比较，即 $T_{best}(n)=O(n)$；</li><li>最坏情况，序列是降序排列，那么此时需要进行的比较共有 $\frac 12n(n−1)$ 次，即 $T_{worse}(n)=O(n^2)$；</li><li>平均情况，为 $T_{avg}(n)=O(n^2)$。</li></ul></li><li>空间复杂度<ul><li>由程序很容易得我们在排序过程中，需要一个临时变量存储要插入的值，所以空间复杂度为 S(n)=O(1)。</li></ul></li></ul><p>它的算法稳定性：直接插入排序的过程中，不需要改变相等数值元素的位置，所以它是<strong>稳定的</strong>算法。</p><h2 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4. 希尔排序"></a>4. 希尔排序</h2><h3 id="4-1-希尔排序算法思想及代码实现"><a href="#4-1-希尔排序算法思想及代码实现" class="headerlink" title="4.1 希尔排序算法思想及代码实现"></a>4.1 希尔排序算法思想及代码实现</h3><p>希尔(Shell)排序又称为<strong>缩小增量排序</strong>，它是一种<strong>插入排序</strong>。它<strong>是直接插入排序算法的一种威力加强版</strong>。该方法因DL．Shell于1959年提出而得名。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：（以下摘自<a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">维基百科</a>）</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到<a href="https://zh.wikipedia.org/w/index.php?title=%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">线性排序</a>的效率</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</li></ul><p>希尔排序的<strong>基本思想</strong>是：</p><p>把记录按<strong>步长</strong> gap 分组，对每组记录采用<strong>直接插入排序</strong>方法进行排序。<br>随着<strong>步长逐渐减小</strong>，所分成的组包含的记录越来越多，当步长的值减小到 <strong>1</strong> 时，整个数据合成为一组，构成一组有序记录，则完成排序。</p><p>举例：假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样：</p><p><code>13 14 94 33 82</code><br><code>25 59 94 65 23</code><br><code>45 27 73 25 39</code><br><code>10</code></p><p>然后我们对每列进行排序：</p><p><code>10 14 73 25 23</code><br><code>13 27 94 33 39</code><br><code>25 59 94 65 82</code><br><code>45</code></p><p>将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ].这时10已经移至正确位置了，然后再以3为步长进行排序：</p><p><code>10 14 73</code><br><code>25 23 13</code><br><code>27 94 33</code><br><code>39 25 59</code><br><code>94 65 82</code><br><code>45</code></p><p>排序之后变为：</p><p><code>10 14 13</code><br><code>25 23 33</code><br><code>27 25 59</code><br><code>39 65 73</code><br><code>45 94 82</code><br><code>94</code></p><p>最后以1步长进行排序（此时就是简单的插入排序了）。</p><p>可想而知，步长的选择是希尔排序的重要部分。算法最开始以一定的步长进行排序，然后会继续以更小的步长进行排序，最终算法以步长为 1 进行排序。当步长为 1 时，算法变为直接插入排序，这就保证了数据一定会被全部排序。</p><p>下面以$\frac n{2^i}$作为步长为例进行讲解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ShellSort(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>)&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">result = <span class="built_in">list</span>;</span><br><span class="line"><span class="keyword">int</span> n = result.size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> gap = n &gt;&gt; <span class="number">1</span>; gap &gt; <span class="number">0</span>; gap &gt;&gt;= <span class="number">1</span>)&#123;<span class="comment">//对n进行二分除二处理</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=gap; i&lt;n; i++)&#123;</span><br><span class="line"><span class="keyword">int</span> temp = result[i];<span class="comment">//记录i所在的数</span></span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">for</span>(j = i-gap; j&gt;=<span class="number">0</span> &amp;&amp; result[j]&gt;temp; j -= gap)&#123;<span class="comment">//把相距为gap的i,j所在数字比较，相当于隔行判断</span></span><br><span class="line">result[j+gap] = result[j];</span><br><span class="line">&#125;</span><br><span class="line">result[j+gap] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序前"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.size(); i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; test[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">result = ShellSort(test);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序后"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; result[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-希尔排序算法性能"><a href="#4-2-希尔排序算法性能" class="headerlink" title="4.2 希尔排序算法性能"></a>4.2 希尔排序算法性能</h3><p>那么它的算法复杂度如下（参考<a href="https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F#.E7.AE.97.E6.B3.95.E5.A4.8D.E6.9D.82.E5.BA.A6" target="_blank" rel="noopener">维基百科</a>）：</p><p>步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。</p><p>算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为1进行排序。当步长为1时，算法变为插入排序，这就保证了数据一定会被排序。<br>Donald Shell 最初建议步长选择为N/2并且对步长取半直到步长达到1。虽然这样取可以比O(N2)类的算法（插入排序）更好，但这样仍然有减少平均时间和最差时间的余地。可能希尔排序最重要的地方在于当用较小步长排序后，以前用的较大步长仍然是有序的。比如，如果一个数列以步长5进行了排序然后再以步长3进行排序，那么该数列不仅是以步长3有序，而且是以步长5有序。如果不是这样，那么算法在迭代过程中会打乱以前的顺序，那就</p><p>不会以如此短的时间完成排序了。</p><div class="table-container"><table><thead><tr><th style="text-align:center">步长序列</th><th style="text-align:center">最坏情况下复杂度</th></tr></thead><tbody><tr><td style="text-align:center">$\frac n{2^i}$</td><td style="text-align:center">$O(n^2)$</td></tr><tr><td style="text-align:center">$2^i-1$</td><td style="text-align:center">$O(n^{\frac 32})$</td></tr><tr><td style="text-align:center">$2^i3^i$</td><td style="text-align:center">$O(nlog^2n)$</td></tr></tbody></table></div><p>已知的最好步长序列是由Sedgewick提出的(1, 5, 19, 41, 109,…)，该序列的项来自$9<em>4^i-9</em>2^i$和$2^{i+2}*(2^{i+2}-3)+1$这两个算式。这项研究也表明“比较在希尔排序中是最主要的操作，而不是交换。”用这样步长序列的希尔排序比插入排序和堆排序都要快，甚至在小数组中比快速排序还快，但是在涉及大量数据时希尔排序还是比快速排序慢。</p><p>它的算法稳定性：希尔排序中相等数据可能会交换位置，所以希尔排序是<strong>不稳定</strong>的算法。</p><h3 id="4-3-希尔排序和直接插入排序比较"><a href="#4-3-希尔排序和直接插入排序比较" class="headerlink" title="4.3 希尔排序和直接插入排序比较"></a>4.3 希尔排序和直接插入排序比较</h3><p>直接插入排序是<strong>稳定的</strong>；而希尔排序是<strong>不稳定</strong>的。</p><p>直接插入排序更适合于原始记录基本<strong>有序</strong>的集合。</p><p>希尔排序的比较次数和移动次数都要比直接插入排序少，当N越大时，效果越明显。   </p><p>在希尔排序中，增量序列gap的取法必须满足：<strong>最后一个步长必须是1</strong>。</p><p>直接插入排序也<strong>适用于链式存储结构</strong>；希尔排序<strong>不适用于链式结构</strong>。</p><h2 id="5-简单选择排序"><a href="#5-简单选择排序" class="headerlink" title="5. 简单选择排序"></a>5. 简单选择排序</h2><h3 id="5-1-简单选择排序算法思想及代码实现"><a href="#5-1-简单选择排序算法思想及代码实现" class="headerlink" title="5.1 简单选择排序算法思想及代码实现"></a>5.1 简单选择排序算法思想及代码实现</h3><p>简单选择排序是一种<strong>选择排序</strong>。</p><p><strong>选择排序</strong>：每趟从待排序的记录中选出关键字最小的记录，顺序放在已排序的记录序列末尾，直到全部排序结束为止。</p><p>简单排序很简单，它的大致处理流程为：</p><ul><li>从待排序序列中，找到关键字最小的元素；</li><li>如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；</li><li>从余下的 N - 1 个元素中，找出关键字最小的元素，重复(1)、(2)步，直到排序结束。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; SelectSort(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>)&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">result = <span class="built_in">list</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;result.size(); i++)&#123;</span><br><span class="line"><span class="keyword">int</span> index = i;<span class="comment">//标记第一个位置</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;result.size(); j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(result[index] &gt; result[j])</span><br><span class="line">index = j;<span class="comment">//如果比index位置上的数字小，就标记该数字</span></span><br><span class="line">&#125;</span><br><span class="line">swap(result[i], result[index]);<span class="comment">//循环结束后把标记的最小数字所在位置index和i位置交换</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"第"</span> &lt;&lt; i + <span class="number">1</span>&lt;&lt; <span class="string">"趟:\t"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; result[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序前"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.size(); i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; test[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">result = SelectSort(test);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序后"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; result[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-简单选择排序算法性能"><a href="#5-2-简单选择排序算法性能" class="headerlink" title="5.2 简单选择排序算法性能"></a>5.2 简单选择排序算法性能</h3><p>那么它的算法复杂度如下：</p><ul><li><p>时间复杂度</p><p>简单选择排序的比较次数与序列的初始排序无关。 假设待排序的序列有 N 个元素，则比较次数总是$\frac {N (N - 1) }2$。</p><p>简单排序的时间复杂度为 $O(N^2)$。</p></li><li><p>空间复杂度</p><ul><li>由程序很容易得我们在排序过程中，需要一个临时变量存储要插入的值，所以空间复杂度为 S(n)=O(1)。</li></ul></li></ul><h2 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6. 堆排序"></a>6. 堆排序</h2><h3 id="6-1-堆排序算法思想及代码实现"><a href="#6-1-堆排序算法思想及代码实现" class="headerlink" title="6.1 堆排序算法思想及代码实现"></a>6.1 堆排序算法思想及代码实现</h3><p>堆排序是利用堆的性质进行的一种选择排序。下面先讨论一下堆。</p><p>堆实际上是一棵完全二叉树，其满足性质：任何一结点大于等于或者小于等于其左右子树结点。</p><p>堆分为大顶堆和小顶堆，满足 “任何一结点大于等于其左右子树结点” 的称为大顶堆，满足 “任何一结点小于等于其左右子树结点” 的称为小顶堆。由上述性质可知：大顶堆的堆顶肯定是最大的，小顶堆的堆顶是最小的。</p><p>堆排序可以归纳出两个操作：</p><ul><li>根据初始数组去<strong>构造初始堆</strong>（构建一个完全二叉树，保证所有的父结点都比它的孩子结点数值大）。</li><li>每次<strong>交换第一个和最后一个元素，输出最后一个元素</strong>（最大值），然后把剩下元素<strong>重新调整</strong>为大根堆。</li></ul><p>下面举个例子（资源来自<a href="http://www.cnblogs.com/dolphin0520/archive/2011/10/06/2199741.html" target="_blank" rel="noopener">堆排序 - 海子</a>）来说明堆排序的过程（以升序为例）：</p><p>（1）<br><img src="https://61mon.com/images/illustrations/Sort/3.jpg" alt="img"></p><p>给定整型数组：{16, 7, 3, 20, 17, 8}，根据该数组 “构建” 完全二叉树（并不是真的写代码去构建，只是把数组看成完全二叉树去操作）。</p><p>程序从最后一个非叶子结点开始，即 3。判断其左右孩子：8，8 比 3 大，把 8 调整上去。</p><p>（2）<br><img src="https://61mon.com/images/illustrations/Sort/4.jpg" alt="img"></p><p>3 结点下无孩子，判断结束。</p><p>继续往前一步，至 7 结点，判断其左右孩子：20 和 17，20 是最大的，将其调整上去。</p><p>（3）<br><img src="https://61mon.com/images/illustrations/Sort/5.jpg" alt="img"></p><p>7 结点下无孩子，判断结束。</p><p>继续往前一步，至 16 结点，判断其左右孩子：20 和 8，20 是最大的，将其调整上去。</p><p>（4）<br><img src="https://61mon.com/images/illustrations/Sort/6.jpg" alt="img"></p><p>判断 16 结点下左右孩子：7 和 17，17 是最大的，将其调整上去。</p><p>（5）<br><img src="https://61mon.com/images/illustrations/Sort/7.jpg" alt="img"></p><p>16 结点下无孩子，判断结束。</p><p>遍历已至头部，结束。</p><p>（6）至此数组已经满足大顶堆的性质，接下来的操作就很简单了。<br><img src="https://61mon.com/images/illustrations/Sort/8.jpg" alt="img"></p><p>看完上面所述的流程你至少有两个疑问：</p><ul><li>如何确定最后一个非叶子结点？</li></ul><p>其实这是有一个公式的，设二叉树结点总数为 n，则最后一个非叶子结点是第$\frac n2$个。</p><ul><li>数组当中如何确定当前结点的左右孩子位置？</li></ul><p>设当前结点下标是 i，则其左孩子的下标是 2i，右孩子的下标是 2i+1。请注意：这是建立在数组下标从 1 开始的情况。若数组下标从 0 开始，则其左右孩子下标还各需多加一个 1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">list</span>, <span class="keyword">int</span> start, <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> parent = start;<span class="comment">//父节点</span></span><br><span class="line"><span class="keyword">int</span> child = <span class="number">2</span> * parent + <span class="number">1</span>;<span class="comment">// 先获得左孩子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (child &lt;= length)&#123;</span><br><span class="line"><span class="comment">// 如果有右子节点，并且右子节点的值大于左子节点，则选取右子节点，否则选取左节点</span></span><br><span class="line"><span class="keyword">if</span> (child + <span class="number">1</span> &lt;= length &amp;&amp; <span class="built_in">list</span>[child] &lt; <span class="built_in">list</span>[child + <span class="number">1</span>])&#123;</span><br><span class="line">child++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果父节点大于孩子节点则代表调整完毕，直接跳出函数</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">list</span>[parent] &gt; <span class="built_in">list</span>[child])&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123; <span class="comment">//否则交换父子内容再继续子节点和孙节点比较</span></span><br><span class="line">swap(<span class="built_in">list</span>[parent], <span class="built_in">list</span>[child]);</span><br><span class="line">parent = child;<span class="comment">//父更新为子节点位置</span></span><br><span class="line">child = parent*<span class="number">2</span>+<span class="number">1</span>;<span class="comment">//子节点更新为孙节点位置</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; HeadSort(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> length = <span class="built_in">list</span>.size();</span><br><span class="line"><span class="comment">// 循环建立初始堆，i从最后一个父节点开始</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = length/<span class="number">2</span><span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">HeapAdjust(<span class="built_in">list</span>, i, length<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>.size(); i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">list</span>[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// 进行n-1次循环，完成排序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line"><span class="comment">// 最后一个元素和第一元素进行交换</span></span><br><span class="line">swap(<span class="built_in">list</span>[<span class="number">0</span>], <span class="built_in">list</span>[i]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 筛选 R[0] 结点，得到i-1个结点的堆</span></span><br><span class="line">HeapAdjust(<span class="built_in">list</span>, <span class="number">0</span>, i<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"第"</span> &lt;&lt; length - i &lt;&lt; <span class="string">"趟排序:"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>.size(); i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">list</span>[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序前:"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.size(); i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; test[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">result = HeadSort(test);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序后:"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; result[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-堆排序算法性能"><a href="#6-2-堆排序算法性能" class="headerlink" title="6.2 堆排序算法性能"></a>6.2 堆排序算法性能</h3><p>堆的存储表示是<strong>顺序的</strong>。因为堆所对应的二叉树为完全二叉树，而完全二叉树通常采用顺序存储方式。</p><p>当想得到一个序列中第<strong>k</strong>个最小的元素之前的部分排序序列，最好采用堆排序。</p><p>时间复杂度为 $O(nlogn)$，证明如下。</p><p>首先计算建堆的时间，也就是下面的代码，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环建立初始堆，i从最后一个父节点开始</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = length/<span class="number">2</span><span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">HeapAdjust(<span class="built_in">list</span>, i, length<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>n 个结点，从第 0 层至第 $log_2n$ 层。对于第$i$层的$2^i$个点如果需要往下走$log_2n−i$步，那么把走的所有步相加得， </p><script type="math/tex; mode=display">T(n) = \sum _{i=0}^{i=log_2n}{2^i(log_2n-i)}= 2n-log_2n-2<2n=O(n)</script><p>接下来就是排序的时间，即下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line"><span class="comment">// 最后一个元素和第一元素进行交换</span></span><br><span class="line">swap(<span class="built_in">list</span>[<span class="number">0</span>], <span class="built_in">list</span>[i]);</span><br><span class="line"><span class="comment">// 筛选 R[0] 结点，得到i-1个结点的堆</span></span><br><span class="line">HeapAdjust(<span class="built_in">list</span>, <span class="number">0</span>, i<span class="number">-1</span>);</span><br></pre></td></tr></table></figure><p>HeapAdjust() 耗时$logn$，共$n$次，故排序时间为$O(nlogn)$。</p><p>综上所述，堆排序时间复杂度为$T(n)=O(n)+O(nlogn)=O(nlogn)$。</p><p>算法稳定度：</p><p>堆排序是一种<strong>不稳定</strong>的排序方法。</p><p>因为在堆的调整过程中，关键字进行比较和交换所走的是该结点到叶子结点的一条路径，因此对于相同的关键字就可能出现排在后面的关键字被交换到前面来的情况。</p><h2 id="7-归并排序"><a href="#7-归并排序" class="headerlink" title="7. 归并排序"></a>7. 归并排序</h2><h3 id="7-1-归并排序算法思想及代码实现"><a href="#7-1-归并排序算法思想及代码实现" class="headerlink" title="7.1 归并排序算法思想及代码实现"></a>7.1 归并排序算法思想及代码实现</h3><p>归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用<strong>分治法（Divide and Conquer）</strong>的一个非常典型的应用。</p><p>将待排序序列R[0…n-1]看成是n个长度为1的有序序列，将相邻的有序表成对归并，得到n/2个长度为2的有序表；将这些有序序列再次归并，得到n/4个长度为4的有序序列；如此反复进行下去，最后得到一个长度为n的有序序列。</p><p>综上可知：</p><p>归并排序其实要做两件事：</p><p>（1）“分解”——将序列每次<strong>折半划分</strong>。</p><p>（2）“合并”——将划分后的序列段<strong>两两合并后排序</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;input, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=left;</span><br><span class="line"><span class="keyword">int</span> j=mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=right)&#123;</span><br><span class="line"><span class="keyword">if</span>(input[i]&lt;=input[j])&#123;</span><br><span class="line">temp[k++] = input[i++];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">temp[k++] = input[j++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid)</span><br><span class="line">temp[k++]=input[i++];</span><br><span class="line"><span class="keyword">while</span>(j&lt;=right)</span><br><span class="line">temp[k++]=input[j++];</span><br><span class="line">k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">input[left++] = temp[k++];</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;input[left<span class="number">-1</span>]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;input, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">MergeSort(input, left, mid, temp);</span><br><span class="line">MergeSort(input, mid+<span class="number">1</span>, right, temp);</span><br><span class="line">Merge(input, left, mid ,right, temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序前:"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.size(); i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; test[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result = test;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp(result.size());<span class="comment">// 在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间</span></span><br><span class="line">MergeSort(result, <span class="number">0</span>, result.size()<span class="number">-1</span>, temp);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序后:"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; result[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-归并排序算法性能"><a href="#7-2-归并排序算法性能" class="headerlink" title="7.2 归并排序算法性能"></a>7.2 归并排序算法性能</h3><p>归并排序的时间复杂度分析：MergeSort()函数用于数组划分，Merge()函数用于合并。</p><ul><li>合并函数Merge()的时间复杂度为$O(n)$，因为代码中有2个长度为n的循环（非嵌套）</li><li>划分函数MergeSort()中，简单的分析一下元素长度为n的归并排序所消耗的时间为T(n)：调用MergeSort()函数划分两部分，那每一小部分所花销的时间则是$T[\frac n2]$</li></ul><p>最后两部分合并:（用迭代法进行推导）</p><script type="math/tex; mode=display">\begin{align}T[n]& = 2T[\frac n2]+O(n)\\令：n=\frac n2\quad &=2(2T[\frac n4]+\frac n2)+n\\&=2^2T[\frac n{2^2}]+2n\\令：n=\frac n{2^2}\quad&=2^2(2T[\frac n{2^3}]+\frac n{2^2})+2n\\&=2^3T[\frac n{2^3}]+3n\\&……\\令：n=\frac n{2^{m-1}}\quad&=2^mT[1]+mn\\经过m次递归后，&当最后平分的不能再平分\\到最后得到T[1]时，&说明这个公式已经迭代完了（T[1]是常量了）\\得到：T[\frac n{2^m}]=T[1]\quad &==>\ n=2^m\quad ==>\ m=logn\\T[n]&=2^mT[1]+mn\qquad 其中m=logn；\\T[n]&=2^{logn}T[1]+nlogn\\&=nT[1]+nlogn\\&=n+nlogn\end{align}</script><p>综上所述：归并排序时间复杂度为：$O(nlogn)$。</p><p>因为不管元素在什么情况下都要做这些步骤，所以花销的时间是不变的，所以该算法的最优时间复杂度和最差时间复杂度及平均时间复杂度都是一样的为：$O(nlogn)$。</p><p>归并排序的空间复杂度：</p><p>归并的空间复杂度就是那个临时的数组和递归时压入栈的数据占用的空间：n+logn；所以空间复杂度为: O(n)</p><p>归并排序的算法稳定度：</p><p>在归并排序中，相等的元素的顺序不会改变，所以它是<strong>稳定的</strong>算法。</p><h2 id="8-基数排序"><a href="#8-基数排序" class="headerlink" title="8. 基数排序"></a>8. 基数排序</h2><h3 id="8-1-基数排序算法思想及代码实现"><a href="#8-1-基数排序算法思想及代码实现" class="headerlink" title="8.1 基数排序算法思想及代码实现"></a>8.1 基数排序算法思想及代码实现</h3><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p><p>算法步骤：</p><ul><li>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。</li><li>从最低位开始，依次进行一次排序。</li><li>这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</li></ul><p>基数排序的方式可以采用 LSD（Least significant digital）或 MSD（Most significant digital），LSD 的排序方式由键值的最右边开始，而 MSD 则相反，由键值的最左边开始。</p><p>不妨通过一个具体的实例来展示一下基数排序是如何进行的。 设有一个初始序列为: R {50, 123, 543, 187, 49, 30, 0, 2, 11, 100}。</p><p>我们知道，任何一个阿拉伯数，它的各个位数上的基数都是以 0~9 来表示的，所以我们不妨把 0~9 视为 10 个桶。</p><p>我们先根据序列的个位数的数字来进行分类，将其分到指定的桶中。例如：R[0] = 50，个位数上是 0，将这个数存入编号为 0 的桶中。</p><p><img src="https://61mon.com/images/illustrations/Sort/10.png" alt="img"></p><p>分类后，我们在从各个桶中，将这些数按照从编号 0 到编号 9 的顺序依次将所有数取出来。这时，得到的序列就是个位数上呈递增趋势的序列。</p><p>按照个位数排序： {50, 30, 0, 100, 11, 2, 123, 543, 187, 49}。</p><p>接下来，可以对十位数、百位数也按照这种方法进行排序，最后就能得到排序完成的序列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求出数组中最大数的位数的函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxBit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input)</span></span>&#123;</span><br><span class="line"><span class="comment">// 数组最大值</span></span><br><span class="line"><span class="keyword">int</span> max_data = input[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; input.size(); i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (input[i] &gt; max_data)&#123;</span><br><span class="line">max_data = input[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"max_data:"</span>&lt;&lt;max_data&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// 数组最大值的位数</span></span><br><span class="line"><span class="keyword">int</span> bits_num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (max_data)&#123;</span><br><span class="line">bits_num++;</span><br><span class="line">max_data /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"bits_num:"</span>&lt;&lt;bits_num&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> bits_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; RadixSort(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">int</span> n)&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bucket(n);<span class="comment">//存储排序过程中的数据</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; count(<span class="number">10</span>);<span class="comment">//位计数器，从第0个元素到第9个元素依次用来记录当前比较位是0的有多少个...是9的有多少个数</span></span><br><span class="line"><span class="keyword">int</span> bits_num = MaxBit(input); <span class="comment">//求出数组中最大数的位数的函数</span></span><br><span class="line"><span class="keyword">int</span> radix = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 从低位往高位循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">1</span>; d &lt;= bits_num; d++)&#123; </span><br><span class="line"><span class="comment">// 计数器清0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">count[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 统计各个桶中的个数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="keyword">int</span> k=(input[i]/radix)%<span class="number">10</span>;<span class="comment">//取每个数字的末尾</span></span><br><span class="line">count[k]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"before:"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;count[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"after:   "</span>;</span><br><span class="line"><span class="comment">//索引重分配</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">count[i] += count[i - <span class="number">1</span>];<span class="comment">//count[i]表示第i个桶的右边界索引</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;count[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//放入临时数组，从右到左扫描，保证排序稳定性</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line"><span class="keyword">int</span> k = (input[i]/radix)%<span class="number">10</span>;</span><br><span class="line">bucket[count[k] - <span class="number">1</span>] = input[i];</span><br><span class="line">count[k]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"input:"</span>;</span><br><span class="line"><span class="comment">// 临时数组复制到 input 中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">input[i] = bucket[i];</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;input[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">radix *= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> input;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">50</span>, <span class="number">123</span>, <span class="number">543</span>, <span class="number">187</span>, <span class="number">49</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">100</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序前:"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.size(); i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; test[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result = test;</span><br><span class="line">result = RadixSort(result, result.size());</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序后:"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; result[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-基数排序算法性能"><a href="#8-2-基数排序算法性能" class="headerlink" title="8.2 基数排序算法性能"></a>8.2 基数排序算法性能</h3><p>基数排序的时间复杂度是$O(k⋅n)$，其中$n$是排序元素个数，$k$是最大的数字位数。</p><p>空间复杂度是使用了两个临时的数组：10 + length；所以空间复杂度：$O(n)$</p><p>在基数排序过程中，每次都是将当前位数上相同数值的元素统一“装桶”，并不需要交换位置。所以基数排序是<strong>稳定</strong>的算法。</p><blockquote><p>本文参考整理自：</p><p><a href="http://cuijiahua.com/blog/2018/01/alogrithm_9.html" target="_blank" rel="noopener">http://cuijiahua.com/blog/2018/01/alogrithm_9.html</a></p><p><a href="https://61mon.com/index.php/archives/193/" target="_blank" rel="noopener">https://61mon.com/index.php/archives/193/</a></p><p><a href="http://www.cnblogs.com/jingmoxukong/p/4311237.html" target="_blank" rel="noopener">http://www.cnblogs.com/jingmoxukong/p/4311237.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;排序算法&quot;&gt;&lt;a href=&quot;#排序算法&quot; class=&quot;headerlink&quot; title=&quot;排序算法&quot;&gt;&lt;/a&gt;排序算法&lt;/h1&gt;&lt;p&gt;之前也有总结排序部分，但是总是忘记，这段时间在整理算法笔记，所以借机再整理一份。&lt;br&gt;主要整理的是八大内部排序，分析代码，
      
    
    </summary>
    
      <category term="学习" scheme="https://hushhw.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法笔记" scheme="https://hushhw.cn/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
      <category term="排序" scheme="https://hushhw.cn/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>CTGUOJ刷题目录</title>
    <link href="https://hushhw.cn/2018/02/12/10CTGUOJ/"/>
    <id>https://hushhw.cn/2018/02/12/10CTGUOJ/</id>
    <published>2018-02-11T20:12:34.000Z</published>
    <updated>2018-02-11T20:15:06.964Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CTGUOJ"><a href="#CTGUOJ" class="headerlink" title="CTGUOJ"></a>CTGUOJ</h1><p>Record my code in CTGUOJ</p><p>所有代码都在：<a href="https://github.com/hushhw/CTGUOJ" target="_blank" rel="noopener">https://github.com/hushhw/CTGUOJ</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CTGUOJ&quot;&gt;&lt;a href=&quot;#CTGUOJ&quot; class=&quot;headerlink&quot; title=&quot;CTGUOJ&quot;&gt;&lt;/a&gt;CTGUOJ&lt;/h1&gt;&lt;p&gt;Record my code in CTGUOJ&lt;/p&gt;
&lt;p&gt;所有代码都在：&lt;a href=&quot;https:
      
    
    </summary>
    
      <category term="学习" scheme="https://hushhw.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="OJ刷题" scheme="https://hushhw.cn/categories/%E5%AD%A6%E4%B9%A0/OJ%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="OJ" scheme="https://hushhw.cn/tags/OJ/"/>
    
      <category term="刷题" scheme="https://hushhw.cn/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
</feed>
