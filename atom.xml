<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hushhw&#39;s blog</title>
  
  <subtitle>身经百战见得多了</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hushhw.cn/"/>
  <updated>2018-04-09T14:11:37.205Z</updated>
  <id>https://hushhw.cn/</id>
  
  <author>
    <name>hushhw</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>写在蓝桥杯省赛后</title>
    <link href="https://hushhw.cn/2018/04/09/19lanqiaobei/"/>
    <id>https://hushhw.cn/2018/04/09/19lanqiaobei/</id>
    <published>2018-04-09T13:19:53.000Z</published>
    <updated>2018-04-09T14:11:37.205Z</updated>
    
    <content type="html"><![CDATA[<p>前天是我开通GitHub一周年，一年里从开始不会使用到后来用来存我的编程代码，到后来学习git把本地的Cocos、Qt工程传上去，之后利用hexo框架搭了这个博客。一年过得很快，我也在这个社区学到了很多，见识到了更大的世界。<br><img src="https://img-blog.csdn.net/20180409213905304?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1c2hodw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="github"></p><p>上图是昨天截下来的一年的贡献图，最密集的那一段是刚刚过去的寒假，几乎每一天都有很认真的把自己当天做的算法题传到GitHub，靠这个图来鼓励自己加油下去，至少可以感动自己吧。</p><p>上了大学之后，爸爸就开始跟不上我了，他不知道我在学些什么，他不知道我可能和他一样迷茫以后要做什么，但是他总会跟我说一定要把路走对，多问问别人总不会错的。对于他的教育，我总是用敷衍回应，因为我非常自信自己走的路是对的，我走的是我喜欢的路，怎么会不对呢？大学不就是做自己喜欢做的事吗？</p><p>现在是大三下，我大概在大二结束的暑假才想清楚我应该走的路。</p><p>那个暑假应班主任的邀请，给大一的学弟学妹做Cocos引擎培训，用两个星期的时间教他们引擎的基本使用和做出一个小游戏来，我们专业这个暑假培训是个传统，一代传一代，所以到我教他们的时候已经过去一年了，C++和Cocos2d-x该忘的都忘得差不多了，所以那两个星期基本上都是白天教晚上学习，整理好明天要讲的内容和笔记代码，大学我应该从来都没有这样逼过自己，也没有这样感受编程给我带来的快乐。</p><p>从那个暑假开始，我才算真正的是个计算机专业的学生吧，开始认真的刷OJ的题，看算法书，别人大一就开始做的事情，我大三才开始做，毫无意外的大三上的校赛落榜，没办法证明自己真的是一件很难受的事情，之后每周都会参与学校的刷题比赛，默默地对比自己和别人的差距，别人开始准备考研的寒假，我花了所有时间去做算法，这个学期一边准备考研，每天还会留晚上的时间来刷题。</p><p>蓝桥杯如期而至，第一次参加这个别人眼里很水的比赛，对我而言这是一次证明自己的机会吧，只是是给自己看的，可是当天又给我开了个玩笑，我用的机器和系统时间相差五分钟，我以为还有五分钟的时候实际上已经结束了，所以我戏剧性的最后一题没有交上去，考完出来就跟班主任诉苦，感觉自己应该是没希望了。</p><p>之间这段时间的学习状态不太好，但是我不会放下算法的学习，慢慢地调整，每周还是会去牛客网看看有没有可以打的比赛，还是会多整理笔记，我喜欢这种有目标的感觉。</p><p>今天中午趴在自习室午休醒来，班主任的消息：上了，可以国赛。</p><p>北京见。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前天是我开通GitHub一周年，一年里从开始不会使用到后来用来存我的编程代码，到后来学习git把本地的Cocos、Qt工程传上去，之后利用hexo框架搭了这个博客。一年过得很快，我也在这个社区学到了很多，见识到了更大的世界。&lt;br&gt;&lt;img src=&quot;https://img
      
    
    </summary>
    
      <category term="随笔" scheme="https://hushhw.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://hushhw.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>01分数规划</title>
    <link href="https://hushhw.cn/2018/04/07/18fenshuguihua/"/>
    <id>https://hushhw.cn/2018/04/07/18fenshuguihua/</id>
    <published>2018-04-07T08:51:42.000Z</published>
    <updated>2018-04-09T12:42:30.425Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>链接：<a href="https://www.nowcoder.com/acm/contest/93/I" target="_blank" rel="noopener">https://www.nowcoder.com/acm/contest/93/I</a><br>来源：牛客网</p><p>时间限制：C/C++ 5秒，其他语言10秒<br>空间限制：C/C++ 262144K，其他语言524288K<br>64bit IO Format: %lld</p><p>题目描述<br>wyh学长现在手里有n个物品，这n个物品的重量和价值都告诉你，然后现在让你从中选取k个，问你在所有可能选取的方案中，最大的单位价值为多少（单位价值为选取的k个物品的总价值和总重量的比值）</p><p>输入描述:<br>输入第一行一个整数T(1&lt;=T&lt;=10)<br>接下来有T组测试数据，对于每组测试数据，第一行输入两个数n和k(1&lt;=k&lt;=n&lt;=100000)<br>接下来有n行，每行两个是a和b，代表这个物品的重量和价值</p><p>输出描述:<br>对于每组测试数据，输出对应答案，结果保留两位小数</p><p>示例1<br>输入<br>1<br>3 2<br>2 2<br>5 3<br>2 1</p><p>输出<br>0.75</p><p>说明<br>对于样例来说，我们选择第一个物品和第三个物品，达到最优目的</p></blockquote><p>做法:<br>二分，对于每一个答案C，有 s[i] = w[i]-c*v[i]<br>排序，取最大前k个，如果大于等于0则可行，否则不可行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> n,k; <span class="comment">//n件物品取k件</span></span><br><span class="line"><span class="keyword">int</span> wi[maxn],vi[maxn];<span class="comment">//物品的重量和价值</span></span><br><span class="line"><span class="keyword">double</span> y[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">y[i]=vi[i]-x*wi[i];</span><br><span class="line">sort(y,y+n);</span><br><span class="line"><span class="keyword">double</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++)&#123;</span><br><span class="line">sum += y[n-i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum&gt;=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;wi[i],&amp;vi[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> left=<span class="number">0</span>, right=maxn;</span><br><span class="line"><span class="keyword">while</span>(right-left&gt;<span class="number">1e-6</span>)&#123;</span><br><span class="line"><span class="keyword">double</span> mid = (right+left)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(cmp(mid)) left=mid;</span><br><span class="line"><span class="keyword">else</span> right = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.nowcoder.com/acm/contest/93/I&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.nowcoder.com/acm/contest/9
      
    
    </summary>
    
      <category term="学习" scheme="https://hushhw.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法笔记" scheme="https://hushhw.cn/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
      <category term="01分数规划" scheme="https://hushhw.cn/tags/01%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>树状数组和归并排序求逆序数</title>
    <link href="https://hushhw.cn/2018/02/28/17%E9%80%86%E5%BA%8F%E6%95%B0/"/>
    <id>https://hushhw.cn/2018/02/28/17逆序数/</id>
    <published>2018-02-28T11:38:26.000Z</published>
    <updated>2018-02-28T11:40:02.273Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树状数组和归并排序求逆序数"><a href="#树状数组和归并排序求逆序数" class="headerlink" title="树状数组和归并排序求逆序数"></a>树状数组和归并排序求逆序数</h1><h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><p>树状数组，具体的说是 离散化+树状数组。</p><p>算法的大体流程就是：</p><ol><li>先对输入的数组离散化，使得各个元素比较接近，而不是离散的</li><li>接着，运用树状数组的标准操作来累计数组的逆序数。</li></ol><p>算法详细解释：</p><ol><li>解释为什么要有离散的这么一个过程？</li></ol><p>刚开始以为999.999.999这么一个数字，对于int存储类型来说是足够了。还有只有500000个数字，何必要离散化呢？刚开始一直想不通，后来明白了，后面在运用树状数组操作的时候，用到的树状数组C[i]是建立在一个有点像位存储的数组的基础之上的，不是单纯的建立在输入数组之上。</p><p>比如输入一个9 1 0 5 4，那么C[i]树状数组的建立是在，</p><p>​    下标 0 1 2 3 4 5 6 7 8 9</p><p>​    数组 1 1 0 0 1 1 0 0 0 1</p><p>现在由于999999999这个数字相对于500000这个数字来说是很大的，所以如果用数组位存储的话，那么需要999999999的空间来存储输入的数据。这样是很浪费空间的，题目也是不允许的，所以这里想通过离散化操作，使得离散化的结果可以更加的密集。</p><ol><li>怎么对这个输入的数组进行离散操作？</li></ol><p>离散化是一种常用的技巧，有时数据范围太大，可以用来放缩到我们能处理的范围；因为其中需排序的数的范围0—-999 999 999；显然数组不肯能这么大；而N的最大范围是500 000；故给出的数一定可以与1.。。。N建立一个一一映射；</p><p>   ①当然用map可以建立，效率可能低点；</p><p>   ②这里用一个结构体</p><p>   struct Node</p><p>   {</p><p>​      int v,ord;</p><p>   }p[510000];和一个数组a[510000];</p><p>   其中v就是原输入的值，ord是下标；然后对结构体按v从小到大排序；此时，v和结构体的下标就是一个一一对应关系，而且满足原来的大小关系；</p><p>   for(i=1;i&lt;=N;i++) a[p[i].ord]=i;</p><p>然后a数组就存储了原来所有的大小信息；比如 9 1 0 5 4 ———- 离散后aa数组就是 5 2 1 4 3；具体的过程可以自己用笔写写就好了。</p><ol><li>离散之后，怎么使用离散后的结果数组来进行树状数组操作，计算出逆序数？</li></ol><p>如果数据不是很大， 可以一个个插入到树状数组中，每插入一个数， 统计比他小的数的个数，对应的逆序为 i- getsum( aa[i] )，其中 i 为当前已经插入的数的个数，getsum( aa[i] ）为比 aa[i] 小的数的个数，i- sum( aa[i] ) 即比 aa[i] 大的个数， 即逆序的个数。</p><p>但如果数据比较大，就必须采用离散化方法。</p><p>假设输入的数组是9 1 0 5 4， 离散后的结果aa[] = {5,2,1,4,3};</p><p>在离散结果中间结果的基础上，那么其计算逆序数的过程是这么一个过程。</p><ol><li>输入5，   调用upDate(5, 1),把第5位设置为1</li></ol><p>1 2 3 4 5</p><p>0 0 0 0 1</p><p>计算1-5上比5小的数字存在么？ 这里用到了树状数组的getSum（5） = 1操作，现在用输入的下标1 - getSum(5) = 0 就可以得到对于5的逆序数为0。</p><ol><li>输入2， 调用upDate(2, 1),把第2位设置为1</li></ol><p>1 2 3 4 5</p><p>0 1 0 0 1</p><p>计算1-2上比2小的数字存在么？ 这里用到了树状数组的getSum（2） = 1操作，现在用输入的下标2 - getSum(2) = 1 就可以得到对于2的逆序数为1。</p><ol><li>输入1， 调用upDate(1, 1),把第1位设置为1</li></ol><p>1 2 3 4 5</p><p>1 1 0 0 1</p><p>计算1-1上比1小的数字存在么？ 这里用到了树状数组的getSum（1） = 1操作，现在用输入的下标 3 - getSum(1) = 2 就可以得到对于1的逆序数为2。</p><ol><li>输入4， 调用upDate(4, 1),把第5位设置为1</li></ol><p>1 2 3 4 5</p><p>1 1 0 1 1</p><p>计算1-4上比4小的数字存在么？ 这里用到了树状数组的getSum（4） = 3操作，现在用输入的下标4 - getSum(4) = 1 就可以得到对于4的逆序数为1。</p><ol><li>输入3， 调用upDate(3, 1),把第3位设置为1</li></ol><p>1 2 3 4 5</p><p>1 1 1 1 1</p><p>计算1-3上比3小的数字存在么？ 这里用到了树状数组的getSum（3） = 3操作，现在用输入的下标5 - getSum(3) = 2 就可以得到对于3的逆序数为2。</p><ol><li>0+1+2+1+2 = 6 这就是最后的逆序数</li></ol><p>分析一下时间复杂度，首先用到快速排序，时间复杂度为O(NlogN),</p><p>后面是循环插入每一个数字，每次插入一个数字，分别调用一次upData()和getSum()</p><p>外循环N, upData()和getSum()时间O(logN) =&gt; 时间复杂度还是O(NlogN).</p><p>最后总的还是O(NlogN).</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">500005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> aa[maxn];<span class="comment">//离散后的数组</span></span><br><span class="line"><span class="keyword">int</span> c[maxn];<span class="comment">//树状数组</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> v;</span><br><span class="line"><span class="keyword">int</span> order;</span><br><span class="line">&#125;in[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&amp;(-x);</span><br><span class="line"><span class="comment">//求出2^p(其中p: x 的二进制表示数中， 右向左数第一个1的位置)</span></span><br><span class="line"><span class="comment">//如6的二进制表示为110，向左数第零个为0，第一个为1，则p=1，故Lowbit(6) = 2^1 = 2。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node a, Node b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.v&lt;b.v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=t; i&lt;=n; i+=lowbit(i))</span><br><span class="line">c[i]+=value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=x; i&gt;=<span class="number">1</span>; i-=lowbit(i))</span><br><span class="line">temp+=c[i];</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)==<span class="number">1</span> &amp;&amp; n)&#123;</span><br><span class="line"><span class="comment">//离散化</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;in[i].v);</span><br><span class="line">in[i].order=i;</span><br><span class="line">&#125;</span><br><span class="line">sort(in+<span class="number">1</span>, in+n+<span class="number">1</span>, cmp);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">aa[in[i].order] = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树状数组求逆序</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span>(c));</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">update(aa[i],<span class="number">1</span>);</span><br><span class="line">ans += i-getsum(aa[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>对于一个数组{5，3，7，4，6，2，1，8}，如果我们以中间（或者左中）为界限将其分成两个数组，只要知道这两个数组中的逆序对数和两边的数所组成的逆序对数就是它所有的逆序对数了。而数组划分的递归结束点在两个数组都只有一个元素的时候，因此两数组中的逆序对数可以要去求分裂的两数组中的逆序对数可以这样去做：先将两数组按升序排序，若前一个数组的第一个元素比后一个的大，则说明前一组的后面所有都要比后一组的第一个元素大，这样将较小的第一个元素去掉后，继续比较两个数组的第一个元素可以把所有的逆序对找到。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right,<span class="keyword">int</span> temp[],<span class="keyword">long</span> <span class="keyword">long</span> *count)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>,i,j;</span><br><span class="line">i = left; j = mid+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>((i&lt;=mid) &amp;&amp; (j&lt;=right))&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i] &lt;= arr[j])&#123;</span><br><span class="line">temp[k++] = arr[i++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">temp[k++] = arr[j++];</span><br><span class="line"><span class="comment">//ans+=e1-p1+1;</span></span><br><span class="line">(*count) = (*count) + mid - i + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//在归并排序的过程中，可以一步步来计算逆序数的值，由于归并排序的过程一直都是升序在排序，所以如果a[i]&gt;a[j]的话，那么a[i]后面的数一定都大于a[j]，加上后面的数的个数；</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid)</span><br><span class="line">temp[k++] = arr[i++];</span><br><span class="line"><span class="keyword">while</span>(j&lt;=right)</span><br><span class="line">temp[k++] = arr[j++];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">arr[left+i] = temp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> temp[],<span class="keyword">long</span> <span class="keyword">long</span> *count)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(left&lt;right)&#123; <span class="comment">// 递归出口</span></span><br><span class="line"><span class="keyword">int</span> mid = (left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">mergeSort(arr,left,mid,temp,count);</span><br><span class="line">mergeSort(arr,mid+<span class="number">1</span>,right,temp,count);</span><br><span class="line">merge(arr,left,mid,right,temp,count);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line"><span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *temp = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">mergeSort(a,<span class="number">0</span>,m<span class="number">-1</span>,temp,&amp;count);</span><br><span class="line"><span class="keyword">delete</span> []a;</span><br><span class="line"><span class="keyword">delete</span> []temp;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;count;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>本文参考整理自：</p><p><a href="http://www.360doc.com/content/12/0925/21/9615799_238155264.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/12/0925/21/9615799_238155264.shtml</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;树状数组和归并排序求逆序数&quot;&gt;&lt;a href=&quot;#树状数组和归并排序求逆序数&quot; class=&quot;headerlink&quot; title=&quot;树状数组和归并排序求逆序数&quot;&gt;&lt;/a&gt;树状数组和归并排序求逆序数&lt;/h1&gt;&lt;h2 id=&quot;树状数组&quot;&gt;&lt;a href=&quot;#树状数组&quot;
      
    
    </summary>
    
      <category term="学习" scheme="https://hushhw.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法笔记" scheme="https://hushhw.cn/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
      <category term="树状数组" scheme="https://hushhw.cn/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="归并排序" scheme="https://hushhw.cn/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>线段树总结</title>
    <link href="https://hushhw.cn/2018/02/23/16%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>https://hushhw.cn/2018/02/23/16线段树/</id>
    <published>2018-02-22T17:21:28.000Z</published>
    <updated>2018-02-22T17:22:43.819Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线段树基本概念"><a href="#线段树基本概念" class="headerlink" title="线段树基本概念"></a>线段树基本概念</h3><p>线段树/区间树是一种非常常用的对区间数据进行操作的数据结构。 </p><p>线段树是一棵二叉树（但不一定是完全二叉树！），它的每个节点均代表一个区间，且父节点代表的区间为左右子节点代表的区间之和。特别的，根节点代表的区间为所有节点代表区间之和，各个叶节点代表区间为单个点（即长度为1的区间）。</p><h3 id="线段树结构"><a href="#线段树结构" class="headerlink" title="线段树结构"></a>线段树结构</h3><p>树中的每一个结点表示了一个区间[a,b]。 a,b通常是整数。每一个叶子节点表示了一个单位区间(长度为1)。对于每一个非叶结点所表示的结点[a,b]，其左儿子表示的区间为[a,(a+b)/2]，右儿子表示的区间为[(a+b)/2+1,b](除法去尾取整）。 </p><p>如下图为区间[1, 9]的线段树：<br><img src="http://7xkwr3.com1.z0.glb.clouddn.com/interval_tree1.PNG" alt="线段树"></p><h3 id="线段树性质"><a href="#线段树性质" class="headerlink" title="线段树性质"></a>线段树性质</h3><ol><li>线段树为二分构造，若根节点对应区间为[a,b]，则其深度为 log2(b−a+1)(向上取整）。这样在进行更新查询操作的时候，操作的复杂度就可以为log(n)量级</li><li>叶子节点的数目和根节点表示的区间长度相同</li><li>若叶子节点的数目为N，则线段树的总节点数目为2*N-1。因为线段树的节点要么是0度，要么为2度，根据二叉树的性质可知。</li><li>若叶子节点为N，要想用连续的数组表示一棵线段树，则数组的大小应该为<strong>4N</strong>。<br>因为，根据性质3，线段树总节点数目为2<em>N-1，又由于线段树不是完全二叉树，因此其最低的叶子一层并不是紧靠最左边，这样在其倒数第二层上的索引号接近2N的位置，按照2</em>index+1和2<em>index+2的方式来访问其左右子节点，这就导致整个数组的大小要约为 4</em>N.</li><li>线段树上，任何一个区间被分解后得到的“终止”节点的数目都是log(n)量级。<br>因为每一层最多有两个“终止”节点，共log(n)层，这样在线段树上进行更新叶子节点和进行区间分解的时间复杂度都是O(logn)。</li></ol><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>以<a href="http://lx.lanqiao.cn/problem.page?gpid=T18" target="_blank" rel="noopener">ALGO-8 操作格子</a> 为例，线段树的一些基本操作：</p><ul><li>建树</li><li>区间求和</li><li>区间取最值</li><li>区间单点修改</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> left,right;<span class="comment">//保存左右边界</span></span><br><span class="line"><span class="keyword">int</span> sum,max;<span class="comment">//权值和最大值</span></span><br><span class="line">&#125;a[MAXN*<span class="number">3</span>+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">imax</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="comment">//判断大小的函数   </span></span><br><span class="line"><span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qMax</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;<span class="comment">//que=3，求l到r最大权值</span></span><br><span class="line"><span class="keyword">if</span>(l == a[n].left &amp;&amp; r == a[n].right)<span class="comment">//所求范围与左右范围相等 ，直接输出最大值   </span></span><br><span class="line"><span class="keyword">return</span> a[n].max;  </span><br><span class="line"><span class="keyword">int</span> middle = (a[n].left + a[n].right) / <span class="number">2</span>;  </span><br><span class="line"><span class="keyword">if</span>(r &lt;= middle)  </span><br><span class="line"><span class="keyword">return</span> qMax(n*<span class="number">2</span>, l, r);<span class="comment">//若所求范围在左孩子范围内，从左孩子寻找   </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(l &gt; middle)  </span><br><span class="line"><span class="keyword">return</span> qMax(n*<span class="number">2</span>+<span class="number">1</span>, l, r);<span class="comment">//若所求范围在右孩子范围内，从右孩子寻找  </span></span><br><span class="line"><span class="keyword">else</span>   </span><br><span class="line"><span class="keyword">return</span> imax(qMax(n*<span class="number">2</span>, l, middle), qMax(n*<span class="number">2</span>+<span class="number">1</span>, middle+<span class="number">1</span>, r));<span class="comment">//若范围在左右孩子之间，分别求最大值，然后求最终最大值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qSum</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;<span class="comment">//que=2，计算l到r的权值和</span></span><br><span class="line"><span class="keyword">if</span>(l==a[n].left &amp;&amp; r==a[n].right)<span class="comment">//若是叶子节点，左右相等，直接返回sum</span></span><br><span class="line"><span class="keyword">return</span> a[n].sum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> middle = (a[n].left+a[n].right)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(r &lt;= middle)&#123; <span class="comment">//下面分情况讨论</span></span><br><span class="line"><span class="keyword">return</span> qSum(n*<span class="number">2</span>, l, r);<span class="comment">//若在左孩子范围，从左孩子寻找</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(l &gt; middle)&#123;</span><br><span class="line"><span class="keyword">return</span> qSum(n*<span class="number">2</span>+<span class="number">1</span>, l, r);<span class="comment">//若在右孩子范围，从右孩子寻找</span></span><br><span class="line">&#125; <span class="keyword">else</span>&#123;<span class="comment">//若在之间，分别求解相加</span></span><br><span class="line"><span class="keyword">return</span> (qSum(n*<span class="number">2</span>, l, middle) + qSum(n*<span class="number">2</span>+<span class="number">1</span>, middle+<span class="number">1</span>, r));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> num)</span></span>&#123; </span><br><span class="line"><span class="comment">//que=1,在区间[l,r]中将r的权值改为num，这题l==r</span></span><br><span class="line"><span class="keyword">if</span>(l==a[n].left &amp;&amp; r==a[n].right)&#123;<span class="comment">//下标与左右范围相等，存本数</span></span><br><span class="line">a[n].sum = num;</span><br><span class="line">a[n].max = num;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> middle = (a[n].left+a[n].right)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(r&lt;=middle)</span><br><span class="line">change(n*<span class="number">2</span>, l, r, num);<span class="comment">//更新左孩子</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(r&gt;middle)</span><br><span class="line">change(n*<span class="number">2</span>+<span class="number">1</span>, l, r, num);<span class="comment">//更新右孩子</span></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">change(n*<span class="number">2</span>, l, middle, num);</span><br><span class="line">change(n*<span class="number">2</span>+<span class="number">1</span>, middle+<span class="number">1</span>, r, num);</span><br><span class="line">&#125;</span><br><span class="line">a[n].sum = a[n*<span class="number">2</span>].sum + a[n*<span class="number">2</span>+<span class="number">1</span>].sum;<span class="comment">//更新总和</span></span><br><span class="line">a[n].max = imax(a[n*<span class="number">2</span>].max, a[n*<span class="number">2</span>+<span class="number">1</span>].max);<span class="comment">//更新最大值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;<span class="comment">//如果左右间距相等,说明是叶子节点</span></span><br><span class="line">a[n].left = l;</span><br><span class="line">a[n].right = r;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[n].sum);</span><br><span class="line">a[n].max = a[n].sum;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> middle = (l+r)/<span class="number">2</span>;</span><br><span class="line">a[n].left = l;<span class="comment">//左边距</span></span><br><span class="line">a[n].right = r;<span class="comment">//右边距</span></span><br><span class="line">build(n*<span class="number">2</span>, l, middle);<span class="comment">//构建l至mid的左孩子</span></span><br><span class="line">build(n*<span class="number">2</span>+<span class="number">1</span>, middle+<span class="number">1</span>, r);<span class="comment">//构建mid+1到r的右孩子</span></span><br><span class="line"></span><br><span class="line">a[n].sum = a[n*<span class="number">2</span>].sum + a[n*<span class="number">2</span>+<span class="number">1</span>].sum;</span><br><span class="line">a[n].max = imax(a[n*<span class="number">2</span>].max, a[n*<span class="number">2</span>+<span class="number">1</span>].max);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">build(<span class="number">1</span>,<span class="number">1</span>,n);<span class="comment">//构建一个范围为1到n的线段树</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> que,b,c;</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;que, &amp;b, &amp;c);</span><br><span class="line"><span class="keyword">switch</span>(que)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">change(<span class="number">1</span>,b,b,c); <span class="keyword">break</span>;<span class="comment">//改变节点b的权值为c  </span></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, qSum(<span class="number">1</span>,b,c)); <span class="keyword">break</span>;<span class="comment">//计算b至c范围内的权值和   </span></span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, qMax(<span class="number">1</span>,b,c)); <span class="keyword">break</span>;<span class="comment">//计算b至c范围内的最大权值   </span></span><br><span class="line"><span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>本文整理参考自：</p><p><a href="https://www.cnblogs.com/gtarcoder/p/4786734.html" target="_blank" rel="noopener">https://www.cnblogs.com/gtarcoder/p/4786734.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;线段树基本概念&quot;&gt;&lt;a href=&quot;#线段树基本概念&quot; class=&quot;headerlink&quot; title=&quot;线段树基本概念&quot;&gt;&lt;/a&gt;线段树基本概念&lt;/h3&gt;&lt;p&gt;线段树/区间树是一种非常常用的对区间数据进行操作的数据结构。 &lt;/p&gt;
&lt;p&gt;线段树是一棵二叉树（但
      
    
    </summary>
    
      <category term="学习" scheme="https://hushhw.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法笔记" scheme="https://hushhw.cn/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
      <category term="线段树" scheme="https://hushhw.cn/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>LQOJ刷题总结</title>
    <link href="https://hushhw.cn/2018/02/21/16LQOJ/"/>
    <id>https://hushhw.cn/2018/02/21/16LQOJ/</id>
    <published>2018-02-21T15:19:04.000Z</published>
    <updated>2018-02-21T15:20:50.178Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LQOJ"><a href="#LQOJ" class="headerlink" title="LQOJ"></a>LQOJ</h1><h3 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h3><ol><li><a href="https://github.com/hushhw/LQOJ/blob/master/BASIC/BASIC-29%20%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95.cpp" target="_blank" rel="noopener">高精度加法</a>  <code>BASIC-29</code> <code>高精度加法</code> </li><li><a href="https://github.com/hushhw/LQOJ/blob/master/BASIC/BASIC-30%20%E9%98%B6%E4%B9%98%E8%AE%A1%E7%AE%97.cpp" target="_blank" rel="noopener">阶乘计算</a> <code>BASIC-30</code>  <code>高精度乘法</code></li></ol><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><ol><li><a href="https://github.com/hushhw/LQOJ/blob/master/BASIC/BASIC-27%202n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98.cpp" target="_blank" rel="noopener">2n皇后问题</a> <code>BASIC-27</code> <code>八皇后问题</code> <code>搜索</code></li></ol><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><ol><li><a href="https://github.com/hushhw/LQOJ/blob/master/BASIC/BASIC-19%20%E5%AE%8C%E7%BE%8E%E7%9A%84%E4%BB%A3%E4%BB%B7.cpp" target="_blank" rel="noopener">完美的代价</a> <code>BASIC-19</code></li><li><a href="https://github.com/hushhw/LQOJ/blob/master/ALGO/ALGO-002%20%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0(%E8%B4%AA%E5%BF%83" target="_blank" rel="noopener">最大最小公倍数</a>.cpp) <code>ALGO-2</code> </li></ol><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><ol><li><a href="https://github.com/hushhw/LQOJ/blob/master/ALGO/ALGO-003%20K%E5%A5%BD%E6%95%B0.cpp" target="_blank" rel="noopener">K好数</a> <code>ALGO-3</code> <code>数位dp</code></li><li><a href="https://github.com/hushhw/LQOJ/blob/master/ALGO/ALGO-004%20%E7%BB%93%E7%82%B9%E9%80%89%E6%8B%A9.cpp" target="_blank" rel="noopener">结点选择</a> <code>ALGO-4</code> <code>树形dp</code></li></ol><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li>图论<ul><li><a href="https://github.com/hushhw/LQOJ/blob/master/ALGO/ALGO-005%20%E6%9C%80%E7%9F%AD%E8%B7%AF.cpp" target="_blank" rel="noopener">最短路</a> <code>ALGO-5</code> <code>SPFA算法</code></li></ul></li><li>矩阵<ul><li><a href="https://github.com/hushhw/LQOJ/blob/master/BASIC/BASIC-17%20%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95.cpp" target="_blank" rel="noopener">矩阵乘法</a> <code>BASIC-17</code> <code>矩阵</code></li></ul></li><li>树&amp;二叉树</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LQOJ&quot;&gt;&lt;a href=&quot;#LQOJ&quot; class=&quot;headerlink&quot; title=&quot;LQOJ&quot;&gt;&lt;/a&gt;LQOJ&lt;/h1&gt;&lt;h3 id=&quot;高精度&quot;&gt;&lt;a href=&quot;#高精度&quot; class=&quot;headerlink&quot; title=&quot;高精度&quot;&gt;&lt;/a&gt;高精
      
    
    </summary>
    
      <category term="学习" scheme="https://hushhw.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="OJ刷题" scheme="https://hushhw.cn/categories/%E5%AD%A6%E4%B9%A0/OJ%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="OJ" scheme="https://hushhw.cn/tags/OJ/"/>
    
      <category term="刷题" scheme="https://hushhw.cn/tags/%E5%88%B7%E9%A2%98/"/>
    
      <category term="LQOJ" scheme="https://hushhw.cn/tags/LQOJ/"/>
    
  </entry>
  
  <entry>
    <title>最小生成树算法</title>
    <link href="https://hushhw.cn/2018/02/21/15%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <id>https://hushhw.cn/2018/02/21/15生成树/</id>
    <published>2018-02-21T12:45:22.000Z</published>
    <updated>2018-02-21T18:05:38.942Z</updated>
    
    <content type="html"><![CDATA[<p>关于图的几个概念定义：</p><ul><li><strong>连通图</strong>：在无向图中，若任意两个顶点vi与vj都有路径相通，则称该无向图为连通图。</li><li><strong>强连通图</strong>：在有向图中，若任意两个顶点vi与vj都有路径相通，则称该有向图为强连通图。</li><li><strong>连通网</strong>：在连通图中，若图的边具有一定的意义，每一条边都对应着一个数，称为权；权代表着连接连个顶点的代价，称这种连通图叫做连通网。</li><li><strong>生成树</strong>：一个连通图的生成树是指一个连通子图，它含有图中全部n个顶点，但只有足以构成一棵树的n-1条边。一颗有n个顶点的生成树有且仅有n-1条边，如果生成树中再添加一条边，则必定成环。</li><li><p><strong>最小生成树</strong>：在连通网的所有生成树中，所有边的代价和最小的生成树，称为最小生成树。</p><p><img src="http://img.blog.csdn.net/20160714130435508" alt="这里写图片描述"></p></li></ul><p>下面介绍两种求最小生成树算法</p><h2 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h2><p>此算法可以称为“加边法”，初始最小生成树边数为0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里。 </p><ol><li>把图中的所有边按代价从小到大排序； </li><li>把图中的n个顶点看成独立的n棵树组成的森林； </li><li>按权值从小到大选择边，所选的边连接的两个顶点ui,vi,应属于两颗不同的树，则成为最小生成树的一条边，并将这两颗树合并作为一颗树。 </li><li>重复(3),直到所有顶点都在一颗树内或者有n-1条边为止。</li></ol><p>实际上代码中就是并查集思想</p><p><img src="http://img.blog.csdn.net/20160714144315409" alt="这里写图片描述"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> from,to,val;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge &amp;x)<span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> val &lt; x.val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;e[MAXN * MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[MAXN],len=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line">r=x;</span><br><span class="line"><span class="keyword">while</span>(r!=pre[r]) <span class="comment">//如果不是根，就去找</span></span><br><span class="line">r=pre[r];</span><br><span class="line"></span><br><span class="line"><span class="comment">//路径压缩</span></span><br><span class="line"><span class="keyword">int</span> i=x;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">while</span>(i!=r)&#123;<span class="comment">//如果当前查找的结点x不是根</span></span><br><span class="line">j=pre[i];<span class="comment">//用j临时存储</span></span><br><span class="line">pre[i]=r;<span class="comment">//更新x的pre前导点直接指向r(前面已经搜过，r即根)</span></span><br><span class="line">i=j;<span class="comment">//让i指向其前导点，在下一次循环里面就会更新其前导点指向根</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) fa[i] = i;</span><br><span class="line">    sort(e,e+len);</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> rootx=find(e[i].from);<span class="comment">//分别查找根</span></span><br><span class="line">        <span class="keyword">int</span> rooty=find(e[i].to);</span><br><span class="line">        <span class="keyword">if</span>(rootx==rooty) <span class="keyword">continue</span>;</span><br><span class="line">        fa[rootx]=rooty; <span class="comment">//没有连接就更新连在一起</span></span><br><span class="line">        ans += e[i].val;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h2><p>Prim算法是一种产生最小生成树的算法。该算法于<code>1930</code>年由捷克数学家沃伊捷赫·亚尔尼克（英语：<code>Vojtěch Jarník</code>）发现；并在<code>1957</code>年由美国计算机科学家罗伯特·普里姆（英语：<code>Robert C. Prim</code>）独立发现；<code>1959</code>年，艾兹格·迪科斯彻再次发现了该算法。</p><p><code>Prim</code>算法从任意一个顶点开始，每次选择一个与当前顶点集最近的一个顶点，并将两顶点之间的边加入到树中。<code>Prim</code>算法在找当前最近顶点时使用到了贪婪算法。</p><p>算法描述：</p><ol><li>在一个加权连通图中，顶点集合<code>V</code>，边集合为<code>E</code></li><li>任意选出一个点作为初始顶点,标记为<code>visit</code>,计算所有与之相连接的点的距离，选择距离最短的，标记<code>visit</code>.</li><li>重复以下操作，直到所有点都被标记为<code>visit</code>：</li></ol><p>在剩下的点中，计算与已标记<code>visit</code>点距离最小的点，标记<code>visit</code>,证明加入了最小生成树。</p><p><img src="http://img.blog.csdn.net/20160714161107576" alt="这里写图片描述"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> dis[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) dis[i] = INF;</span><br><span class="line"><span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">dis[cur]=<span class="number">0</span>;vis[cur]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        <span class="keyword">if</span>(!vis[j] &amp;&amp; dis[j] &gt; <span class="built_in">map</span>[cur][j])</span><br><span class="line">             dis[j] = <span class="built_in">map</span>[cur][j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mini = INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            <span class="keyword">if</span>(!vis[j] &amp;&amp; dis[j] &lt; mini)</span><br><span class="line">                mini = dis[cur = j];</span><br><span class="line">        vis[cur] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) ans+=dis[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>本文参考整理自：<br>勿在浮沙筑高台<a href="http://blog.csdn.net/luoshixian099/article/details/51908175" target="_blank" rel="noopener">http://blog.csdn.net/luoshixian099/article/details/51908175</a></p><p><a href="https://www.hrwhisper.me/algorithm-graph-dijkstra-spfa-bellmanford-prim-kruskal/#_MST" target="_blank" rel="noopener">https://www.hrwhisper.me/algorithm-graph-dijkstra-spfa-bellmanford-prim-kruskal/#_MST</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于图的几个概念定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;连通图&lt;/strong&gt;：在无向图中，若任意两个顶点vi与vj都有路径相通，则称该无向图为连通图。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;强连通图&lt;/strong&gt;：在有向图中，若任意两个顶点vi与vj都有路径相
      
    
    </summary>
    
      <category term="学习" scheme="https://hushhw.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法笔记" scheme="https://hushhw.cn/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
      <category term="图论" scheme="https://hushhw.cn/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最小生成树" scheme="https://hushhw.cn/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>最短路径</title>
    <link href="https://hushhw.cn/2018/02/21/14%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    <id>https://hushhw.cn/2018/02/21/14最短路/</id>
    <published>2018-02-21T08:52:43.000Z</published>
    <updated>2018-02-21T08:54:12.070Z</updated>
    
    <content type="html"><![CDATA[<ul><li>dijkstra</li><li>SPFA</li><li>floyd</li></ul><h2 id="dijkstra-单源最短路径"><a href="#dijkstra-单源最短路径" class="headerlink" title="dijkstra(单源最短路径)"></a>dijkstra(单源最短路径)</h2><p>Dijkstra单源最短路算法，即计算从起点出发到每个点的最短路。Dijkstra常常作为其他算法的预处理。</p><ul><li>使用邻接矩阵的时间复杂度为O(n^2)</li><li>用邻接表+优先队列（堆）的时间复杂度为O((m+n)logn)近似为O(mlogn)</li></ul><p>这个算法只能计算单元最短路，而且不能计算负权值，这个算法是贪心的思想， dis数组用来储存起始点到其他点的最短路，但开始时却是存的起始点到其他点的初始路程。通过n-1遍的遍历找最短。<br>比如1到3的最短路就是比较dis[3]与dis[2]+e[2][3]，如果大于的话就更新dis[3]位dis[2]+e[2][3]，这个专业术语叫松弛，这种算法的核心思想就是通过边来松弛一号顶点到其他定点的路程，这也就能解释为什么要遍历n-1遍了。<br>book数组用来标记，被标记的是已经找过的最短路，没被标记的没有被找过的最短路，当全部找过以后算法结束，也就是说dis数组中的数是起始点到其他所有点的最短路 。</p><p>以下为以 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1874" target="_blank" rel="noopener">HDU 1874 畅通工程续</a> 完整代码：</p><ol><li>dijkstra+邻接矩阵</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">200</span>+<span class="number">10</span>;  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[MAXN][MAXN];<span class="comment">//e用来记录数组</span></span><br><span class="line"><span class="keyword">int</span> dis[MAXN];<span class="comment">//dis用来记录初始点到个点的位置</span></span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];<span class="comment">//标记是否被访问</span></span><br><span class="line"><span class="keyword">int</span> n,m;<span class="comment">//n表示顶点个数，m表示边的条数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));<span class="comment">//初始化判断数组</span></span><br><span class="line"><span class="keyword">int</span> cur=s;</span><br><span class="line">dis[cur]=<span class="number">0</span>;</span><br><span class="line">vis[cur]=<span class="number">1</span>; <span class="comment">//把起点标记为已访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Dijkstra算法核心语句</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!vis[j] &amp;&amp; dis[j] &gt; dis[cur] + <span class="built_in">map</span>[cur][j])&#123;  <span class="comment">//更新cur到j的距离</span></span><br><span class="line">dis[j]=dis[cur] + <span class="built_in">map</span>[cur][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mini=inf;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!vis[j] &amp;&amp; dis[j]&lt;mini)&#123;<span class="comment">//更新当前未访问的最小的dis[cur]</span></span><br><span class="line">mini=dis[j];</span><br><span class="line">cur = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">vis[cur]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m))&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">dis[i]=inf;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line"><span class="built_in">map</span>[i][j]=inf;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> from,to,val;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++)&#123;<span class="comment">//读入边</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;from,&amp;to,&amp;val);</span><br><span class="line"><span class="built_in">map</span>[from][to] = <span class="built_in">map</span>[to][from] = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s,t;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;s,&amp;t); <span class="comment">//输入起点和终点</span></span><br><span class="line">dijkstra(s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dis[t]==inf)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dis[t]);</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>dijkstra+优先队列</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">200</span>+<span class="number">10</span>;  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[MAXN],len;<span class="comment">//记录数组</span></span><br><span class="line"><span class="keyword">int</span> dis[MAXN];<span class="comment">//dis用来记录初始点到个点的位置</span></span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];<span class="comment">//标记是否被访问</span></span><br><span class="line"><span class="keyword">int</span> n,m;<span class="comment">//n表示顶点个数，m表示边的条数</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to, val, next;</span><br><span class="line">&#125;e[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">e[len].to=to;</span><br><span class="line">e[len].val=val;</span><br><span class="line">e[len].next=head[from];</span><br><span class="line">head[from]=len++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> val, id;</span><br><span class="line">point(<span class="keyword">int</span> id,<span class="keyword">int</span> val):id(id),val(val)&#123;&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> point &amp;x)<span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> val&gt;x.val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));<span class="comment">//初始化判断数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">dis[i] = inf;</span><br><span class="line">priority_queue&lt;point&gt; q;</span><br><span class="line">q.push(point(s,<span class="number">0</span>));</span><br><span class="line">dis[s]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> cur=q.top().id;</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">if</span>(vis[cur]) <span class="keyword">continue</span>;</span><br><span class="line">vis[cur]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[cur]; i!=<span class="number">-1</span>; i=e[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> id=e[i].to;</span><br><span class="line"><span class="keyword">if</span>(!vis[id] &amp;&amp; dis[cur]+e[i].val &lt; dis[id])&#123;</span><br><span class="line">dis[id]=dis[cur]+e[i].val;</span><br><span class="line">q.push(point(id, dis[id]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m))&#123;</span><br><span class="line">len=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line"><span class="keyword">int</span> from, to, val;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;from,&amp;to,&amp;val);</span><br><span class="line">add(from, to, val);</span><br><span class="line">add(to, from, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> s,t;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;s,&amp;t); <span class="comment">//输入起点和终点</span></span><br><span class="line">dijkstra(s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dis[t]==inf)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dis[t]);</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SPFA（bellman-ford）"><a href="#SPFA（bellman-ford）" class="headerlink" title="SPFA（bellman-ford）"></a>SPFA（bellman-ford）</h2><p>SPFA是bellman-ford算法的队列实现版本（貌似也改进了点）</p><p>SPFA的实现如下：</p><p>用数组dis记录更新后的状态，cnt记录更新的次数，队列q记录更新过的顶点，算法依次从q中取出顶点v,按照dis(k)[u]=min{dis(k-1)[v]+e(v,u)}的递归式更新。在计算过程中，一旦发现顶点K有cnt[k]&gt;n，说明有一个从顶点K出发的负权圈，此时没有最短路，应终止算法。否则，队列为空的时候，算法得到G的各顶点的最短路径长度。</p><p> 下面举一个实例来说明SFFA算法是怎样进行的：<br><img src="http://www.layz.net/LAOJ/suanfa/pic/s9-4-1.jpg" alt="img"><br><img src="http://www.layz.net/LAOJ/suanfa/pic/s9-4-2.jpg" alt="img"></p><p>1.邻接矩阵的SPFA <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1874" target="_blank" rel="noopener">HDU 1874 畅通工程续</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">200</span>+<span class="number">10</span>;  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[MAXN][MAXN];<span class="comment">//记录数组</span></span><br><span class="line"><span class="keyword">int</span> dis[MAXN];<span class="comment">//dis用来记录初始点到个点的位置</span></span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];<span class="comment">//标记是否被访问</span></span><br><span class="line"><span class="keyword">int</span> n,m;<span class="comment">//n表示顶点个数，m表示边的条数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">dis[i]=inf;</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">vis[s]=<span class="number">1</span>;</span><br><span class="line">dis[s]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.push(s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> cur=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">vis[cur]=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[i] &gt; dis[cur] + <span class="built_in">map</span>[cur][i])&#123;</span><br><span class="line">dis[i] = dis[cur] + <span class="built_in">map</span>[cur][i];</span><br><span class="line"><span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">q.push(i);</span><br><span class="line">vis[i]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m))&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line"><span class="built_in">map</span>[i][j]=inf;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> from,to,val;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++)&#123;<span class="comment">//读入边</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;from,&amp;to,&amp;val);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>[from][to]&gt;val)</span><br><span class="line"><span class="built_in">map</span>[from][to] = <span class="built_in">map</span>[to][from] = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s,t;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;s,&amp;t); <span class="comment">//输入起点和终点</span></span><br><span class="line">SPFA(s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dis[t]==inf)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dis[t]);</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>邻接表的SPFA（推荐）<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1874" target="_blank" rel="noopener">HDU 1874 畅通工程续</a></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">const int inf=0x3f3f3f3f;</span><br><span class="line">const int MAXN=200+10;  </span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int head[MAXN],len;</span><br><span class="line">int dis[MAXN];//dis用来记录初始点到个点的位置</span><br><span class="line">bool vis[MAXN];//标记是否被访问</span><br><span class="line">int n,m;//n表示顶点个数，m表示边的条数</span><br><span class="line"></span><br><span class="line">struct edge&#123;</span><br><span class="line">int to, val, next;</span><br><span class="line">&#125;e[MAXN];</span><br><span class="line"></span><br><span class="line">void add(int from, int to, int val)&#123;</span><br><span class="line">e[len].to=to;</span><br><span class="line">e[len].val=val;</span><br><span class="line">e[len].next=head[from];</span><br><span class="line">head[from]=len++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void SPFA(int s)&#123;</span><br><span class="line">memset(vis, 0, sizeof(vis));//初始化判断数组</span><br><span class="line">for(int i=0; i&lt;n; i++)</span><br><span class="line">dis[i] = inf;</span><br><span class="line"></span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">q.push(s);</span><br><span class="line">vis[s]=true;</span><br><span class="line">dis[s]=0;</span><br><span class="line"></span><br><span class="line">while(!q.empty())&#123;</span><br><span class="line">int cur=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">vis[cur]=false;</span><br><span class="line">for(int i=head[cur]; i!=-1; i=e[i].next)&#123;</span><br><span class="line">int id=e[i].to;</span><br><span class="line">if(dis[id] &gt; dis[cur]+e[i].val)&#123;</span><br><span class="line">dis[id] = dis[cur]+e[i].val;</span><br><span class="line">if(!vis[id])&#123;</span><br><span class="line">vis[id]=true;</span><br><span class="line">q.push(id);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))&#123;</span><br><span class="line">len=0;</span><br><span class="line">memset(head, -1, sizeof(head));</span><br><span class="line"></span><br><span class="line">for(int i=0; i&lt;m; i++)&#123;</span><br><span class="line">int from, to, val;</span><br><span class="line">scanf(&quot;%d%d%d&quot;,&amp;from,&amp;to,&amp;val);</span><br><span class="line">add(from, to, val);</span><br><span class="line">add(to, from, val);</span><br><span class="line">&#125;</span><br><span class="line">int s,t;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;s,&amp;t); //输入起点和终点</span><br><span class="line">SPFA(s);</span><br><span class="line"></span><br><span class="line">if(dis[t]==inf)</span><br><span class="line">printf(&quot;-1\n&quot;);</span><br><span class="line">else</span><br><span class="line">printf(&quot;%d\n&quot;,dis[t]);</span><br><span class="line">&#125;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="floyd"><a href="#floyd" class="headerlink" title="floyd"></a>floyd</h2><p><strong>Floyd-Warshall算法</strong>（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包。Floyd-Warshall算法的时间复杂度为$O(N^3)$，空间复杂度为$O(N^2)$。</p><p>这是一个dp（动态规划的过程）<br>dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);<br>即从顶点i到j且经过顶点k的最短路径长度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">200</span>+<span class="number">10</span>;  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> n,m;<span class="comment">//n表示顶点个数，m表示边的条数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;n; k++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">dis[i][j]=min(dis[i][j], dis[i][k]+dis[k][j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m))&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">dis[i][j]=inf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line"><span class="keyword">int</span> from, to, val;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;from,&amp;to,&amp;val);</span><br><span class="line"><span class="keyword">if</span>(dis[from][to] &gt; val)  </span><br><span class="line">dis[to][from]=dis[from][to]=val; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> s,t;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;s,&amp;t); <span class="comment">//输入起点和终点</span></span><br><span class="line"><span class="keyword">if</span>(s==t)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">floyd();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dis[s][t]==inf)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dis[s][t]);</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>本文整理自：</p><p><a href="http://blog.csdn.net/acm_1361677193/article/details/48211319" target="_blank" rel="noopener">http://blog.csdn.net/acm_1361677193/article/details/48211319</a></p><p><a href="http://blog.csdn.net/xunalove/article/details/70045815" target="_blank" rel="noopener">http://blog.csdn.net/xunalove/article/details/70045815</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;dijkstra&lt;/li&gt;
&lt;li&gt;SPFA&lt;/li&gt;
&lt;li&gt;floyd&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;dijkstra-单源最短路径&quot;&gt;&lt;a href=&quot;#dijkstra-单源最短路径&quot; class=&quot;headerlink&quot; title=&quot;dijk
      
    
    </summary>
    
      <category term="学习" scheme="https://hushhw.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法笔记" scheme="https://hushhw.cn/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
      <category term="图论" scheme="https://hushhw.cn/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最短路" scheme="https://hushhw.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>数位dp总结</title>
    <link href="https://hushhw.cn/2018/02/20/13%E6%95%B0%E4%BD%8Ddp/"/>
    <id>https://hushhw.cn/2018/02/20/13数位dp/</id>
    <published>2018-02-20T10:15:49.000Z</published>
    <updated>2018-02-21T08:54:20.411Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>“在信息学竞赛中，有一类与数位相关的区间统计问题。这类问题往往具有比较浓厚的数学味道，无法暴力求解，需要在数位上进行地推等操作。”——刘聪《浅谈数位类统计问题》</p></blockquote><p>这类问题往往需要一些预处理，这里就要用到数位dp。</p><p>数位DP是解决把一个数字区间里所有数字按位拆分再进行计算或计数的问题的动态规划算法。</p><h2 id="基本思想与方法"><a href="#基本思想与方法" class="headerlink" title="基本思想与方法"></a>基本思想与方法</h2><p>题目中经常需要统计区间[l, r]的满足题意的数的个数，这往往可以转换成求[0,r] - [0,l)的问题。对于求区间[0,n]有一个通用的方法：</p><p>​    对于一个小于n的数，肯定是从高位到低位出现某一位&lt;n的那一位，比如n=58(n为十进制)，x=49时，此时x的十位小于n，x=51时，此时x的个位小于n。</p><p>有了这个性质，我们可以从高位到低位枚举第一次&lt;n对应位是哪一位。这样之前的位确定了，之后的位就不受n的限制即从00…0~99…9，可以先预处理，然后这时就可以直接统计答案。</p><p>预处理f数组。$F[i, st]$代表的是位数为i，状态为st的方案数。这里的st根据题目需要确定。如i=4，$F[i, st]$也就是0000~9999的符合条件的数的个数。</p><p>决策第i位是多少（0~9），F[i, st] = F[i, st] + F[i-1, st’]，st’为相对应的状态。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="【Hdu2089-吉利数】"><a href="#【Hdu2089-吉利数】" class="headerlink" title="【Hdu2089 吉利数】"></a>【Hdu2089 吉利数】</h3><blockquote><p>题意：</p><p>区间[l,r]内数字的数位不含62且不含4的数的个数，0&lt;l&lt;=r&lt;1000000</p><p>如62315包含62，所以不合法</p></blockquote><p>参照前面提到的思路，先预处理一个f数组，然后统计[0, m] - [0, n)。</p><p>f[i, j]表示开头为j 的i 位数中不包含”62”或”4”的数有多少个。如f[2, 6]包含60，61，63，65，66，67，68，69。我们这里再举个栗子f[3, 0]：表示从1~100中满足条件的个数、（这里就不枚举了、、、）【0,99】</p><p>那么f[3, 1]呢？表示从100~200中满足条件的个数【100,199】</p><p>具体看代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">7</span>; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">10</span>; j++)&#123;<span class="comment">//枚举第i位数上的数字</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">10</span>; k++)&#123;<span class="comment">//枚举第i-1为数上的数字</span></span><br><span class="line"><span class="keyword">if</span>(j!=<span class="number">4</span> &amp;&amp; !(j==<span class="number">6</span> &amp;&amp; k==<span class="number">2</span>))<span class="comment">//满足条件</span></span><br><span class="line">dp[i][j] += dp[i<span class="number">-1</span>][k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">7</span>; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">10</span>; j++)&#123;<span class="comment">//枚举第i位数上的数字</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">10</span>; k++)&#123;<span class="comment">//枚举第i-1为数上的数字</span></span><br><span class="line"><span class="keyword">if</span>(j!=<span class="number">4</span> &amp;&amp; !(j==<span class="number">6</span> &amp;&amp; k==<span class="number">2</span>))<span class="comment">//满足条件</span></span><br><span class="line">dp[i][j] += dp[i<span class="number">-1</span>][k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">int</span> digit[<span class="number">10</span>];<span class="comment">//存储每位数字</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="number">1</span>;<span class="comment">//位数</span></span><br><span class="line"><span class="keyword">while</span>(n)&#123;</span><br><span class="line">digit[len++]=n%<span class="number">10</span>;</span><br><span class="line">n /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;<span class="comment">//记录满足条件的结果</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=len; i&gt;=<span class="number">1</span>; i--)&#123;<span class="comment">//从最高为开始遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;digit[i]; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(j!=<span class="number">4</span> &amp;&amp; !(digit[i+<span class="number">1</span>]==<span class="number">6</span> &amp;&amp; j==<span class="number">2</span>))</span><br><span class="line">ans += dp[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(digit[i]==<span class="number">4</span> || (digit[i+<span class="number">1</span>]==<span class="number">6</span> &amp;&amp; digit[i]==<span class="number">2</span>)) <span class="comment">////第i位已经不满足条件，则i位以后都不可能满足条件，结束循环  </span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r)&#123;</span><br><span class="line"><span class="keyword">if</span>(l+r==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;solve(r+<span class="number">1</span>)-solve(l)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外一种方法：<code>记忆化的数位dp</code></p><p>通常而言，有四个参数必须 dp( pos, flag, limit )<br>pos表示当前<strong>正在</strong>枚举的数位。<br>flag标志已经枚举的前缀是否某种性质（前面的数位和，是否含有某个数，前一个枚举的数等等。。），当然flag可以有多个。<br>limit表示当前是否为上限，有时还会记录是否有前导0。<br>相较而言，记忆化搜索更容易编写，需要维护的细节更少。</p><p>回到这题上面来，数位上不能有4也不能有连续的62，没有4的话在枚举的时候判断一下，不枚举4就可以保证状态合法了，所以这个约束没有记忆化的必要，而对于62的话，涉及到两位，当前一位是6或者不是6这两种不同情况我计数是不相同的，所以要用状态来记录不同的方案数。</p><p>dp[pos][sta]表示当前第pos位，前一位是否是6的状态，这里sta只需要去0和1两种状态就可以了，不是6的情况可视为同种，不会影响计数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">10</span>][<span class="number">2</span>]; <span class="comment">//dp[i][j]表示，当前第i位，前一位是否是6的状态</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> l,r,tot;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pos表示当前位置，pre表示前一个数，sta表示当前状态，也就是之前是否为6</span></span><br><span class="line"><span class="comment">//lim表示当前是否是有限制的，比如967，当我们第一个数选择9时，第二个数就只能选择0-6了</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> pre, <span class="keyword">int</span> sta, <span class="keyword">int</span> lim)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cur=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(pos==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//如果执行到0了，当前构成的数可行</span></span><br><span class="line"><span class="keyword">if</span>(!lim &amp;&amp; dp[pos][sta]!=<span class="number">-1</span>) <span class="keyword">return</span> dp[pos][sta];</span><br><span class="line"><span class="keyword">int</span> up = lim? a[pos]:<span class="number">9</span>; <span class="comment">//是否有限制判断</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=up; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">4</span> || (pre==<span class="number">6</span> &amp;&amp; i==<span class="number">2</span>)) <span class="comment">//如果当前数字为4，或者前一个数字为6，当前位2，排除</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">cur += dfs(pos<span class="number">-1</span>, i, i==<span class="number">6</span>, lim&amp;&amp;i==a[pos]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!lim) dp[pos][sta]=cur;</span><br><span class="line"><span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">tot = <span class="number">0</span>;<span class="comment">//tot用来记录位数</span></span><br><span class="line"><span class="keyword">while</span>(x)&#123;</span><br><span class="line">a[++tot]=x%<span class="number">10</span>;</span><br><span class="line">x /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dfs(tot,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r)&amp;&amp;(l+r))&#123;</span><br><span class="line"><span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, solve(r)-solve(l<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;“在信息学竞赛中，有一类与数位相关的区间统计问题。这类问题往往具有比较浓厚的数学味道，无法暴力求解，需要在数位上进行地推等操作。”——刘聪《浅谈数位类统计问题》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这类问题往往需要一些预处理，这里就要用到数位
      
    
    </summary>
    
      <category term="学习" scheme="https://hushhw.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法笔记" scheme="https://hushhw.cn/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
      <category term="动态规划" scheme="https://hushhw.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="数位dp" scheme="https://hushhw.cn/tags/%E6%95%B0%E4%BD%8Ddp/"/>
    
  </entry>
  
  <entry>
    <title>博弈论总结</title>
    <link href="https://hushhw.cn/2018/02/20/12%E5%8D%9A%E5%BC%88/"/>
    <id>https://hushhw.cn/2018/02/20/12博弈/</id>
    <published>2018-02-19T17:32:25.000Z</published>
    <updated>2018-02-19T17:37:05.455Z</updated>
    
    <content type="html"><![CDATA[<p>今天开始总结博弈这块的知识点，博弈论真的是一门非常神奇的学科。博弈是信息学和数学试题中常会出现的一种类型，算法灵活多变是其最大特点，而其中有一类试题更是完全无法用常见的博弈树来进行解答。 <strong>寻找必败态</strong>即为针对此类试题给出一种解题思路。</p><p>常见的几种博弈：</p><h2 id="巴什博弈（Bash-Game）"><a href="#巴什博弈（Bash-Game）" class="headerlink" title="巴什博弈（Bash Game）"></a>巴什博弈（Bash Game）</h2><blockquote><p>问题模型：只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取m个。最后取光者得胜。</p></blockquote><p>显然，如果n=m+1，那么由于一次最多只能取m个，所以，无论先取者拿走多少个，后取者都能够一次拿走剩余的物品，后者取胜。因此我们发现了如何取胜的法则：</p><script type="math/tex; mode=display">如果n=(m+1)r+s，（r为任意自然数，s≤m)</script><p>那么先取者要拿走s个物品，如果后取者拿走k（≤m)个，那么先取者再拿走m+1-k个，结果剩下(m+1)(r-1)个，以后保持这样的取法，那么先取者肯定获胜。</p><p>总之，要保持给对手留下(m+1)的倍数，那么最后就能获胜。</p><script type="math/tex; mode=display">取石子（一)\\时间限制：3000 ms   |   内存限制：65535 KB \\难度：2\\</script><p>描述<br>​    一天，TT在寝室闲着无聊，和同寝的人玩起了取石子游戏，而由于条件有限，他/她们是用旺仔小馒头当作石子。游戏的规则是这样的。设有一堆石子，数量为N（1&lt;=N&lt;=1000000），两个人轮番取出其中的若干个，每次最多取M（1&lt;=M&lt;=1000000），最先把石子取完者胜利。我们知道，TT和他/她的室友都十分的聪明，那么如果是TT先取，他/她会取得游戏的胜利么？ </p><p>输入<br>​    第一行是一个正整数n表示有n组测试数据<br>​    输入有不到1000组数据，每组数据一行，有两个数N和M,之间用空格分隔。 </p><p>输出<br>​    对于每组数据，输出一行。如果先取的TT可以赢得游戏，则输出“Win”，否则输出“Lose”（引号不用输出） </p><p>样例输入 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1000 1</span><br><span class="line">1 100</span><br></pre></td></tr></table></figure><p>样例输出 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Lose</span><br><span class="line"></span><br><span class="line">Win</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 巴什博弈</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> N, num, limit;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line"><span class="keyword">while</span>(N--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;num, &amp;limit);</span><br><span class="line"><span class="keyword">if</span>(num%(limit+<span class="number">1</span>)!=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Win\n"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Lose\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>巴什博弈变形： </p><script type="math/tex; mode=display">取石子（七） \\时间限制：1000 ms  |  内存限制：65535 KB \\难度：1</script><p>描述<br>​    Yougth和Hrdv玩一个游戏，拿出n个石子摆成一圈，Yougth和Hrdv分别从其中取石子，谁先取完者胜，每次可以从中取一个或者相邻两个，Hrdv先取，输出胜利着的名字。 </p><p>输入<br>​    输入包括多组测试数据。<br>​    每组测试数据一个n，数据保证int范围内。 </p><p>输出<br>​    输出胜利者的名字。 </p><p>样例输入 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>样例输出 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hrdv</span><br><span class="line">Yougth</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解题思路：假设石子数等于5，如果先者先取一个，那么后者拿走两个，将剩下的两个石子分成两堆，后者赢。如果先者先取二个，那么后者取一个使剩下的两个石子分成两堆，后者赢。假设石子数等于6，如果先者先取一个，那么后者拿走一个，将剩下的石子分成两段，每段两个，如果先者再拿两个，那么后者赢，如果先者再拿一个，那么后者再取另一堆中的一个，这样剩下的两个石子被分成两堆， 后者赢。         如果先者先取两个，那么后者也取两个使剩下的两个石子分成两堆，后者赢。所以当先者取走后，后者取走一个或者两个，将剩下的石子分成对称的两段，以此类推，那么如果石子数大于2后者一定赢。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"><span class="keyword">int</span> n;  </span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF)  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">if</span>(n &gt; <span class="number">2</span>)  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Yougth\n"</span>);  </span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Hrdv\n"</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="威佐夫博弈（Wythoff-Game）"><a href="#威佐夫博弈（Wythoff-Game）" class="headerlink" title="威佐夫博弈（Wythoff Game）"></a>威佐夫博弈（Wythoff Game）</h2><blockquote><p>问题模型：有两堆各若干个物品，两个人轮流从某一堆或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜。</p></blockquote><p>我们用（ak，bk）（ak ≤ bk ,k=0，1，2，…,n)表示两堆物品的数量并称其为局势，如果甲面对（0，0），那么甲已经输了，这种局势我们称为奇异局势。前几个奇异局势是：（0，0）、（1，2）、（3，5）、（4，7）、（6，10）、（8，13）、（9，15）、（11，18）、（12，20）。 可以看出,a0=b0=0,ak是未在前面出现过的最小自然数,而 bk= ak + k，奇异局势有如下三条性质： </p><ul><li>任何自然数都包含在一个且仅有一个奇异局势中。 </li><li>任意操作都可将奇异局势变为非奇异局势。 </li><li>采用适当的方法，可以将非奇异局势变为奇异局势。</li></ul><p>从如上性质可知，两个人如果都采用正确操作，那么面对非奇异局势，先拿者必胜；反之，则后拿者取胜。<br> 那么任给一个局势（a，b），怎样判断它是不是奇异局势呢？我们有如下公式： </p><script type="math/tex; mode=display">a_k =[\frac {k(1+√5)}2]，b_k= a_k + k（k=0，1，2，...,n 方括号表示取整函数)</script><script type="math/tex; mode=display">取石子 (四） \\时间限制：1000 ms  |  内存限制：65535 KB \\难度：4</script><p>描述<br>​    有两堆石子，数量任意，可以不同。游戏开始由两个人轮流取石子。游戏规定，每次有两种不同的取法，一是可以在任意的一堆中取走任意多的石子；二是可以在两堆中同时取走相同数量的石子。最后把石子全部取完者为胜者。现在给出初始的两堆石子的数目，如果轮到你先取，假设双方都采取最好的策略，问最后你是胜者还是败者。 </p><p>输入<br>​    输入包含若干行，表示若干种石子的初始情况，其中每一行包含两个非负整数a和b，表示两堆石子的数目，a和b都不大于1,000,000,000。 </p><p>输出<br>​    输出对应也有若干行，每行包含一个数字1或0，如果最后你是胜者，则为1，反之，则为0。 </p><p>样例输入 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 1</span><br><span class="line">8 4</span><br><span class="line">4 7</span><br></pre></td></tr></table></figure><p>样例输出 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n)&#123;</span><br><span class="line"><span class="keyword">if</span>(m&gt;n)</span><br><span class="line">swap(m,n);</span><br><span class="line"><span class="keyword">int</span> k = n-m;</span><br><span class="line"><span class="keyword">int</span> data = <span class="built_in">floor</span>(k*(<span class="number">1.0</span>+<span class="built_in">sqrt</span>(<span class="number">5.0</span>))/<span class="number">2.0</span>);</span><br><span class="line"><span class="keyword">if</span>(data==m)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">Wythoff Game \\时间限制：1000 ms  |  内存限制：65535 KB \\难度：1</script><p>描述<br>​    最近ZKC同学在学博弈，学到了一个伟大的博弈问题—威佐夫博弈。<br>​    相信大家都学过了吧？没学过？没问题。我将要为你讲述一下这个伟大的博弈问题。 有两堆石子，数量任意，可以不同。游戏开始由两个人轮流取石子。 游戏规定，每次有两种不同的取法：<br>一是可以在任意的一堆中取走任意多的石子； 二是可以在两堆中同时取走相同数量的石子。 最后把石子全部取完者为胜者。<br>​    我们今天要做的是求前n个必败态。<br>​    什么是必败态？比如我们把（a，b）称为一种状态，a，b分别为两堆石子中所剩的数目。如果a=0，b=0，我们说该种状态为必败态，因为我不能再进行游戏，即使是可以进行，那也是必败的，你知道，游戏的我们都是非常聪明的。（0,0）（1,2）（3,5）…都是必败态，我们今天要做的就是求前n个必败态。不会？好吧！<br>​    我再告诉你：假设第n个必败态为（a，b）a为前n-1个必败态中没有出现的最小自然数，b=a+n。这下大家应该明白了吧。好吧，我们的任务就的要前n个必败态。规定第0个必败态为（0,0）。 </p><p>输入<br>​    多组数据。<br>​    输入为一个数n（0&lt;=n&lt;=100000）。 </p><p>输出<br>​    按照要求求出前n个必败态。输出格式看下面样例。<br>样例输入 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>样例输出 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(0,0)(1,2)(3,5)(4,7)</span><br><span class="line">(0,0)(1,2)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line">&#125;N;</span><br><span class="line"></span><br><span class="line">N res[<span class="number">100001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">res[<span class="number">0</span>].a = <span class="number">0</span>;</span><br><span class="line">res[<span class="number">0</span>].b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">100001</span>; i++)&#123;</span><br><span class="line">res[i].a = (<span class="number">1</span>+<span class="built_in">sqrt</span>(<span class="number">5</span>))*i/<span class="number">2</span>;</span><br><span class="line">res[i].b = res[i].a+i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"(%d,%d)"</span>, res[i].a, res[i].b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尼姆博弈（Nimm-Game）"><a href="#尼姆博弈（Nimm-Game）" class="headerlink" title="尼姆博弈（Nimm Game）"></a>尼姆博弈（Nimm Game）</h2><blockquote><p>问题模型：有三堆各若干个物品，两个人轮流从某一堆取任意多的物品，规定每次至少取一个，多者不限，最后取光者得胜。</p></blockquote><p>用（a，b，c）表示某种局势，显证（0，0，0）是第一种奇异局势，无论谁面对奇异局势，都必然失败。第二种奇异局势是（0，n，n），只要与对手拿走一样多的物品，最后都将导致（0，0，0）。搞定这个问题需要把必败态的规律找出：(a,b,c)是必败态等价于a^b^c=0(^表示异或运算）。</p><script type="math/tex; mode=display">取石子（二） \\时间限制：3000 ms  |  内存限制：65535 KB \\难度：5</script><p>描述<br>​    小王喜欢与同事玩一些小游戏，今天他们选择了玩取石子。 游戏规则如下：共有N堆石子，已知每堆中石子的数量，并且规定好每堆石子最多可以取的石子数（最少取1颗）。 </p><p>​    两个人轮流取子，每次只能选择N堆石子中的一堆，取一定数量的石子(最少取一个），并且取的石子数量不能多于该堆石子规定好的最多取子数，等哪个人无法取子时就表示此人输掉了游戏。 </p><p>​    假设每次都是小王先取石子，并且游戏双方都绝对聪明，现在给你石子的堆数、每堆石子的数量和每堆石子规定的单次取子上限，请判断出小王能否获胜。 </p><p>输入<br>​    第一行是一个整数T表示测试数据的组数(T&lt;100)<br>​    每组测试数据的第一行是一个整数N(1&lt;N&lt;100),表示共有N堆石子，随后的N行每行表示一堆石子，这N行中每行有两个数整数m,n表示该堆石子共有m个石子，该堆石子每次最多取n个。(0&lt;=m,n&lt;=2^31) </p><p>输出<br>​    对于每组测试数据，输出Win表示小王可以获胜，输出Lose表示小王必然会败。 </p><p>样例输入 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1 </span><br><span class="line">1000 1</span><br><span class="line">2</span><br><span class="line">1 1</span><br><span class="line">1 1</span><br></pre></td></tr></table></figure><p>样例输出 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Lose</span><br><span class="line">Lose</span><br></pre></td></tr></table></figure><p> 提示<br>​    注意下面一组测试数据 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 </span><br><span class="line">1 1</span><br><span class="line">2 2</span><br></pre></td></tr></table></figure><p>​    正确的结果应该是<code>Win</code><br>​    因为小王会先从第二堆石子中取一个石子，使状态变为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> 1 1</span><br><span class="line"> 1 2</span><br></pre></td></tr></table></figure><p>​    这种状态下，无论对方怎么取，小王都能获胜。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line"><span class="keyword">int</span> m,n,g,sum=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;g;</span><br><span class="line"><span class="keyword">while</span>(g--)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n;</span><br><span class="line">sum ^= m%(n+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(sum? <span class="string">"Win"</span>:<span class="string">"Lose"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">取石子（三）\\时间限制：1000 ms  |  内存限制：1000 KB\\难度：6</script><p>描述<br>​    小王喜欢与同事玩一些小游戏，今天他们选择了玩取石子。游戏规则如下：共有N堆石子，已知每堆中石子的数量，两个人轮流取子，每次只能选择N堆石子中的一堆，取一定数量的石子（最少取一个），取过子之后，还可以将该堆石子中剩下的任意多个石子中随意选取几个放到其它的任意一堆或几堆上。等哪个人无法取子时就表示此人输掉了游戏。注意，一堆石子没有子之后，就不能再往此处放石子了。<br>​    假设每次都是小王先取石子，并且游戏双方都绝对聪明，现在给你石子的堆数、每堆石子的数量，请判断出小王能否获胜。<br>​    例如：如果最开始有4堆石子，石子个数分别为3 1 4 2，而小王想决定要先拿走第三堆石子中的两个石子（石子堆状态变为3 1 2 2），然后他可以使石子堆达到的状态有以下几种：<br>​    3 1 2 2（不再移动石子）<br>​    4 1 1 2（移动到第一堆一个）<br>​    3 2 1 2（移动到第二堆一个）<br>​    3 1 1 3（移动到第四堆一个）<br>​    5 1 0 2（全部移动到第一堆）<br>​    3 3 0 2（全部移动到第二堆）<br>​    3 1 0 4（全部移动到最后）</p><p>输入<br>​    可能有多组测试数据(测试数据组数不超过1000)<br>​    每组测试数据的第一行是一个整数，表示N(1&lt;=N&lt;=10)<br>​    第二行是N个整数分别表示该堆石子中石子的数量。（每堆石子数目不超过100）<br>​    当输入的N为0时，表示输入结束</p><p>输出<br>​    对于每组测试数据，输出Win表示小王可以获胜，输出Lose表示小王必然会败。</p><p>样例输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2 1 3</span><br><span class="line">2</span><br><span class="line">1 1</span><br><span class="line">0</span><br></pre></td></tr></table></figure></p><p>样例输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Win</span><br><span class="line">Lose</span><br></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, ans, a;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n), n)&#123;</span><br><span class="line"><span class="keyword">while</span>(n--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">++arr[a];</span><br><span class="line">&#125;</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1001</span>; ++i)</span><br><span class="line"><span class="keyword">if</span>(arr[i] &amp; <span class="number">1</span>)&#123;</span><br><span class="line">ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(ans ? <span class="string">"Win\n"</span> : <span class="string">"Lose\n"</span>);</span><br><span class="line"><span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="keyword">sizeof</span>(arr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天开始总结博弈这块的知识点，博弈论真的是一门非常神奇的学科。博弈是信息学和数学试题中常会出现的一种类型，算法灵活多变是其最大特点，而其中有一类试题更是完全无法用常见的博弈树来进行解答。 &lt;strong&gt;寻找必败态&lt;/strong&gt;即为针对此类试题给出一种解题思路。&lt;/p&gt;
      
    
    </summary>
    
      <category term="学习" scheme="https://hushhw.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法笔记" scheme="https://hushhw.cn/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
      <category term="博弈" scheme="https://hushhw.cn/tags/%E5%8D%9A%E5%BC%88/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="https://hushhw.cn/2018/02/13/11%E6%8E%92%E5%BA%8F/"/>
    <id>https://hushhw.cn/2018/02/13/11排序/</id>
    <published>2018-02-12T18:52:47.000Z</published>
    <updated>2018-02-13T13:17:55.764Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>之前也有总结排序部分，但是总是忘记，这段时间在整理算法笔记，所以借机再整理一份。<br>主要整理的是八大内部排序，分析代码，时间复杂度等</p><p>排序分类见图：（图片来源见图片链接）<br><img src="http://cuijiahua.com/wp-content/uploads/2018/01/algorithm_9_2.png" alt="图片来源见链接"></p><p>各排序算法基本性能：<br><img src="http://cuijiahua.com/wp-content/uploads/2018/01/algorithm_9_3.png" alt="图片来源见链接"></p><h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h2><h3 id="1-1-冒泡排序算法思想及代码实现"><a href="#1-1-冒泡排序算法思想及代码实现" class="headerlink" title="1.1 冒泡排序算法思想及代码实现"></a>1.1 冒泡排序算法思想及代码实现</h3><p>冒泡排序是一种交换排序，基本算法思想是重复访问要排序的数列，每趟排序过程中通过两两比较相邻元素，按一定顺序交换，直到没有在需要交换即数列排序完成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bubbleSort(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>)&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">list</span>.empty())&#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result = <span class="built_in">list</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; result.size()<span class="number">-1</span>; ++i)&#123;<span class="comment">//外层循环仅标记趟数</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"第"</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">"趟排序:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j &lt; result.size()<span class="number">-1</span>; j++)&#123;<span class="comment">//内层循环进行相邻数据交换</span></span><br><span class="line"><span class="keyword">if</span>(result[j+<span class="number">1</span>] &lt; result[j])&#123;</span><br><span class="line">swap(result[j+<span class="number">1</span>], result[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"排序中:"</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>; s&lt;result.size(); s++)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;result[s]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"排序结果:"</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>; s &lt; result.size(); s++)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;result[s]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序前"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.size(); i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; test[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">result = bubbleSort(test);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序后"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; result[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-冒泡排序算法性能"><a href="#1-2-冒泡排序算法性能" class="headerlink" title="1.2 冒泡排序算法性能"></a>1.2 冒泡排序算法性能</h3><p>若文件的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数C和记录移动次数M均达到最小值：Cmin = N - 1, Mmin = 0。所以，<strong>冒泡排序最好时间复杂度为O(N)</strong>。<br>若初始文件是反序的，需要进行 N -1 趟排序。每趟排序要进行 N - i 次关键字的比较(1 ≤ i ≤ N - 1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：<br>$C_{max} = N(N-1)/2 = O(N^2)$<br>$M_{max} = 3N(N-1)/2 = O(N^2)$<br>冒泡排序的最坏时间复杂度为$O(N^2)$。<br>因此，冒泡排序的平均时间复杂度为$O(N^2)$。<br>总结起来，其实就是一句话：当数据越接近正序时，冒泡排序性能越好。</p><p>冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以相同元素的前后顺序并没有改变，所以冒泡排序是一种<strong>稳定排序算法</strong>。</p><h3 id="1-3-冒泡排序优化"><a href="#1-3-冒泡排序优化" class="headerlink" title="1.3 冒泡排序优化"></a>1.3 冒泡排序优化</h3><p>在上述代码中测试的数据会发现，早在第三趟就已经完成排序，但是还是执行了后面的四五六趟排序。对冒泡排序常见的改进方法是加入<strong>标志性变量exchange</strong>，用于标志某一趟排序过程中是否有数据交换。如果进行<strong>某一趟排序时并没有进行数据交换，则说明所有数据已经有序</strong>，可立即结束排序，避免不必要的比较过程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bubbleSort(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>)&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">list</span>.empty())&#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result = <span class="built_in">list</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; result.size()<span class="number">-1</span>; ++i)&#123;<span class="comment">//外层循环仅标记趟数</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"第"</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">"趟排序:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">/*----------冒泡排序优化代码1-----------*/</span></span><br><span class="line"><span class="keyword">bool</span> bChanged = <span class="literal">false</span>;<span class="comment">//交换标记</span></span><br><span class="line"><span class="comment">/*----------冒泡排序优化代码1-----------*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j &lt; result.size()<span class="number">-1</span>; j++)&#123;<span class="comment">//内层循环进行相邻数据交换</span></span><br><span class="line"><span class="keyword">if</span>(result[j+<span class="number">1</span>] &lt; result[j])&#123;</span><br><span class="line">swap(result[j+<span class="number">1</span>], result[j]);</span><br><span class="line"><span class="comment">/*----------冒泡排序优化代码2-----------*/</span></span><br><span class="line">bChanged = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">/*----------冒泡排序优化代码2-----------*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"排序中:"</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>; s&lt;result.size(); s++)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;result[s]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*----------冒泡排序优化代码3-----------*/</span></span><br><span class="line"><span class="keyword">if</span>(bChanged == <span class="literal">false</span>)<span class="comment">//如果标志为false,说明本轮遍历没有进行数据交换，即说明已经有序</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">/*----------冒泡排序优化代码3-----------*/</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"排序结果:"</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>; s &lt; result.size(); s++)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;result[s]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序前"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.size(); i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; test[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">result = bubbleSort(test);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序后"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; result[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-快速排序"><a href="#2-快速排序" class="headerlink" title="2. 快速排序"></a>2. 快速排序</h2><h3 id="2-1-快速排序算法思想及代码实现"><a href="#2-1-快速排序算法思想及代码实现" class="headerlink" title="2.1 快速排序算法思想及代码实现"></a>2.1 快速排序算法思想及代码实现</h3><p>快速排序也是一种交换排序。快速排序由C. A. R. Hoare在1962年提出。</p><p>它的基本思想是：通过一趟排序将要排序的数据<strong>分割</strong>成独立的两部分：<strong>分割点左边都是比它小的数，右边都是比它大的数</strong>。然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><p>算法步骤：</p><ul><li>选取主元</li><li>小于等于主元的放左边，大于等于主元的放右边</li><li>分别对左右边递归，即重复（1）、（2）步</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">division</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">list</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> base = <span class="built_in">list</span>[left];</span><br><span class="line"><span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line"><span class="keyword">while</span>(left &lt; right &amp;&amp; <span class="built_in">list</span>[right]&gt;=base)<span class="comment">//从序号右端开始向左遍历，直到找到小于base的数</span></span><br><span class="line">right--;</span><br><span class="line"><span class="built_in">list</span>[left] = <span class="built_in">list</span>[right];<span class="comment">//找到比base小的元素，将这个元素放到最左边的位置</span></span><br><span class="line"><span class="keyword">while</span>(left &lt; right &amp;&amp; <span class="built_in">list</span>[left]&lt;=base) <span class="comment">//从序号左端开始向右遍历，直到找到大于base的数</span></span><br><span class="line">left++;</span><br><span class="line"><span class="built_in">list</span>[right] = <span class="built_in">list</span>[left];<span class="comment">//找到比base大的元素，将这个元素放到最右边的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>[left] = base;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"每一轮："</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>.size(); i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">list</span>[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">list</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(left &lt; right)&#123;<span class="comment">//左下标一定小于右下标，否则越界</span></span><br><span class="line"><span class="keyword">int</span> base = division(<span class="built_in">list</span>, left, right);<span class="comment">//对数组进行分割，去除下次分割的基准标号</span></span><br><span class="line">QuickSort(<span class="built_in">list</span>, left, base<span class="number">-1</span>);<span class="comment">//左</span></span><br><span class="line">QuickSort(<span class="built_in">list</span>, base+<span class="number">1</span>, right);<span class="comment">//右</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test(arr, arr + <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序前"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.size(); i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; test[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result = test;</span><br><span class="line"></span><br><span class="line">QuickSort(result, <span class="number">0</span>, result.size() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序后"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; result[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-快速排序算法性能"><a href="#2-2-快速排序算法性能" class="headerlink" title="2.2 快速排序算法性能"></a>2.2 快速排序算法性能</h3><p>时间复杂度上：</p><p>最好的情况，每次我们运行一次分区，我们会把一个数组分为两个几近相等的片段。这个意思就是每次递归调用处理一半大小的数组。则会有关系式：</p><script type="math/tex; mode=display">T(n)=2T(\frac n 2)+O(n)</script><p>解出 $T_{best}(n)=O(nlogn)$。</p><p>最坏的情况，在分割后，两子数组总是拥有各为 1 和 n-1 长度的数组，则递归关系式变为：</p><script type="math/tex; mode=display">T(n)=T(n−1)+O(n)+O(1)=T(n−1)+O(n)</script><p>解出 $T_{worst}(n)=O(n^2)$。</p><p>空间复杂度上：</p><p>快速排序在每次分割的过程中，需要 1 个空间存储基准值。而快速排序的大概需要Nlog2N次的分割处理，所以占用空间也是 Nlog2N 个。</p><p>算法稳定性上：</p><p>在快速排序中，相等元素可能会因为分区而交换顺序，所以它是不稳定的算法。</p><h3 id="2-3-快速排序细节优化"><a href="#2-3-快速排序细节优化" class="headerlink" title="2.3 快速排序细节优化"></a>2.3 快速排序细节优化</h3><p>我们知道主元的大小直接决定快排的效率，因为数组的划分需要依靠主元，理想状态下，给定的主元正好可以把数组分为长度相等的两个子数组，但找到并确定这样的主元还需要耗费额外的时间，如此一来，得不偿失。</p><p>快速排序算法有三种选择主元的方法：</p><ol><li>取序列中的第一个或最后一个元素作为主元<em>（前面实现的就是这种）</em></li><li>取序列中任意一个元素作为主元</li><li>选取左，中，右三个元素的 “中值” 为主元</li></ol><h2 id="3-直接插入排序"><a href="#3-直接插入排序" class="headerlink" title="3. 直接插入排序"></a>3. 直接插入排序</h2><h3 id="3-1-插入排序算法思想及代码实现"><a href="#3-1-插入排序算法思想及代码实现" class="headerlink" title="3.1 插入排序算法思想及代码实现"></a>3.1 插入排序算法思想及代码实现</h3><p>每一趟将一个待排序的记录，按照其关键字的大小插入到有序队列的合适位置里，直到全部插入完成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; insertSort(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>)&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">list</span>.empty())&#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">result = <span class="built_in">list</span>;</span><br><span class="line"><span class="comment">// 第1个数肯定是有序的，从第2个数开始遍历，依次插入有序序列</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line"><span class="comment">// 取出第i个数，和前i-1个数比较后，插入合适位置</span></span><br><span class="line"><span class="keyword">int</span> temp = result[i];</span><br><span class="line"><span class="comment">// 因为前i-1个数都是从小到大的有序序列，所以只要当前比较的数(res[j])比temp大，就把这个数后移一位</span></span><br><span class="line"><span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (j; j &gt;= <span class="number">0</span> &amp;&amp; result[j] &gt; temp; j--)&#123;</span><br><span class="line">result[j + <span class="number">1</span>] = result[j];</span><br><span class="line">&#125;</span><br><span class="line">result[j + <span class="number">1</span>] = temp;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"第"</span>&lt;&lt;i&lt;&lt;<span class="string">"轮:"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; result[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序前"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.size(); i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; test[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">result = insertSort(test);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序后"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; result[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-插入排序算法性能"><a href="#3-2-插入排序算法性能" class="headerlink" title="3.2 插入排序算法性能"></a>3.2 插入排序算法性能</h3><p>那么它的算法复杂度如下（参考<a href="https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F#.E7.AE.97.E6.B3.95.E5.A4.8D.E6.9D.82.E5.BA.A6" target="_blank" rel="noopener">维基百科</a>）：</p><ul><li>时间复杂度<ul><li>最好情况，序列是升序排列，在这种情况下，只需进行 $n-1$ 比较，即 $T_{best}(n)=O(n)$；</li><li>最坏情况，序列是降序排列，那么此时需要进行的比较共有 $\frac 12n(n−1)$ 次，即 $T_{worse}(n)=O(n^2)$；</li><li>平均情况，为 $T_{avg}(n)=O(n^2)$。</li></ul></li><li>空间复杂度<ul><li>由程序很容易得我们在排序过程中，需要一个临时变量存储要插入的值，所以空间复杂度为 S(n)=O(1)。</li></ul></li></ul><p>它的算法稳定性：直接插入排序的过程中，不需要改变相等数值元素的位置，所以它是<strong>稳定的</strong>算法。</p><h2 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4. 希尔排序"></a>4. 希尔排序</h2><h3 id="4-1-希尔排序算法思想及代码实现"><a href="#4-1-希尔排序算法思想及代码实现" class="headerlink" title="4.1 希尔排序算法思想及代码实现"></a>4.1 希尔排序算法思想及代码实现</h3><p>希尔(Shell)排序又称为<strong>缩小增量排序</strong>，它是一种<strong>插入排序</strong>。它<strong>是直接插入排序算法的一种威力加强版</strong>。该方法因DL．Shell于1959年提出而得名。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：（以下摘自<a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">维基百科</a>）</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到<a href="https://zh.wikipedia.org/w/index.php?title=%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">线性排序</a>的效率</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</li></ul><p>希尔排序的<strong>基本思想</strong>是：</p><p>把记录按<strong>步长</strong> gap 分组，对每组记录采用<strong>直接插入排序</strong>方法进行排序。<br>随着<strong>步长逐渐减小</strong>，所分成的组包含的记录越来越多，当步长的值减小到 <strong>1</strong> 时，整个数据合成为一组，构成一组有序记录，则完成排序。</p><p>举例：假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样：</p><p><code>13 14 94 33 82</code><br><code>25 59 94 65 23</code><br><code>45 27 73 25 39</code><br><code>10</code></p><p>然后我们对每列进行排序：</p><p><code>10 14 73 25 23</code><br><code>13 27 94 33 39</code><br><code>25 59 94 65 82</code><br><code>45</code></p><p>将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ].这时10已经移至正确位置了，然后再以3为步长进行排序：</p><p><code>10 14 73</code><br><code>25 23 13</code><br><code>27 94 33</code><br><code>39 25 59</code><br><code>94 65 82</code><br><code>45</code></p><p>排序之后变为：</p><p><code>10 14 13</code><br><code>25 23 33</code><br><code>27 25 59</code><br><code>39 65 73</code><br><code>45 94 82</code><br><code>94</code></p><p>最后以1步长进行排序（此时就是简单的插入排序了）。</p><p>可想而知，步长的选择是希尔排序的重要部分。算法最开始以一定的步长进行排序，然后会继续以更小的步长进行排序，最终算法以步长为 1 进行排序。当步长为 1 时，算法变为直接插入排序，这就保证了数据一定会被全部排序。</p><p>下面以$\frac n{2^i}$作为步长为例进行讲解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ShellSort(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>)&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">result = <span class="built_in">list</span>;</span><br><span class="line"><span class="keyword">int</span> n = result.size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> gap = n &gt;&gt; <span class="number">1</span>; gap &gt; <span class="number">0</span>; gap &gt;&gt;= <span class="number">1</span>)&#123;<span class="comment">//对n进行二分除二处理</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=gap; i&lt;n; i++)&#123;</span><br><span class="line"><span class="keyword">int</span> temp = result[i];<span class="comment">//记录i所在的数</span></span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">for</span>(j = i-gap; j&gt;=<span class="number">0</span> &amp;&amp; result[j]&gt;temp; j -= gap)&#123;<span class="comment">//把相距为gap的i,j所在数字比较，相当于隔行判断</span></span><br><span class="line">result[j+gap] = result[j];</span><br><span class="line">&#125;</span><br><span class="line">result[j+gap] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序前"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.size(); i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; test[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">result = ShellSort(test);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序后"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; result[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-希尔排序算法性能"><a href="#4-2-希尔排序算法性能" class="headerlink" title="4.2 希尔排序算法性能"></a>4.2 希尔排序算法性能</h3><p>那么它的算法复杂度如下（参考<a href="https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F#.E7.AE.97.E6.B3.95.E5.A4.8D.E6.9D.82.E5.BA.A6" target="_blank" rel="noopener">维基百科</a>）：</p><p>步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。</p><p>算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为1进行排序。当步长为1时，算法变为插入排序，这就保证了数据一定会被排序。<br>Donald Shell 最初建议步长选择为N/2并且对步长取半直到步长达到1。虽然这样取可以比O(N2)类的算法（插入排序）更好，但这样仍然有减少平均时间和最差时间的余地。可能希尔排序最重要的地方在于当用较小步长排序后，以前用的较大步长仍然是有序的。比如，如果一个数列以步长5进行了排序然后再以步长3进行排序，那么该数列不仅是以步长3有序，而且是以步长5有序。如果不是这样，那么算法在迭代过程中会打乱以前的顺序，那就</p><p>不会以如此短的时间完成排序了。</p><div class="table-container"><table><thead><tr><th style="text-align:center">步长序列</th><th style="text-align:center">最坏情况下复杂度</th></tr></thead><tbody><tr><td style="text-align:center">$\frac n{2^i}$</td><td style="text-align:center">$O(n^2)$</td></tr><tr><td style="text-align:center">$2^i-1$</td><td style="text-align:center">$O(n^{\frac 32})$</td></tr><tr><td style="text-align:center">$2^i3^i$</td><td style="text-align:center">$O(nlog^2n)$</td></tr></tbody></table></div><p>已知的最好步长序列是由Sedgewick提出的(1, 5, 19, 41, 109,…)，该序列的项来自$9<em>4^i-9</em>2^i$和$2^{i+2}*(2^{i+2}-3)+1$这两个算式。这项研究也表明“比较在希尔排序中是最主要的操作，而不是交换。”用这样步长序列的希尔排序比插入排序和堆排序都要快，甚至在小数组中比快速排序还快，但是在涉及大量数据时希尔排序还是比快速排序慢。</p><p>它的算法稳定性：希尔排序中相等数据可能会交换位置，所以希尔排序是<strong>不稳定</strong>的算法。</p><h3 id="4-3-希尔排序和直接插入排序比较"><a href="#4-3-希尔排序和直接插入排序比较" class="headerlink" title="4.3 希尔排序和直接插入排序比较"></a>4.3 希尔排序和直接插入排序比较</h3><p>直接插入排序是<strong>稳定的</strong>；而希尔排序是<strong>不稳定</strong>的。</p><p>直接插入排序更适合于原始记录基本<strong>有序</strong>的集合。</p><p>希尔排序的比较次数和移动次数都要比直接插入排序少，当N越大时，效果越明显。   </p><p>在希尔排序中，增量序列gap的取法必须满足：<strong>最后一个步长必须是1</strong>。</p><p>直接插入排序也<strong>适用于链式存储结构</strong>；希尔排序<strong>不适用于链式结构</strong>。</p><h2 id="5-简单选择排序"><a href="#5-简单选择排序" class="headerlink" title="5. 简单选择排序"></a>5. 简单选择排序</h2><h3 id="5-1-简单选择排序算法思想及代码实现"><a href="#5-1-简单选择排序算法思想及代码实现" class="headerlink" title="5.1 简单选择排序算法思想及代码实现"></a>5.1 简单选择排序算法思想及代码实现</h3><p>简单选择排序是一种<strong>选择排序</strong>。</p><p><strong>选择排序</strong>：每趟从待排序的记录中选出关键字最小的记录，顺序放在已排序的记录序列末尾，直到全部排序结束为止。</p><p>简单排序很简单，它的大致处理流程为：</p><ul><li>从待排序序列中，找到关键字最小的元素；</li><li>如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；</li><li>从余下的 N - 1 个元素中，找出关键字最小的元素，重复(1)、(2)步，直到排序结束。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; SelectSort(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>)&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">result = <span class="built_in">list</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;result.size(); i++)&#123;</span><br><span class="line"><span class="keyword">int</span> index = i;<span class="comment">//标记第一个位置</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;result.size(); j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(result[index] &gt; result[j])</span><br><span class="line">index = j;<span class="comment">//如果比index位置上的数字小，就标记该数字</span></span><br><span class="line">&#125;</span><br><span class="line">swap(result[i], result[index]);<span class="comment">//循环结束后把标记的最小数字所在位置index和i位置交换</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"第"</span> &lt;&lt; i + <span class="number">1</span>&lt;&lt; <span class="string">"趟:\t"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; result[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序前"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.size(); i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; test[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">result = SelectSort(test);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序后"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; result[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-简单选择排序算法性能"><a href="#5-2-简单选择排序算法性能" class="headerlink" title="5.2 简单选择排序算法性能"></a>5.2 简单选择排序算法性能</h3><p>那么它的算法复杂度如下：</p><ul><li><p>时间复杂度</p><p>简单选择排序的比较次数与序列的初始排序无关。 假设待排序的序列有 N 个元素，则比较次数总是$\frac {N (N - 1) }2$。</p><p>简单排序的时间复杂度为 $O(N^2)$。</p></li><li><p>空间复杂度</p><ul><li>由程序很容易得我们在排序过程中，需要一个临时变量存储要插入的值，所以空间复杂度为 S(n)=O(1)。</li></ul></li></ul><h2 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6. 堆排序"></a>6. 堆排序</h2><h3 id="6-1-堆排序算法思想及代码实现"><a href="#6-1-堆排序算法思想及代码实现" class="headerlink" title="6.1 堆排序算法思想及代码实现"></a>6.1 堆排序算法思想及代码实现</h3><p>堆排序是利用堆的性质进行的一种选择排序。下面先讨论一下堆。</p><p>堆实际上是一棵完全二叉树，其满足性质：任何一结点大于等于或者小于等于其左右子树结点。</p><p>堆分为大顶堆和小顶堆，满足 “任何一结点大于等于其左右子树结点” 的称为大顶堆，满足 “任何一结点小于等于其左右子树结点” 的称为小顶堆。由上述性质可知：大顶堆的堆顶肯定是最大的，小顶堆的堆顶是最小的。</p><p>堆排序可以归纳出两个操作：</p><ul><li>根据初始数组去<strong>构造初始堆</strong>（构建一个完全二叉树，保证所有的父结点都比它的孩子结点数值大）。</li><li>每次<strong>交换第一个和最后一个元素，输出最后一个元素</strong>（最大值），然后把剩下元素<strong>重新调整</strong>为大根堆。</li></ul><p>下面举个例子（资源来自<a href="http://www.cnblogs.com/dolphin0520/archive/2011/10/06/2199741.html" target="_blank" rel="noopener">堆排序 - 海子</a>）来说明堆排序的过程（以升序为例）：</p><p>（1）<br><img src="https://61mon.com/images/illustrations/Sort/3.jpg" alt="img"></p><p>给定整型数组：{16, 7, 3, 20, 17, 8}，根据该数组 “构建” 完全二叉树（并不是真的写代码去构建，只是把数组看成完全二叉树去操作）。</p><p>程序从最后一个非叶子结点开始，即 3。判断其左右孩子：8，8 比 3 大，把 8 调整上去。</p><p>（2）<br><img src="https://61mon.com/images/illustrations/Sort/4.jpg" alt="img"></p><p>3 结点下无孩子，判断结束。</p><p>继续往前一步，至 7 结点，判断其左右孩子：20 和 17，20 是最大的，将其调整上去。</p><p>（3）<br><img src="https://61mon.com/images/illustrations/Sort/5.jpg" alt="img"></p><p>7 结点下无孩子，判断结束。</p><p>继续往前一步，至 16 结点，判断其左右孩子：20 和 8，20 是最大的，将其调整上去。</p><p>（4）<br><img src="https://61mon.com/images/illustrations/Sort/6.jpg" alt="img"></p><p>判断 16 结点下左右孩子：7 和 17，17 是最大的，将其调整上去。</p><p>（5）<br><img src="https://61mon.com/images/illustrations/Sort/7.jpg" alt="img"></p><p>16 结点下无孩子，判断结束。</p><p>遍历已至头部，结束。</p><p>（6）至此数组已经满足大顶堆的性质，接下来的操作就很简单了。<br><img src="https://61mon.com/images/illustrations/Sort/8.jpg" alt="img"></p><p>看完上面所述的流程你至少有两个疑问：</p><ul><li>如何确定最后一个非叶子结点？</li></ul><p>其实这是有一个公式的，设二叉树结点总数为 n，则最后一个非叶子结点是第$\frac n2$个。</p><ul><li>数组当中如何确定当前结点的左右孩子位置？</li></ul><p>设当前结点下标是 i，则其左孩子的下标是 2i，右孩子的下标是 2i+1。请注意：这是建立在数组下标从 1 开始的情况。若数组下标从 0 开始，则其左右孩子下标还各需多加一个 1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">list</span>, <span class="keyword">int</span> start, <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> parent = start;<span class="comment">//父节点</span></span><br><span class="line"><span class="keyword">int</span> child = <span class="number">2</span> * parent + <span class="number">1</span>;<span class="comment">// 先获得左孩子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (child &lt;= length)&#123;</span><br><span class="line"><span class="comment">// 如果有右子节点，并且右子节点的值大于左子节点，则选取右子节点，否则选取左节点</span></span><br><span class="line"><span class="keyword">if</span> (child + <span class="number">1</span> &lt;= length &amp;&amp; <span class="built_in">list</span>[child] &lt; <span class="built_in">list</span>[child + <span class="number">1</span>])&#123;</span><br><span class="line">child++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果父节点大于孩子节点则代表调整完毕，直接跳出函数</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">list</span>[parent] &gt; <span class="built_in">list</span>[child])&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123; <span class="comment">//否则交换父子内容再继续子节点和孙节点比较</span></span><br><span class="line">swap(<span class="built_in">list</span>[parent], <span class="built_in">list</span>[child]);</span><br><span class="line">parent = child;<span class="comment">//父更新为子节点位置</span></span><br><span class="line">child = parent*<span class="number">2</span>+<span class="number">1</span>;<span class="comment">//子节点更新为孙节点位置</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; HeadSort(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> length = <span class="built_in">list</span>.size();</span><br><span class="line"><span class="comment">// 循环建立初始堆，i从最后一个父节点开始</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = length/<span class="number">2</span><span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">HeapAdjust(<span class="built_in">list</span>, i, length<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>.size(); i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">list</span>[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// 进行n-1次循环，完成排序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line"><span class="comment">// 最后一个元素和第一元素进行交换</span></span><br><span class="line">swap(<span class="built_in">list</span>[<span class="number">0</span>], <span class="built_in">list</span>[i]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 筛选 R[0] 结点，得到i-1个结点的堆</span></span><br><span class="line">HeapAdjust(<span class="built_in">list</span>, <span class="number">0</span>, i<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"第"</span> &lt;&lt; length - i &lt;&lt; <span class="string">"趟排序:"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>.size(); i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">list</span>[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序前:"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.size(); i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; test[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">result = HeadSort(test);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序后:"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; result[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-堆排序算法性能"><a href="#6-2-堆排序算法性能" class="headerlink" title="6.2 堆排序算法性能"></a>6.2 堆排序算法性能</h3><p>堆的存储表示是<strong>顺序的</strong>。因为堆所对应的二叉树为完全二叉树，而完全二叉树通常采用顺序存储方式。</p><p>当想得到一个序列中第<strong>k</strong>个最小的元素之前的部分排序序列，最好采用堆排序。</p><p>时间复杂度为 $O(nlogn)$，证明如下。</p><p>首先计算建堆的时间，也就是下面的代码，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环建立初始堆，i从最后一个父节点开始</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = length/<span class="number">2</span><span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">HeapAdjust(<span class="built_in">list</span>, i, length<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>n 个结点，从第 0 层至第 $log_2n$ 层。对于第$i$层的$2^i$个点如果需要往下走$log_2n−i$步，那么把走的所有步相加得， </p><script type="math/tex; mode=display">T(n) = \sum _{i=0}^{i=log_2n}{2^i(log_2n-i)}= 2n-log_2n-2<2n=O(n)</script><p>接下来就是排序的时间，即下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line"><span class="comment">// 最后一个元素和第一元素进行交换</span></span><br><span class="line">swap(<span class="built_in">list</span>[<span class="number">0</span>], <span class="built_in">list</span>[i]);</span><br><span class="line"><span class="comment">// 筛选 R[0] 结点，得到i-1个结点的堆</span></span><br><span class="line">HeapAdjust(<span class="built_in">list</span>, <span class="number">0</span>, i<span class="number">-1</span>);</span><br></pre></td></tr></table></figure><p>HeapAdjust() 耗时$logn$，共$n$次，故排序时间为$O(nlogn)$。</p><p>综上所述，堆排序时间复杂度为$T(n)=O(n)+O(nlogn)=O(nlogn)$。</p><p>算法稳定度：</p><p>堆排序是一种<strong>不稳定</strong>的排序方法。</p><p>因为在堆的调整过程中，关键字进行比较和交换所走的是该结点到叶子结点的一条路径，因此对于相同的关键字就可能出现排在后面的关键字被交换到前面来的情况。</p><h2 id="7-归并排序"><a href="#7-归并排序" class="headerlink" title="7. 归并排序"></a>7. 归并排序</h2><h3 id="7-1-归并排序算法思想及代码实现"><a href="#7-1-归并排序算法思想及代码实现" class="headerlink" title="7.1 归并排序算法思想及代码实现"></a>7.1 归并排序算法思想及代码实现</h3><p>归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用<strong>分治法（Divide and Conquer）</strong>的一个非常典型的应用。</p><p>将待排序序列R[0…n-1]看成是n个长度为1的有序序列，将相邻的有序表成对归并，得到n/2个长度为2的有序表；将这些有序序列再次归并，得到n/4个长度为4的有序序列；如此反复进行下去，最后得到一个长度为n的有序序列。</p><p>综上可知：</p><p>归并排序其实要做两件事：</p><p>（1）“分解”——将序列每次<strong>折半划分</strong>。</p><p>（2）“合并”——将划分后的序列段<strong>两两合并后排序</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;input, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=left;</span><br><span class="line"><span class="keyword">int</span> j=mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=right)&#123;</span><br><span class="line"><span class="keyword">if</span>(input[i]&lt;=input[j])&#123;</span><br><span class="line">temp[k++] = input[i++];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">temp[k++] = input[j++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid)</span><br><span class="line">temp[k++]=input[i++];</span><br><span class="line"><span class="keyword">while</span>(j&lt;=right)</span><br><span class="line">temp[k++]=input[j++];</span><br><span class="line">k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">input[left++] = temp[k++];</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;input[left<span class="number">-1</span>]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;input, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">MergeSort(input, left, mid, temp);</span><br><span class="line">MergeSort(input, mid+<span class="number">1</span>, right, temp);</span><br><span class="line">Merge(input, left, mid ,right, temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序前:"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.size(); i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; test[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result = test;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp(result.size());<span class="comment">// 在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间</span></span><br><span class="line">MergeSort(result, <span class="number">0</span>, result.size()<span class="number">-1</span>, temp);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序后:"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; result[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-归并排序算法性能"><a href="#7-2-归并排序算法性能" class="headerlink" title="7.2 归并排序算法性能"></a>7.2 归并排序算法性能</h3><p>归并排序的时间复杂度分析：MergeSort()函数用于数组划分，Merge()函数用于合并。</p><ul><li>合并函数Merge()的时间复杂度为$O(n)$，因为代码中有2个长度为n的循环（非嵌套）</li><li>划分函数MergeSort()中，简单的分析一下元素长度为n的归并排序所消耗的时间为T(n)：调用MergeSort()函数划分两部分，那每一小部分所花销的时间则是$T[\frac n2]$</li></ul><p>最后两部分合并:（用迭代法进行推导）</p><script type="math/tex; mode=display">\begin{align}T[n]& = 2T[\frac n2]+O(n)\\令：n=\frac n2\quad &=2(2T[\frac n4]+\frac n2)+n\\&=2^2T[\frac n{2^2}]+2n\\令：n=\frac n{2^2}\quad&=2^2(2T[\frac n{2^3}]+\frac n{2^2})+2n\\&=2^3T[\frac n{2^3}]+3n\\&……\\令：n=\frac n{2^{m-1}}\quad&=2^mT[1]+mn\\经过m次递归后，&当最后平分的不能再平分\\到最后得到T[1]时，&说明这个公式已经迭代完了（T[1]是常量了）\\得到：T[\frac n{2^m}]=T[1]\quad &==>\ n=2^m\quad ==>\ m=logn\\T[n]&=2^mT[1]+mn\qquad 其中m=logn；\\T[n]&=2^{logn}T[1]+nlogn\\&=nT[1]+nlogn\\&=n+nlogn\end{align}</script><p>综上所述：归并排序时间复杂度为：$O(nlogn)$。</p><p>因为不管元素在什么情况下都要做这些步骤，所以花销的时间是不变的，所以该算法的最优时间复杂度和最差时间复杂度及平均时间复杂度都是一样的为：$O(nlogn)$。</p><p>归并排序的空间复杂度：</p><p>归并的空间复杂度就是那个临时的数组和递归时压入栈的数据占用的空间：n+logn；所以空间复杂度为: O(n)</p><p>归并排序的算法稳定度：</p><p>在归并排序中，相等的元素的顺序不会改变，所以它是<strong>稳定的</strong>算法。</p><h2 id="8-基数排序"><a href="#8-基数排序" class="headerlink" title="8. 基数排序"></a>8. 基数排序</h2><h3 id="8-1-基数排序算法思想及代码实现"><a href="#8-1-基数排序算法思想及代码实现" class="headerlink" title="8.1 基数排序算法思想及代码实现"></a>8.1 基数排序算法思想及代码实现</h3><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p><p>算法步骤：</p><ul><li>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。</li><li>从最低位开始，依次进行一次排序。</li><li>这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</li></ul><p>基数排序的方式可以采用 LSD（Least significant digital）或 MSD（Most significant digital），LSD 的排序方式由键值的最右边开始，而 MSD 则相反，由键值的最左边开始。</p><p>不妨通过一个具体的实例来展示一下基数排序是如何进行的。 设有一个初始序列为: R {50, 123, 543, 187, 49, 30, 0, 2, 11, 100}。</p><p>我们知道，任何一个阿拉伯数，它的各个位数上的基数都是以 0~9 来表示的，所以我们不妨把 0~9 视为 10 个桶。</p><p>我们先根据序列的个位数的数字来进行分类，将其分到指定的桶中。例如：R[0] = 50，个位数上是 0，将这个数存入编号为 0 的桶中。</p><p><img src="https://61mon.com/images/illustrations/Sort/10.png" alt="img"></p><p>分类后，我们在从各个桶中，将这些数按照从编号 0 到编号 9 的顺序依次将所有数取出来。这时，得到的序列就是个位数上呈递增趋势的序列。</p><p>按照个位数排序： {50, 30, 0, 100, 11, 2, 123, 543, 187, 49}。</p><p>接下来，可以对十位数、百位数也按照这种方法进行排序，最后就能得到排序完成的序列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求出数组中最大数的位数的函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxBit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input)</span></span>&#123;</span><br><span class="line"><span class="comment">// 数组最大值</span></span><br><span class="line"><span class="keyword">int</span> max_data = input[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; input.size(); i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (input[i] &gt; max_data)&#123;</span><br><span class="line">max_data = input[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"max_data:"</span>&lt;&lt;max_data&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// 数组最大值的位数</span></span><br><span class="line"><span class="keyword">int</span> bits_num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (max_data)&#123;</span><br><span class="line">bits_num++;</span><br><span class="line">max_data /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"bits_num:"</span>&lt;&lt;bits_num&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> bits_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; RadixSort(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">int</span> n)&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bucket(n);<span class="comment">//存储排序过程中的数据</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; count(<span class="number">10</span>);<span class="comment">//位计数器，从第0个元素到第9个元素依次用来记录当前比较位是0的有多少个...是9的有多少个数</span></span><br><span class="line"><span class="keyword">int</span> bits_num = MaxBit(input); <span class="comment">//求出数组中最大数的位数的函数</span></span><br><span class="line"><span class="keyword">int</span> radix = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 从低位往高位循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">1</span>; d &lt;= bits_num; d++)&#123; </span><br><span class="line"><span class="comment">// 计数器清0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">count[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 统计各个桶中的个数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="keyword">int</span> k=(input[i]/radix)%<span class="number">10</span>;<span class="comment">//取每个数字的末尾</span></span><br><span class="line">count[k]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"before:"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;count[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"after:   "</span>;</span><br><span class="line"><span class="comment">//索引重分配</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">count[i] += count[i - <span class="number">1</span>];<span class="comment">//count[i]表示第i个桶的右边界索引</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;count[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//放入临时数组，从右到左扫描，保证排序稳定性</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line"><span class="keyword">int</span> k = (input[i]/radix)%<span class="number">10</span>;</span><br><span class="line">bucket[count[k] - <span class="number">1</span>] = input[i];</span><br><span class="line">count[k]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"input:"</span>;</span><br><span class="line"><span class="comment">// 临时数组复制到 input 中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">input[i] = bucket[i];</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;input[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">radix *= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> input;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">50</span>, <span class="number">123</span>, <span class="number">543</span>, <span class="number">187</span>, <span class="number">49</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">100</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序前:"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.size(); i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; test[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result = test;</span><br><span class="line">result = RadixSort(result, result.size());</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序后:"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; result[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-基数排序算法性能"><a href="#8-2-基数排序算法性能" class="headerlink" title="8.2 基数排序算法性能"></a>8.2 基数排序算法性能</h3><p>基数排序的时间复杂度是$O(k⋅n)$，其中$n$是排序元素个数，$k$是最大的数字位数。</p><p>空间复杂度是使用了两个临时的数组：10 + length；所以空间复杂度：$O(n)$</p><p>在基数排序过程中，每次都是将当前位数上相同数值的元素统一“装桶”，并不需要交换位置。所以基数排序是<strong>稳定</strong>的算法。</p><blockquote><p>本文参考整理自：</p><p><a href="http://cuijiahua.com/blog/2018/01/alogrithm_9.html" target="_blank" rel="noopener">http://cuijiahua.com/blog/2018/01/alogrithm_9.html</a></p><p><a href="https://61mon.com/index.php/archives/193/" target="_blank" rel="noopener">https://61mon.com/index.php/archives/193/</a></p><p><a href="http://www.cnblogs.com/jingmoxukong/p/4311237.html" target="_blank" rel="noopener">http://www.cnblogs.com/jingmoxukong/p/4311237.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;排序算法&quot;&gt;&lt;a href=&quot;#排序算法&quot; class=&quot;headerlink&quot; title=&quot;排序算法&quot;&gt;&lt;/a&gt;排序算法&lt;/h1&gt;&lt;p&gt;之前也有总结排序部分，但是总是忘记，这段时间在整理算法笔记，所以借机再整理一份。&lt;br&gt;主要整理的是八大内部排序，分析代码，
      
    
    </summary>
    
      <category term="学习" scheme="https://hushhw.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法笔记" scheme="https://hushhw.cn/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
      <category term="排序" scheme="https://hushhw.cn/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>CTGUOJ刷题目录</title>
    <link href="https://hushhw.cn/2018/02/12/10CTGUOJ/"/>
    <id>https://hushhw.cn/2018/02/12/10CTGUOJ/</id>
    <published>2018-02-11T20:12:34.000Z</published>
    <updated>2018-02-11T20:15:06.964Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CTGUOJ"><a href="#CTGUOJ" class="headerlink" title="CTGUOJ"></a>CTGUOJ</h1><p>Record my code in CTGUOJ</p><p>所有代码都在：<a href="https://github.com/hushhw/CTGUOJ" target="_blank" rel="noopener">https://github.com/hushhw/CTGUOJ</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CTGUOJ&quot;&gt;&lt;a href=&quot;#CTGUOJ&quot; class=&quot;headerlink&quot; title=&quot;CTGUOJ&quot;&gt;&lt;/a&gt;CTGUOJ&lt;/h1&gt;&lt;p&gt;Record my code in CTGUOJ&lt;/p&gt;
&lt;p&gt;所有代码都在：&lt;a href=&quot;https:
      
    
    </summary>
    
      <category term="学习" scheme="https://hushhw.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="OJ刷题" scheme="https://hushhw.cn/categories/%E5%AD%A6%E4%B9%A0/OJ%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="OJ" scheme="https://hushhw.cn/tags/OJ/"/>
    
      <category term="刷题" scheme="https://hushhw.cn/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>并查集的使用及实现</title>
    <link href="https://hushhw.cn/2018/02/11/09%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>https://hushhw.cn/2018/02/11/09并查集/</id>
    <published>2018-02-11T10:17:42.000Z</published>
    <updated>2018-02-12T18:53:56.604Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>详见这篇博文：<a href="http://blog.csdn.net/niushuai666/article/details/6662911" target="_blank" rel="noopener">超有爱的并查集</a></p><p>并查集是一种用来管理元素分组情况的数据结构。并查集可以高效地进行如下操作。不过需要注意并查集虽然可以进行合并操作，但是无法进行分割操作。</p><ul><li>查询元素a和元素b是否属于同一组。</li><li>合并元素a和元素b所在的组。</li></ul><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>并查集由三部分组成：一个数组和两个函数</p><ul><li>数组pre[]，用来存储前导点</li><li>find()函数，用于寻找前导点</li><li>join()函数，用于合并线路</li></ul><p>具体代码实现：</p><ol><li><p>初始化pre[]数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pre[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123; <span class="comment">//初始化pre数组，让他们的前导点都记录为自己，即自己为根节点</span></span><br><span class="line">pre[i]=i; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>find()函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> r=x;</span><br><span class="line"><span class="keyword">while</span>(pre[r]!=r)<span class="comment">//如果r的上级不是自己</span></span><br><span class="line">r=pre[r];<span class="comment">//那么r等于它的前导点，继续寻找，直到找到根节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面这段起到路径压缩的作用</span></span><br><span class="line"><span class="keyword">int</span> i=x; <span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">while</span>(i!=r)<span class="comment">//如果当前查找的不是根结点（pre指向自己）</span></span><br><span class="line">&#123;</span><br><span class="line">j=pre[i];<span class="comment">//在改变上级之前用临时变量j记录下他的值</span></span><br><span class="line">pre[i]=r;<span class="comment">//更新前导点直接指向根节点</span></span><br><span class="line">i=j;<span class="comment">//让i指向其前导点，在下一次循环里面就会更新其前导点指向根节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>join()函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> p1,<span class="keyword">int</span> p2)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> f1,f2;</span><br><span class="line">f1 = find(p1);</span><br><span class="line">f2 = find(p2); <span class="comment">//分别查找根节点</span></span><br><span class="line"><span class="comment">//如果是不连通的，那么把这两个分支连起来</span></span><br><span class="line"><span class="keyword">if</span>(f1!=f2)</span><br><span class="line">&#123;</span><br><span class="line">pre[f1]=f2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="具体代码实例"><a href="#具体代码实例" class="headerlink" title="具体代码实例"></a>具体代码实例</h2><h3 id="【hdu1232】畅通工程"><a href="#【hdu1232】畅通工程" class="headerlink" title="【hdu1232】畅通工程"></a>【hdu1232】畅通工程</h3><blockquote><p>畅通工程<br><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1232" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1232</a><br>Time Limit: 4000/2000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)<br>Total Submission(s): 61184    Accepted Submission(s): 32757</p><p>Problem Description<br>某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。<br>省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？ </p><p>Input<br>测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( &lt; 1000 )和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。<br>注意:两个城市之间可以有多条道路相通,也就是说<br>3 3<br>1 2<br>1 2<br>2 1<br>这种输入也是合法的<br>当N为0时，输入结束，该用例不被处理。 </p><p>Output<br>对每个测试用例，在1行里输出最少还需要建设的道路数目。 </p><p>Sample Input<br>4 2<br>1 3<br>4 3<br>3 3<br>1 2<br>1 3<br>2 3<br>5 2<br>1 2<br>3 5<br>999 0<br>0</p><p>Sample Output<br>1<br>0<br>2<br>998</p></blockquote><p>分析：见代码注释部分</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pre[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">int</span> total;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> r=x;</span><br><span class="line"><span class="keyword">while</span>(pre[r]!=r)<span class="comment">//如果r的上级不是自己</span></span><br><span class="line">r=pre[r];<span class="comment">//那么r等于它的前导点，继续寻找，直到找到根节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面这段起到路径压缩的作用</span></span><br><span class="line"><span class="keyword">int</span> i=x; <span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">while</span>(i!=r)<span class="comment">//如果当前查找的城镇不是根结点（pre指向自己）</span></span><br><span class="line">&#123;</span><br><span class="line">j=pre[i];<span class="comment">//j为该城镇的前导点</span></span><br><span class="line">pre[i]=r;<span class="comment">//更新该城镇的前导点直接指向根节点</span></span><br><span class="line">i=j;<span class="comment">//让i指向其前导点，在下一次循环里面就会更新其前导点指向根节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> p1,<span class="keyword">int</span> p2)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> f1,f2;</span><br><span class="line">f1 = find(p1);</span><br><span class="line">f2 = find(p2); <span class="comment">//分别查找两个城镇的根节点</span></span><br><span class="line"><span class="comment">//如果是不连通的，那么把这两个分支连起来</span></span><br><span class="line"><span class="comment">//分支的总数就减少了1，还需建的路也就减了1</span></span><br><span class="line"><span class="keyword">if</span>(f1!=f2)</span><br><span class="line">&#123;</span><br><span class="line">pre[f2 ]=f1;</span><br><span class="line">total--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  n,m,p1,p2;</span><br><span class="line"><span class="keyword">while</span>((~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)) &amp;&amp; n)&#123;</span><br><span class="line">total = n<span class="number">-1</span>; <span class="comment">//最差的情况下，总共要修n-1条路</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123; <span class="comment">//初始化pre数组，让他们的前导点都记录为自己，即自己为根节点</span></span><br><span class="line">pre[i]=i; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;p1&gt;&gt;p2; <span class="comment">//输入相连的连个城镇</span></span><br><span class="line">join(p1,p2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,total); <span class="comment">//最后输出还要修的路条数</span></span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="【2018年全国多校算法寒假训练营练习比赛（第四场）】Call-to-your-teacher"><a href="#【2018年全国多校算法寒假训练营练习比赛（第四场）】Call-to-your-teacher" class="headerlink" title="【2018年全国多校算法寒假训练营练习比赛（第四场）】Call to your teacher"></a>【2018年全国多校算法寒假训练营练习比赛（第四场）】Call to your teacher</h3><blockquote><p>链接：<a href="https://www.nowcoder.net/acm/contest/76/F" target="_blank" rel="noopener">https://www.nowcoder.net/acm/contest/76/F</a><br>来源：牛客网</p><p>题目描述<br>从实验室出来后，你忽然发现你居然把自己的电脑落在了实验室里，但是实验室的老师已经把大门锁上了。更糟的是，你没有那个老师的电话号码。你开始给你知道的所有人打电话，询问他们有没有老师的电话，如果没有，他们也会问自己的同学来询问电话号码。那么，你能联系到老师并且拿到电脑吗。<br>输入描述:<br>存在多组测试样例<br>每组样例的第一行分别是两个整数n(1&lt;n&lt;=50)，m(1&lt;m&lt;=2000)，n是在题目当中出现的人数，其中你的序号是1号，实验室老师的序号是n。<br>接下来的m行，每行有两个整数x(1&lt;=x&lt;=n)，y(1&lt;=y&lt;=n)，代表x有y的电话号码。<br>输出描述:<br>对于每组测试样例，如果你最终能联系到老师，输出“Yes”，否则输出“No”。<br>示例1<br>输入<br>5 5<br>1 3<br>2 3<br>3 4<br>2 4<br>4 5<br>输出<br>Yes<br>示例2<br>输入<br>4 3<br>1 2<br>2 3<br>4 1<br>输出<br>No</p></blockquote><p>分析：要求1号能不能得到老师n号的电话号码，最后我们只要检测1号和n号在不在一个集合里，能否直接通过find()函数查找到。所以通过并查集解决这题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pre[<span class="number">2010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> r=x;</span><br><span class="line"><span class="keyword">while</span>(pre[r]!=r)</span><br><span class="line">r = pre[r];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i=x, j;</span><br><span class="line"><span class="keyword">while</span>(i!=r)&#123;</span><br><span class="line">j = pre[i];</span><br><span class="line">pre[i] = r;</span><br><span class="line">i = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> p1, <span class="keyword">int</span> p2)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> f1, f2;</span><br><span class="line">f1 = find(p1);</span><br><span class="line">f2 = find(p2);</span><br><span class="line"><span class="keyword">if</span>(f2!=<span class="number">1</span>)&#123;</span><br><span class="line">pre[f2] = f1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,m,p1,p2;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m))&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">pre[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;p1&gt;&gt;p2;</span><br><span class="line">join(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(find(n)==<span class="number">1</span>)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"Yes"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"No"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;并查集&quot;&gt;&lt;a href=&quot;#并查集&quot; class=&quot;headerlink&quot; title=&quot;并查集&quot;&gt;&lt;/a&gt;并查集&lt;/h1&gt;&lt;p&gt;详见这篇博文：&lt;a href=&quot;http://blog.csdn.net/niushuai666/article/details/6
      
    
    </summary>
    
      <category term="学习" scheme="https://hushhw.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法笔记" scheme="https://hushhw.cn/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
      <category term="并查集" scheme="https://hushhw.cn/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>错排公式的推导及应用</title>
    <link href="https://hushhw.cn/2018/02/07/08%E9%94%99%E6%8E%92/"/>
    <id>https://hushhw.cn/2018/02/07/08错排/</id>
    <published>2018-02-07T15:06:32.000Z</published>
    <updated>2018-02-12T18:54:59.615Z</updated>
    
    <content type="html"><![CDATA[<p>之前就遇到过错排公式的题，但是自己没有注意这个知识点，以为只要硬记住就好啦，结果就是不知道推导过程完全记不住呀，所以今天认真整理一下错排公式相关的点。</p><h1 id="错排公式的推导"><a href="#错排公式的推导" class="headerlink" title="错排公式的推导"></a>错排公式的推导</h1><p>考虑一个有n个元素的排列，若一个排列中所有的元素都不在自己原来的位置上，那么这样的排列就称为原排列的一个错排，n个元素的错排记为D(n)。下面就是求出D(n)为多少中排列。</p><p>首先我们拿第一个元素的放置来理解一下这个过程：把元素1放在除自己原来的位置以外的位置，共有(n-1)种，假设第一个元素被放在了第k个元素的位置上，对第k个元素而言就有两种情况要讨论了，第一种，它放在非第一个位置上，所以对于接下来的排列就相当于是n-1个元素的错排，即D(n-1)；第二种，它就放在第1个元素的位置上，所以排列D(n)中有两个元素已经找到位置了，那么接下来就只需要考虑n-2个元素的错排，即D(n-2)。由此，我们就可以写出<strong>递推式对于D(n)都有D(n)=(n-1)*(D(n-1)+D(n-2))【特殊的情况 D(1)=0, D(2)=1】</strong>。</p><p>下面通过这个递推关系进行推导：<br>为了运算方便，我们设D(n)=n!<em>N(n)，则有：<br>n!</em>N(n) = (n-1)<em>(n-2)!</em>N(n-2) + (n-1)<em>(n-1)!N(n-1); 对两边同时除以(n-1)!，可得：<br>n</em>N(n) = N(n-2)+(n-1)<em>N(n-1)，移项：<br>N(n) - N(n-1) = (N(n-2) - N(n-1))/n = -(1/n)(N(n-1) - N(n-2))，所以，由此可以推出<br>N(n-1) - N(n-2) = -(1/(n-1))(N(n-2) - N(n-3))<br>……<br>N(2) - N(1) = 1/2;<br>由此，将每个式子相加得到：N(n) - N(1) = (1/2! - 1/3! + 1/4! - ……+((-1)^(n-1))/(n-1)! + (-1)^n/n!)<br>由于N(1) = 0，所以N(n) = (1/2! - 1/3! + 1/4! - …… +((-1)^(n-1))/(n-1)! + (-1)^n/n!)，于是可以得到：<br>错排公式<em>*D(n) = n!(1/2! - 1/3! + 1/4! - …… +((-1)^(n-1))/(n-1)! + (-1)^n/n!)</em></em>。</p><h1 id="错排公式的应用解题"><a href="#错排公式的应用解题" class="headerlink" title="错排公式的应用解题"></a>错排公式的应用解题</h1><h2 id="【hdu2049】考新郎"><a href="#【hdu2049】考新郎" class="headerlink" title="【hdu2049】考新郎"></a>【hdu2049】考新郎</h2><blockquote><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p> 在一场盛大的集体婚礼中,为了使婚礼进行的丰富一些,司仪临时想出了有一个有意思的节目,叫做”考新郎”,具体的操作是这样的:</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p> 输入数据的第一行是一个整数C,表示测试实例的个数，然后是C行数据，每行包含两个整数N和M(1&lt; M&lt;=N&lt;=20)</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p> 对于每个测试实例，请输出一共有多少种发生这种情况的可能，每个实例的输出占一行。</p><h2 id="示例输入"><a href="#示例输入" class="headerlink" title="示例输入"></a>示例输入</h2><p> 2<br> 2 2<br> 3 2</p></blockquote><p>最开始做着题的时候就直接求解排列组合C(n,m)，没有考虑错排m个元素D(m)的问题，这里用上面的两种方法分别写出代码：</p><h3 id="方法一：递推公式-D-n-n-1-D-n-1-D-n-2-D-1-0，D-2-1"><a href="#方法一：递推公式-D-n-n-1-D-n-1-D-n-2-D-1-0，D-2-1" class="headerlink" title="方法一：递推公式 D(n)=(n-1)*(D(n-1)+D(n-2)) [D(1)=0，D(2)=1]"></a>方法一：递推公式 D(n)=(n-1)*(D(n-1)+D(n-2)) [D(1)=0，D(2)=1]</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">long long f[22];  </span><br><span class="line">void init()//错排  </span><br><span class="line">&#123;  </span><br><span class="line">f[1]=0;  </span><br><span class="line">f[2]=1;  </span><br><span class="line">for(int i=3;i&lt;=20;i++)  </span><br><span class="line">&#123;  </span><br><span class="line">f[i]=(i-1)*(f[i-1]+f[i-2]);  </span><br><span class="line">&#125;  </span><br><span class="line">return ;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">int c(int x, int y)&#123;  </span><br><span class="line">int n=x, m=y;</span><br><span class="line">int sum=1,a=1,b=1;  </span><br><span class="line">for(int i=1;i&lt;=y;i++)  &#123;  </span><br><span class="line">a*=n;  </span><br><span class="line">n--; </span><br><span class="line">b*=m;  </span><br><span class="line">m--; </span><br><span class="line">&#125;  </span><br><span class="line">sum=a/b;  </span><br><span class="line">return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;  </span><br><span class="line">int N,M;  </span><br><span class="line">init();  </span><br><span class="line">while(scanf(&quot;%d%d&quot;,&amp;N,&amp;M)!=EOF)  </span><br><span class="line">&#123;  </span><br><span class="line"></span><br><span class="line">cout&lt;&lt;c(N,M)*f[M]&lt;&lt;endl;  </span><br><span class="line">&#125;  </span><br><span class="line">return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二：通项公式-D-n-n-1-2-1-3-1-4-1-5-···-···-1-n-1-n-1-1-n-n"><a href="#方法二：通项公式-D-n-n-1-2-1-3-1-4-1-5-···-···-1-n-1-n-1-1-n-n" class="headerlink" title="方法二：通项公式 D(n)=n!*(1/2!-1/3!+1/4!- 1/5!+ ··· ··· +((-1)^(n-1))/(n-1)!+((-1)^n)/n! )"></a>方法二：通项公式 D(n)=n!*(1/2!-1/3!+1/4!- 1/5!+ ··· ··· +((-1)^(n-1))/(n-1)!+((-1)^n)/n! )</h3><p>对通项先进行简单变形：<br>C(n,m)<em>D(m) = (n!/(m!</em>(n-m)!))<em>D(m) = n!</em>(1/2!-1/3!+1/4!- 1/5!+ ··· ··· +((-1)^(m-1))/(m-1)!+((-1)^m)/m! )/(n-m)!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">long long f[22];  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int c(int n)&#123;  </span><br><span class="line">ll sum=1;</span><br><span class="line">for(int i=1; i&lt;=n; i++)</span><br><span class="line">sum*=i;</span><br><span class="line">return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;  </span><br><span class="line">int N,M;   </span><br><span class="line">while(scanf(&quot;%d%d&quot;,&amp;N,&amp;M)!=EOF)  </span><br><span class="line">&#123;  </span><br><span class="line">ll a=c(N), sum=0, b=c(N-M);</span><br><span class="line">for(int i=2; i&lt;=M; ++i)&#123;</span><br><span class="line">a/=i;</span><br><span class="line">if(i%2==0)</span><br><span class="line">sum+=a;</span><br><span class="line">else</span><br><span class="line">sum-=a;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;sum/b&lt;&lt;endl;</span><br><span class="line">&#125;  </span><br><span class="line">return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>本文内容参考自：<br><a href="http://blog.csdn.net/yangyuhao0408/article/details/50971170" target="_blank" rel="noopener">http://blog.csdn.net/yangyuhao0408/article/details/50971170</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前就遇到过错排公式的题，但是自己没有注意这个知识点，以为只要硬记住就好啦，结果就是不知道推导过程完全记不住呀，所以今天认真整理一下错排公式相关的点。&lt;/p&gt;
&lt;h1 id=&quot;错排公式的推导&quot;&gt;&lt;a href=&quot;#错排公式的推导&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="学习" scheme="https://hushhw.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法笔记" scheme="https://hushhw.cn/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
      <category term="错排公式" scheme="https://hushhw.cn/tags/%E9%94%99%E6%8E%92%E5%85%AC%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>“埃氏筛法”思想运用</title>
    <link href="https://hushhw.cn/2018/02/03/07%E5%9F%83%E7%AD%9B/"/>
    <id>https://hushhw.cn/2018/02/03/07埃筛/</id>
    <published>2018-02-03T08:19:44.000Z</published>
    <updated>2018-02-12T18:55:24.129Z</updated>
    
    <content type="html"><![CDATA[<h1 id="何为“埃氏筛法”"><a href="#何为“埃氏筛法”" class="headerlink" title="何为“埃氏筛法”"></a>何为“埃氏筛法”</h1><blockquote><p>埃拉托斯特尼筛法，简称埃氏筛或爱氏筛，是一种由希腊数学家埃拉托斯特尼所提出的一种简单检定素数的算法。要得到自然数n以内的全部素数，必须把不大于根号n的所有素数的倍数剔除，剩下的就是素数。</p></blockquote><h1 id="求n以内的素数个数"><a href="#求n以内的素数个数" class="headerlink" title="求n以内的素数个数"></a>求n以内的素数个数</h1><p>给你一个数n,请问n以内有多少个素数?一般来说,要是对一个整数进行素数判断，首先想到的是写个函数判断是否为素数，然后调用这个函数，时间复杂度为O(n^(½)，但是要求n以内的素数就略显吃力了。这里就可以用埃氏筛法来处理这个问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int SIZE = 1e7;</span><br><span class="line"></span><br><span class="line">int prime[SIZE];//第i个素数</span><br><span class="line">bool is_prime[SIZE];//true表示i是素数</span><br><span class="line"></span><br><span class="line">int slove(int n)&#123;</span><br><span class="line">int p=0;</span><br><span class="line">for(int i=0; i&lt;=n; i++)</span><br><span class="line">is_prime[i] = true;//初始化</span><br><span class="line">is_prime[0] = is_prime[1] = false;//0,1不是素数</span><br><span class="line">for(int i=2; i&lt;=n; i++)&#123;</span><br><span class="line">if(is_prime[i])&#123;</span><br><span class="line">prime[p++] = i;</span><br><span class="line">for(int j=2*i; j&lt;=n; j+=i)  //将i的倍数全部设为false</span><br><span class="line">is_prime[j] = false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">int n;</span><br><span class="line">while(cin&gt;&gt;n)&#123;</span><br><span class="line">int res = slove(n);</span><br><span class="line">cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">for(int i=0; i&lt;res; i++)</span><br><span class="line">cout&lt;&lt;prime[i]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看代码说明，埃氏筛法是通过把不大于n的所有素数的倍数剔除，剩下的就是素数，这里最小的素数是2，将表中所有2的倍数都除去，剩下最小的数是3，不能被更小的数整除，所以是素数。再将表中3的倍数的数除去。以此类推。如果表中最小的数字是m，m就是素数。然后将表中所有m的倍数都除去……</p><h1 id="利用埃氏筛法的思想解题"><a href="#利用埃氏筛法的思想解题" class="headerlink" title="利用埃氏筛法的思想解题"></a>利用埃氏筛法的思想解题</h1><p>链接：<a href="https://www.nowcoder.net/acm/contest/71/A" target="_blank" rel="noopener">https://www.nowcoder.net/acm/contest/71/A</a><br>来源：牛客网</p><blockquote><p>找一找<br>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 262144K，其他语言524288K<br>64bit IO Format: %lld<br>题目描述<br>给定n个正整数，请找出其中有多少个数x满足：在这n个数中存在数y=kx，其中k为大于1的整数<br>输入描述:<br>第一行输入一个n<br>接下来一行输入n个正整数ai<br>输出描述:<br>输出符合条件个数<br>示例1<br>输入<br>5<br>1 2 3 4 5<br>输出<br>2<br>说明<br>5个数中1和2符合条件，1是后面每个数的因子，2是4的因子<br>备注:<br>1≤n,a<br>i<br>≤1000000</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef unsigned long long ull;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=1e6+5;</span><br><span class="line">int b[N],a[N],sum;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i=0; i&lt;n; i++)</span><br><span class="line">cin&gt;&gt;a[i],b[a[i]]=1;</span><br><span class="line">for(int i=0; i&lt;n; i++)</span><br><span class="line">&#123;</span><br><span class="line">if(a[i]==1)</span><br><span class="line">&#123;</span><br><span class="line">sum++;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">for(int j=a[i]+a[i]; j&lt;N; j+=a[i])</span><br><span class="line">if(b[j]==1)</span><br><span class="line">&#123;</span><br><span class="line">sum++;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d\n&quot;,sum);</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;何为“埃氏筛法”&quot;&gt;&lt;a href=&quot;#何为“埃氏筛法”&quot; class=&quot;headerlink&quot; title=&quot;何为“埃氏筛法”&quot;&gt;&lt;/a&gt;何为“埃氏筛法”&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;埃拉托斯特尼筛法，简称埃氏筛或爱氏筛，是一种由希腊数学家埃拉托斯特
      
    
    </summary>
    
      <category term="学习" scheme="https://hushhw.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法笔记" scheme="https://hushhw.cn/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
      <category term="埃筛" scheme="https://hushhw.cn/tags/%E5%9F%83%E7%AD%9B/"/>
    
  </entry>
  
  <entry>
    <title>浙江大学PAT题解目录</title>
    <link href="https://hushhw.cn/2018/01/25/06PAT/"/>
    <id>https://hushhw.cn/2018/01/25/06PAT/</id>
    <published>2018-01-25T14:45:39.000Z</published>
    <updated>2018-02-21T14:49:38.524Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PAT"><a href="#PAT" class="headerlink" title="PAT"></a>PAT</h1><p>Record my code in Programming Ability Test</p><p><a href="https://github.com/hushhw/PAT" target="_blank" rel="noopener">https://github.com/hushhw/PAT</a></p><h2 id="PAT甲级"><a href="#PAT甲级" class="headerlink" title="PAT甲级"></a>PAT甲级</h2><div class="table-container"><table><thead><tr><th style="text-align:center">ID</th><th style="text-align:left">Title</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:center">1001</td><td style="text-align:left">A+B Format (20)</td><td style="text-align:left">字符串处理</td></tr><tr><td style="text-align:center">1002</td><td style="text-align:left">A+B for Polynomials (25)</td><td style="text-align:left">模拟</td></tr><tr><td style="text-align:center">1003</td><td style="text-align:left">Emergency (25)</td><td style="text-align:left">Dijkstra算法及dfs解法</td></tr><tr><td style="text-align:center">1004</td><td style="text-align:left">Counting Leaves (30)</td><td style="text-align:left">BFS，DFS，树的层序遍历</td></tr><tr><td style="text-align:center">1005</td><td style="text-align:left">Spell It Right (20)</td><td style="text-align:left">字符串处理</td></tr><tr><td style="text-align:center">1006</td><td style="text-align:left">Sign In and Sign Out (25)</td><td style="text-align:left">查找元素</td></tr><tr><td style="text-align:center">1007</td><td style="text-align:left">Maximum Subsequence Sum(25)</td><td style="text-align:left">动态规划，最大连续子序列和</td></tr><tr><td style="text-align:center">1008</td><td style="text-align:left">Elevator (20)</td><td style="text-align:left">数学问题</td></tr><tr><td style="text-align:center">1009</td><td style="text-align:left">Product of Polynomials (25)</td><td style="text-align:left">模拟</td></tr><tr><td style="text-align:center">1010</td><td style="text-align:left">Radix (25)</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">1011</td><td style="text-align:left">World Cup Betting (20)</td><td style="text-align:left">查找元素</td></tr></tbody></table></div><h2 id="PAT乙级"><a href="#PAT乙级" class="headerlink" title="PAT乙级"></a>PAT乙级</h2><div class="table-container"><table><thead><tr><th style="text-align:center">ID</th><th style="text-align:left">Title</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">1001</td><td style="text-align:left">害死人不偿命的(3n+1)猜想(15)</td><td style="text-align:center">模拟</td></tr><tr><td style="text-align:center">1002</td><td style="text-align:left">写出这个数 (20)</td><td style="text-align:center">字符串处理</td></tr><tr><td style="text-align:center">1003</td><td style="text-align:left">我要通过！(20)</td><td style="text-align:center">数学题</td></tr><tr><td style="text-align:center">1004</td><td style="text-align:left">成绩排名 (20)</td><td style="text-align:center">Hash散列</td></tr><tr><td style="text-align:center">1006</td><td style="text-align:left">换个格式输出整数 (15)</td><td style="text-align:center">素数</td></tr><tr><td style="text-align:center">1008</td><td style="text-align:left">数组元素循环右移问题 (20)</td><td style="text-align:center">模拟</td></tr><tr><td style="text-align:center">1009</td><td style="text-align:left">说反话 (20)</td><td style="text-align:center">字符串处理</td></tr><tr><td style="text-align:center">1010</td><td style="text-align:left">一元多项式求导 (25)</td><td style="text-align:center">模拟</td></tr><tr><td style="text-align:center">1011</td><td style="text-align:left">A+B和C (15)</td><td style="text-align:center">模拟</td></tr><tr><td style="text-align:center">1012</td><td style="text-align:left">数字分类 (20)</td><td style="text-align:center">模拟</td></tr><tr><td style="text-align:center">1013</td><td style="text-align:left">数素数 (20)</td><td style="text-align:center">素数</td></tr><tr><td style="text-align:center">1014</td><td style="text-align:left">福尔摩斯的约会 (20)</td><td style="text-align:center">字符串处理</td></tr><tr><td style="text-align:center">1015</td><td style="text-align:left">德才论 (25)</td><td style="text-align:center">排序</td></tr><tr><td style="text-align:center">1016</td><td style="text-align:left">部分A+B (15)</td><td style="text-align:center">模拟</td></tr><tr><td style="text-align:center">1017</td><td style="text-align:left">A除以B (20)</td><td style="text-align:center">大整数运算</td></tr><tr><td style="text-align:center">1018</td><td style="text-align:left">锤子剪刀布 (20)</td><td style="text-align:center">模拟</td></tr><tr><td style="text-align:center">1019</td><td style="text-align:left">数字黑洞 (20)</td><td style="text-align:center">数学问题</td></tr><tr><td style="text-align:center">1020</td><td style="text-align:left">月饼 (25)</td><td style="text-align:center">贪心算法</td></tr><tr><td style="text-align:center">1021</td><td style="text-align:left">个位数统计 (15)</td><td style="text-align:center">字符串处理</td></tr><tr><td style="text-align:center">1022</td><td style="text-align:left">D进制的A+B (20)</td><td style="text-align:center">进制转换</td></tr><tr><td style="text-align:center">1023</td><td style="text-align:left">组个最小数 (20)</td><td style="text-align:center">贪心算法</td></tr><tr><td style="text-align:center">1024</td><td style="text-align:left">科学计数法 (20)</td><td style="text-align:center">字符串处理</td></tr><tr><td style="text-align:center">1025</td><td style="text-align:left">反转链表 (25)</td><td style="text-align:center">链表</td></tr><tr><td style="text-align:center">1026</td><td style="text-align:left">程序运行时间(15)</td><td style="text-align:center">模拟</td></tr><tr><td style="text-align:center">1027</td><td style="text-align:left">打印沙漏(20)</td><td style="text-align:center">图形打印</td></tr><tr><td style="text-align:center">1028</td><td style="text-align:left">人口普查(20)</td><td style="text-align:center">查找元素</td></tr><tr><td style="text-align:center">1029</td><td style="text-align:left">旧键盘(20)</td><td style="text-align:center">Hash散列</td></tr><tr><td style="text-align:center">1030</td><td style="text-align:left">完美数列(25)</td><td style="text-align:center">two pointers</td></tr><tr><td style="text-align:center">1031</td><td style="text-align:left">查验身份证(15)</td><td style="text-align:center">字符串处理</td></tr><tr><td style="text-align:center">1032</td><td style="text-align:left">挖掘机技术哪家强(20)</td><td style="text-align:center">查找元素</td></tr><tr><td style="text-align:center">1033</td><td style="text-align:left">旧键盘打字(20)</td><td style="text-align:center">Hash散列</td></tr><tr><td style="text-align:center">1034</td><td style="text-align:left">有理数四则运算(20)</td><td style="text-align:center">分数的四则运算</td></tr><tr><td style="text-align:center">1035</td><td style="text-align:left">插入与归并(25)</td><td style="text-align:center">two pointers</td></tr><tr><td style="text-align:center">1036</td><td style="text-align:left">跟奥巴马一起编程(15)</td><td style="text-align:center">图形打印</td></tr><tr><td style="text-align:center">1037</td><td style="text-align:left">在霍格沃茨找零钱（20)</td><td style="text-align:center">进制转换</td></tr><tr><td style="text-align:center">1038</td><td style="text-align:left">统计同成绩学生(20)</td><td style="text-align:center">Hash散列</td></tr><tr><td style="text-align:center">1039</td><td style="text-align:left">到底买不买 (20)</td><td style="text-align:center">Hash散列</td></tr><tr><td style="text-align:center">1040</td><td style="text-align:left">有几个PAT（25)</td><td style="text-align:center">逻辑题</td></tr><tr><td style="text-align:center">1041</td><td style="text-align:left">考试座位号(15)</td><td style="text-align:center">查找元素</td></tr><tr><td style="text-align:center">1042</td><td style="text-align:left">字符统计(20)</td><td style="text-align:center">Hash散列</td></tr><tr><td style="text-align:center">1043</td><td style="text-align:left">输出PATest(20)</td><td style="text-align:center">Hash散列</td></tr><tr><td style="text-align:center">1044</td><td style="text-align:left">火星数字(20)</td><td style="text-align:center">map映射，STL的使用</td></tr><tr><td style="text-align:center">1045</td><td style="text-align:left">快速排序(25)</td><td style="text-align:center">快速排序</td></tr><tr><td style="text-align:center">1046</td><td style="text-align:left">划拳(15)</td><td style="text-align:center">模拟</td></tr><tr><td style="text-align:center">1047</td><td style="text-align:left">编程团体赛(20)</td><td style="text-align:center">Hash散列</td></tr><tr><td style="text-align:center">1048</td><td style="text-align:left">数字加密(20)</td><td style="text-align:center">字符串处理</td></tr><tr><td style="text-align:center">1049</td><td style="text-align:left">数列的片段和(20)</td><td style="text-align:center">数学问题</td></tr><tr><td style="text-align:center">1050</td><td style="text-align:left">螺旋矩阵(25)</td><td style="text-align:center">模拟</td></tr><tr><td style="text-align:center">1051</td><td style="text-align:left">复数乘法 (15)</td><td style="text-align:center">模拟</td></tr><tr><td style="text-align:center">1052</td><td style="text-align:left">卖个萌 (20)</td><td style="text-align:center">字符串处理</td></tr><tr><td style="text-align:center">1053</td><td style="text-align:left">住房空置率 (20)</td><td style="text-align:center">模拟</td></tr><tr><td style="text-align:center">1054</td><td style="text-align:left">求平均值 (20)</td><td style="text-align:center">字符串处理</td></tr><tr><td style="text-align:center">1055</td><td style="text-align:left">集体照 (25)</td><td style="text-align:center">排序</td></tr><tr><td style="text-align:center">1056</td><td style="text-align:left">组合数的和(15)</td><td style="text-align:center">数学问题</td></tr><tr><td style="text-align:center">1057</td><td style="text-align:left">数零壹(20)</td><td style="text-align:center">进制转换</td></tr><tr><td style="text-align:center">1058</td><td style="text-align:left">选择题(20)</td><td style="text-align:center">字符串处理</td></tr><tr><td style="text-align:center">1059</td><td style="text-align:left">C语言竞赛(20)</td><td style="text-align:center">逻辑题</td></tr><tr><td style="text-align:center">1060</td><td style="text-align:left">爱丁顿数(25)</td><td style="text-align:center">逻辑题</td></tr><tr><td style="text-align:center">1061</td><td style="text-align:left">判断题(15)</td><td style="text-align:center">逻辑题</td></tr><tr><td style="text-align:center">1062</td><td style="text-align:left">最简分数(20)</td><td style="text-align:center">分数化简</td></tr><tr><td style="text-align:center">1063</td><td style="text-align:left">计算谱半径(20)</td><td style="text-align:center">逻辑题</td></tr><tr><td style="text-align:center">1064</td><td style="text-align:left">朋友数(20)</td><td style="text-align:center">set的使用</td></tr><tr><td style="text-align:center">1065</td><td style="text-align:left">单身狗(25)</td><td style="text-align:center">逻辑题，set的使用</td></tr><tr><td style="text-align:center">1066</td><td style="text-align:left">图像过滤(15)</td><td style="text-align:center">逻辑题</td></tr><tr><td style="text-align:center">1067</td><td style="text-align:left">试密码(20)</td><td style="text-align:center">字符串</td></tr><tr><td style="text-align:center">1068</td><td style="text-align:left">万绿丛中一点红(20)</td><td style="text-align:center">逻辑题</td></tr><tr><td style="text-align:center">1069</td><td style="text-align:left">微博转发抽奖(20)</td><td style="text-align:center">map映射</td></tr><tr><td style="text-align:center">1070</td><td style="text-align:left">结绳(25)</td><td style="text-align:center">排序，贪心</td></tr><tr><td style="text-align:center">1071</td><td style="text-align:left">小赌怡情(15)</td><td style="text-align:center">简单题</td></tr><tr><td style="text-align:center">1072</td><td style="text-align:left">开学寄语(20)</td><td style="text-align:center">简单题</td></tr><tr><td style="text-align:center">1073</td><td style="text-align:left">多选题常见计分法(20)</td><td style="text-align:center">逻辑题</td></tr><tr><td style="text-align:center">1074</td><td style="text-align:left">宇宙无敌加法器(20)</td><td style="text-align:center">逻辑题</td></tr><tr><td style="text-align:center">1075</td><td style="text-align:left">链表元素分类(25)</td><td style="text-align:center">链表</td></tr><tr><td style="text-align:center">1076</td><td style="text-align:left">Wifi密码</td><td style="text-align:center">简单题</td></tr><tr><td style="text-align:center">1077</td><td style="text-align:left">互评成绩计算</td><td style="text-align:center">简单题</td></tr><tr><td style="text-align:center">1078</td><td style="text-align:left">字符串压缩与解压</td><td style="text-align:center">逻辑题</td></tr><tr><td style="text-align:center">1079</td><td style="text-align:left">延迟的回文数</td><td style="text-align:center">回文数</td></tr><tr><td style="text-align:center">1080</td><td style="text-align:left">MOOC期终成绩</td><td style="text-align:center">map映射，排序</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PAT&quot;&gt;&lt;a href=&quot;#PAT&quot; class=&quot;headerlink&quot; title=&quot;PAT&quot;&gt;&lt;/a&gt;PAT&lt;/h1&gt;&lt;p&gt;Record my code in Programming Ability Test&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https:/
      
    
    </summary>
    
      <category term="学习" scheme="https://hushhw.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="OJ刷题" scheme="https://hushhw.cn/categories/%E5%AD%A6%E4%B9%A0/OJ%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="PAT" scheme="https://hushhw.cn/tags/PAT/"/>
    
      <category term="OJ" scheme="https://hushhw.cn/tags/OJ/"/>
    
      <category term="刷题" scheme="https://hushhw.cn/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>《计算机网络》复习笔记</title>
    <link href="https://hushhw.cn/2018/01/05/05computer%20network/"/>
    <id>https://hushhw.cn/2018/01/05/05computer network/</id>
    <published>2018-01-04T17:35:29.000Z</published>
    <updated>2018-02-07T10:53:42.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络复习笔记"><a href="#计算机网络复习笔记" class="headerlink" title="计算机网络复习笔记"></a>计算机网络复习笔记</h1><ul><li>本复习笔记基于谢希仁的《计算机网络》第五版教材整理。</li></ul><p>[TOC]</p><hr><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><h3 id="1-1-计算机网络"><a href="#1-1-计算机网络" class="headerlink" title="1.1 计算机网络"></a>1.1 计算机网络</h3><ol><li>计算机网络向用户提供的两个最重要的功能：<ul><li>连通性</li><li>共享</li></ul></li></ol><h3 id="1-2-因特网概述"><a href="#1-2-因特网概述" class="headerlink" title="1.2 因特网概述"></a>1.2 因特网概述</h3><ol><li><p>因特网发展的三个阶段：</p><ul><li>第一阶段：从单个网络 ARPANET 向互联网发展的过程。1983 年 TCP/IP 协议成为 ARPANET 上的标准协议。</li><li>第二阶段：建成三级结构的因特网：主干网、地区网和校园网（或企业网）。</li><li>第三阶段：形成多层次的ISP（Internet Service Provider 因特网服务提供者）结构的因特网</li></ul></li><li><p>Internet 和 Internet 的区别：</p><ul><li><strong>internet</strong>：通用名词，它泛指由多个计算机网络互连而成的网络。</li><li><strong>Internet</strong>：专用名词，它指当前全球最大的、开放的、由众多网络相互连接而成的特定计算机网络，它采用 TCP/IP 协议族作为通信的规则，且其前身是美国的 ARPANET。</li></ul></li></ol><h3 id="1-3-互联网的组成-P8"><a href="#1-3-互联网的组成-P8" class="headerlink" title="1.3 互联网的组成 P8"></a>1.3 互联网的组成 P8</h3><ul><li><strong>边缘部分</strong>：有所有连接在因特网上的主机组成。这部分由<strong>用户直接使用</strong>，用来进行通信和资源共享。</li><li><strong>核心部分</strong> : 由大量的网络和连接这些网络的路由器组成。这部分是<strong>为边缘部分提供服务的</strong>（提供连通性和交换）。</li></ul><ol><li><p>处于边缘部分的用户通信方式 P9-P10</p><ul><li><p>客户服务器方式（<strong>C/S</strong>方式）：即Client/Server方式。（客户是服务的请求方，服务器是服务的提供方）</p></li><li><p>对等方式（<strong>P2P</strong>方式）：即Peer-to-Peer方式。（对等连接中的每一个主机既是客户又同时是服务器）</p></li></ul></li><li><p>核心部分的交换技术 P11-15</p><ul><li><strong>电路交换</strong> 的三个阶段：建立连接——通话——释放连接<br>在通话时，两用户之间占用端到端的资源，而由于绝大部分时间线路都是空闲的，所以线路的传输速率往往很低。</li><li><strong>分组交换</strong> 的组成：报文、首部、分组。采用存储转发技术，即收到分组——存储分组——查询路由（路由选择协议）——转发分组。优点：高效、灵活、迅速、可靠。缺点：时延、开销。关键构件：路由器。</li><li><strong>报文交换</strong> 整个报文传送到相邻结点，全部存储下来之后查询转发表，转发到下一个结点。<br><img src="http://img.blog.csdn.net/20140126135022484" alt="图片来源：blog.csdn.net/hcbbt/article/details/18271491"><br><img src="http://img.blog.csdn.net/20180105203650888?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHVzaGh3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></li></ul></li></ol><h3 id="1-4-计算机网络的类别-P17"><a href="#1-4-计算机网络的类别-P17" class="headerlink" title="1.4 计算机网络的类别 P17"></a>1.4 计算机网络的类别 P17</h3><ol><li><p>分类</p><ul><li><p>按通信距离分：广域网、局域网、城域网</p></li><li><p>按信息交换方式分：电路交换网、分组交换网、总和交换网</p></li><li>按网络拓扑结构分：星型网、树型网、环型网、总线网</li><li>按通信介质分：双绞线网、同轴电缆网、光纤网、卫星网</li><li>按传输带宽分：基带网、宽带网</li><li>按使用范围分：公用网、专用网</li><li>按速率分：高速网、中速网、低速网</li><li>按通信传播方式分：广播式、点到点式</li></ul></li><li><p>性能指标（P18）：速率、带宽、时延</p><ul><li><strong>速率</strong>：指连接在计算机网络上的主机在数字信道上传送数据的速率。b/s（bps） 如100M以太网，实际是指100Mb/s。往往是指额定速率或标称速率。</li><li><strong>带宽</strong>：数字信道所能传送的最高速率。b/s（bps）</li><li><strong>吞吐量</strong>：单位时间内通过某个网络（或信道、接口）的实际数据量。其绝对上限值等于带宽。</li><li><p><strong>时延</strong>：数据（一个报文或分组、甚至比特）从网络（或链路）的一段传送到另一端的时间，也称延迟。<br>&emsp; ① 发送时延：主机或路由器发送数据帧所需的时间，也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。也成传输时延。<br>发送时延 = 数据帧长度（b） / 信道带宽（b/s）<br>&emsp;② 传播时延：电磁波在信道中传输一定距离所需划分的时间。<br>传播时间 = 信道长度（m） / 传输速率（m/s）<br>&emsp;③ 处理时延：主机或路由器处理收到的分组所花费的时间。<br>&emsp;④ 排队时延：分组在输入队列中等待处理的时间加上其在输出队列中等待转发的时间。<br> 综上：总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延。<br>注：对于高速网络链路，提高的是发送速率而不是传播速率。</p></li><li><p>时延带宽积：传播时延 * 带宽。表示链路的容量。</p></li><li>往返时间RTT：从发送方发送数据开始，到发送发收到接收方的确认为止，所花费的时间。</li><li>利用率：某信道有百分之几是被利用的（有数据通过）。而信道或网络利用率过高会产生非常大的时延。<br>当前时延=空闲时时延/（1-利用率）</li></ul></li></ol><h3 id="1-5-计算机网络的体系结构-P25"><a href="#1-5-计算机网络的体系结构-P25" class="headerlink" title="1.5 计算机网络的体系结构 P25"></a>1.5 计算机网络的体系结构 P25</h3><ol><li><strong>网络协议</strong>：简称协议，是为了进行网络中的数据交换而建立的规则、标准或约定。</li><li>网络协议的三要素<ul><li>语法：数据与控制信息的结构或格式 </li><li>语义：需要发出何种控制信息，完成何种动作以及做出何种响应</li><li>同步：事件实现顺序的详细说明</li></ul></li><li><strong>体系结构</strong>(architecture)是计算机网络的各层及其协议的集合</li><li>五层协议的体系结构<ul><li><strong>物理层</strong>：物理层的任务就是透明地传送比特流。（注意：传递信息的物理媒体，如双绞线、同轴电缆、光缆等，是在物理层的下面，当做第0 层。）物理层还要确定连接电缆插头的定义及连接法。</li><li><strong>数据链路层</strong>：将网络层交下来的IP数据报组装成帧，在两个相邻结点间的链路上”透明“的传送以帧为单位的数据。每一帧包括数据和必要的控制信息。在收到数据时，控制信息使收到端直到哪个帧从哪个比特开始和结束。</li><li><strong>网络层</strong>：选择合适的路由，使发送站的运输层所传下来的分组能够正确无误地按照地址找到目的站，并交付给目的站的运输层。网络层将运输层产生的报文或用户数据报封装成分组（IP数据报）或包进行传送。</li><li><strong>运输层</strong>：向上一层的进行通信的两个进程之间提供一个可靠的端对端服务，使它们看不见运输层以下的数据通信的细节。（TCP、UDP）</li><li><strong>应用层</strong>：直接为用户的应用进程提供服务（HTTP、FTP等）</li></ul></li><li>OSI体系结构：物理层、数据链路层、网络层、运输层、会话层、表示层、应用层</li><li><p>TCP/IP体系结构：网络接口层、网际层IP、运输层、应用层<br><img src="http://img.blog.csdn.net/20180105203859787?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHVzaGh3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="图片来源网络"></p><p>​</p></li></ol><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><h3 id="2-1-物理层下的传输媒体"><a href="#2-1-物理层下的传输媒体" class="headerlink" title="2.1 物理层下的传输媒体"></a>2.1 物理层下的传输媒体</h3><p><img src="http://img.blog.csdn.net/20180105222431656?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHVzaGh3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="图片来源网络"></p><ol><li>导向传输媒体<br>1.1. 双绞线<br>  双绞线已成为局域网中的主流传输媒体</li></ol><ul><li><strong>屏蔽双绞线 STP</strong> (Shielded Twisted Pair)</li><li><strong>无屏蔽双绞线 UTP</strong> (Unshielded Twisted Pair)</li></ul><p>  1.2. 同轴电缆</p><ul><li><strong>细缆</strong>（适合短距离，安装容易，造价低）</li><li><p><strong>粗缆</strong>（适合较大局域网，布线距离长，可靠性好）</p><p>1.3. 光纤<br>光纤有很好的抗电磁干扰特性和很宽的频带，主要用在环形网中</p></li><li><strong>多模光纤</strong>（用发光二极管，便宜，定向性较差）</li><li><strong>单模光纤</strong>（注入激光二极管，定向性好）</li></ul><ol><li>非导向传输媒体<br>微波、红外线、激光、卫星通信</li></ol><h3 id="2-2-关于信道的几个基本概念"><a href="#2-2-关于信道的几个基本概念" class="headerlink" title="2.2 关于信道的几个基本概念"></a>2.2 关于信道的几个基本概念</h3><ol><li>通信方式</li></ol><ul><li>单向通信（单工）</li><li>双向交替通信（半双工）</li><li>双向同时通信（全双工）</li></ul><ol><li>基带信号：来自信源的信号。 带通信号：经过载波条之后的信号。基本带通调制方法：调幅(AM)、调频(FM)、调相(PM)</li></ol><h3 id="2-3-信道复用技术"><a href="#2-3-信道复用技术" class="headerlink" title="2.3 信道复用技术"></a>2.3 信道复用技术</h3><blockquote><p>这部分掌握码分复用计算即可</p></blockquote><ul><li>频分复用FDM (Frequency Division Multiplexing)：所有用户在同样的时间占用不同的频率带宽资源。</li><li>时分复用TDM(Time Division Multiplexing)则是将时间划分为一段段等长的时分复用帧（TDM 帧）。</li><li>统计时分复用 STDM(Statistic TDM)是改进的时分复用，明显地提高信道的利用率。</li><li>波分复用 WDM (Wavelength Division Multiplexing)：光的频分复用</li><li><p>码分复用 CDM (Code Division Multiplexing)常用的名词是<strong>码分多址 CDMA</strong>：有很强的抗干扰能力。</p><p>码分多址的计算靠一个例题就基本会了：<br><img src="http://img.blog.csdn.net/20180105230449989?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHVzaGh3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="课后习题"></p></li></ul><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p> 数据链路层使用的信道主要有以下两种类型：</p><ul><li>点对点信道</li><li>广播信道</li></ul><h3 id="3-1-使用点对点信道的数据链路层"><a href="#3-1-使用点对点信道的数据链路层" class="headerlink" title="3.1 使用点对点信道的数据链路层"></a>3.1 使用点对点信道的数据链路层</h3><ol><li><strong>链路</strong> ：从一个结点到相邻结点的一段物理线路</li><li><p><strong>数据链路</strong> ：把实现这些协议的硬件和软件加载链路上<br>现在最常用的方法是使用适配器（即网卡）来实现这些协议的硬件和软件。一般的适配器都包括了数据链路层和物理层这两层的功能。</p></li><li><p>三个基本问题：</p><ul><li><strong>封装成帧</strong><br>就是在一段数据的前后分别添加首部（帧开始符SOH 01）和尾部（帧结束符EOT 04），然后就构成了一个帧。（数据部分&lt;=长度限制MTU）首部和尾部的一个重要作用就是进行帧定界。<br><strong>帧定界是分组交换的必然要求</strong></li><li><strong>透明传输</strong><br>为了达到透明传输（即传输的数据部分不会因为包含SOH和EOT而出错），在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”(十六进制1B)<br><strong>透明传输避免消息符号与帧定界符号相混淆</strong></li><li><strong>差错检测</strong><br>现实通信链路中比特在传输中会产生差错，传输错误的比特占比称为<strong>误码率BER</strong>，为了保证可靠性，通常通过<strong>循环冗余检验CRC</strong>来做差错检测。<br><strong>差错检测防止无效数据帧浪费后续路由上的传输和处理资源</strong></li></ul><blockquote><p>CRC校验在计算机组成与结构中学过不做解释<br>会做课后习题7、8题即可</p></blockquote></li></ol><h3 id="3-2点对点协议-PPP-P70"><a href="#3-2点对点协议-PPP-P70" class="headerlink" title="3.2点对点协议 PPP P70"></a>3.2点对点协议 PPP P70</h3><ol><li>PPP协议的组成部分</li></ol><ul><li>一个将 IP 数据报封装到串行链路的方法</li><li>链路控制协议 LCP (Link Control Protocol)</li><li>网络控制协议 NCP (Network Control Protocol)</li></ul><ol><li>PPP协议的帧格式<br><img src="http://img.blog.csdn.net/20160204105742700" alt="图片来源：blog.csdn.net/cainv89/article/details/50614218"><br>首部：</li></ol><ul><li>首部中的标志字段F(Flag)，规定为0x7E(符号0x表示它后面的字符是用十六进制表示的。十六进制的7E的二进制表示是01111110)，标志字段表示一个帧的开始。</li><li>首部中的地址字段A规定为0xFF(即11111111)。</li><li>首部中的控制字段C规定为0x03(即00000011)。</li><li><p>首部中的2字节的协议字段：<br>(1)当协议字段为0x0021时，PPP帧的信息字段就是IP数据报。<br>(2)当协议字段为0xC021时，PPP帧的信息字段就是PPP链路控制协议LCP的数据。<br>(3)当协议字段为0x8021时，PPP帧的信息字段就是网络层的控制数据。</p><p>尾部：</p></li><li>尾部中的第一个字段(2个字节)是使用CRC的帧检验序列FCS。</li><li>尾部中的标志字段F(Flag)，规定为0x7E(符号0x表示它后面的字符是用十六进制表示的。十六进制的7E的二进制表示是01111110)，标志字段表示一个帧的结束。</li></ul><ol><li><p>透明传输的实现方法<br>当信息字段中出现和标志字段一样的比特(0x7E)组合时，就必须采取一些措施使这种形式上和标志字段一样的比特组合不出现在信息字段中。</p><ul><li><p><strong>字节填充</strong>——PPP使用异步传输<br>当 PPP 用在异步传输时，就使用一种特殊的字符填充法：将每一个 0x7E字节变为(0x7D, 0x5E)，0x7D转变成为(0x7D, 0x5D)。ASCII 码的控制字符（即数值小于 0x20 的字符），则在前面要加入0x7D，同时将该字符的编码加以改变。</p></li><li><p><strong>零比特填充</strong>——PPP使用同步传输<br>只要发现有5个连续的1，则立即填入一个0<br><img src="http://img.blog.csdn.net/20160204114637729" alt="图片来源：blog.csdn.net/cainv89/article/details/50614218"></p></li></ul></li></ol><blockquote><p>这部分考题很简单：见课后习题10</p></blockquote><ol><li>PPP 协议的工作状态：<br>链路静止-建立物理层-链路建立-pc发LCP-NCP分配IP地址-链路打开，网络层建立。（释放时倒过来）</li></ol><h3 id="3-3-使用广播信道的数据链路层-P76"><a href="#3-3-使用广播信道的数据链路层-P76" class="headerlink" title="3.3 使用广播信道的数据链路层 P76"></a>3.3 使用广播信道的数据链路层 P76</h3><p>广播信道是一种一对多的通信，局域网使用的就是广播信道</p><ol><li>局域网的数据链路层（局域网的数据链路层被拆分为了两个子层）</li></ol><ul><li>逻辑链路控制LLC子层：与传输媒体无关</li><li>媒体接入控制MAC子层：和局域网都对LLC子层来说是透明的</li></ul><ol><li><p>CSMA/CD 协议<br>以太网采用CSMA/CD协议的方式来协调总线上各计算机的工作。在使用CSMA/CD协议的时候，一个站不可能同时进行发送和接收，因此使用CSMA/CD协议的以太网不可能进行全双工通信而只能进行双向交替通信（半双工）。</p><p>CSMA/CD是<strong>载波监听多点接入/碰撞检测</strong>（Carrier Sense Multiple Access with Collision Detection）的缩写，下面是CSMA/CD协议的要点：</p></li></ol><ul><li><strong>“多点接入”</strong>就是计算机以多点接入（动态媒体接入控制）的方式连接在一根总线上。</li><li><strong>“载波监听”</strong>就是”发送前先监听”，即每一个站在发送数据前先要检测一下总线是否有其他站在发送数据，如有则暂时不要发送数据，要等到信道为空闲。</li><li><p><strong>“碰撞检测”</strong>就是“边发送边监听”，即适配器边发送数据边检测信道上的信号电压的变化情况。当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送。</p><p> 把总线上的单程端到端传播时延记为τ，A 发送数据后，最迟要经过2τ才能知道自己发送的数据和其他站发送的数据有没有发生碰撞。</p></li></ul><h3 id="3-4-以太网的MAC层"><a href="#3-4-以太网的MAC层" class="headerlink" title="3.4 以太网的MAC层"></a>3.4 以太网的MAC层</h3><ol><li><p>MAC地址<br>“MAC地址”又叫做硬件地址或物理地址，实际上就是适配器地址或适配器标识符EUI-48。高位24位：厂家，低位24位由厂家自行指派</p></li><li><p>MAC帧的格式<br>常用的以太网MAC帧格式有两种标准 ： DIX Ethernet V2 标准IEEE 的 802.3 标准。V2使用较多，如图：<br><img src="http://img.blog.csdn.net/20131017004657921?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZnR4Y19ibG9n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="图片来源：见水印blog.csdn.net/ftxc_blog/article/details/12811235"><br>以太网V2的MAC帧较为简单，有五个字段组成。<br>前两个字段分别为6字长的目标地址和源地址字段。第三个字段是2字节的类型字段，用来标志上一层使用的是什么协议，以便把收到的MAC帧的数据上交给上一层的这个协议。后面数据字段46~1500字节，FCS字段4个字节。</p></li></ol><h3 id="3-5-扩展的以太网"><a href="#3-5-扩展的以太网" class="headerlink" title="3.5 扩展的以太网"></a>3.5 扩展的以太网</h3><ol><li><p>在物理层扩展—集线器 P91<br>现在，双绞线以太网成为以太网的主流类型，扩展主机和集线器之间的距离的一种简单方法就是使用光纤(通常是一对光纤)和一对光纤调制解调器。</p><p>光纤调制解调器的作用，是进行电信号和光信号的转换。</p></li></ol><ol><li><p>在数据链路层扩展—网桥（自学习算法）P94<br><strong>注：在数据链路层扩展以太网要使用网桥</strong><br>网桥工作在数据链路层，它根据MAC帧的目的地址对收到的帧进行转发或过滤。当网桥收到一个帧时，并不是向所有的接口转发这个帧，而是检查此帧的目的MAC地址，然后再确定将该帧转发到哪一个接口，或者是把它丢弃(即过滤)。</p><blockquote><p>具体可以参考这篇博客：<br><a href="http://blog.csdn.net/cainv89/article/details/50651489" target="_blank" rel="noopener">http://blog.csdn.net/cainv89/article/details/50651489</a></p></blockquote></li></ol><ol><li>虚拟局域网-交换机P98<br>多接口网桥即交换式集线器常称为以太网交换机。利用以太网交换机可以很方便地 实现虚拟局域网，虚拟局域网协议允许在以太网的帧格式中插入一个 4 字节的标识符，称为 VLAN 标记。</li></ol><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="4-1-网际协议IP"><a href="#4-1-网际协议IP" class="headerlink" title="4.1 网际协议IP"></a>4.1 网际协议IP</h3><p> 网际协议IP是TCP/IP体系中两个最重要的协议之一，也是最重要的因特网标准协议之一。与IP协议配套是用的四个协议：<br> 1.<strong>地址解析协议ARP</strong>：是解决同一个局域网上的主机或路由器的IP地址和硬件地址的映射问题。<br> 2.<strong>逆地址解析协议RARP</strong>：是解决同一个局域网上的主机或路由器的硬件地址和IP地址的映射问题。<br> 3.<strong>网际控制报文协议ICMP</strong>：提供差错报告和询问报文，以提高IP数据交付成功的机会<br> 4.<strong>网际组管理协议IGMP</strong>：：用于探寻、转发本局域网内的组成员关系。</p><p> <img src="http://img.blog.csdn.net/20180107020713763?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHVzaGh3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="图片来源网络"></p><h4 id="4-1-1-虚拟互连网络"><a href="#4-1-1-虚拟互连网络" class="headerlink" title="4.1.1 虚拟互连网络"></a>4.1.1 虚拟互连网络</h4><p> 因为没有一种单一的网络能够适应所有的用户需求，所以网络互连也变得困难，所以需要一些中间设备：</p><ul><li>物理层中间设备：转发器(repeater)</li><li>数据链路层中间设备：网桥或桥接器(bridge)</li><li>网络层中间设备：路由器(router)</li><li><p>网络层以上的中间设备：网关(gateway)</p><blockquote><p> 具体各层的设备说明可以看这篇博客“网络设备”部分：<br> <a href="http://blog.csdn.net/hushhw/article/details/78489470" target="_blank" rel="noopener">http://blog.csdn.net/hushhw/article/details/78489470</a></p></blockquote></li></ul><h4 id="4-1-2-分类的IP地址-P113"><a href="#4-1-2-分类的IP地址-P113" class="headerlink" title="4.1.2 分类的IP地址 P113"></a>4.1.2 分类的IP地址 P113</h4><p> <strong>IP 地址</strong>就是给每个连接在因特网上的主机（或路由器）分配一个在全世界范围是唯一的 32 位的标识符。由因特网名字与号码指派公司ICANN进行分配。</p><p> IP地址编制方法的三个阶段：</p><ul><li>分类的IP地址</li><li>子网的划分</li><li>构成超网</li></ul><p> 每一类地址都由 <strong>网络号</strong> net-id和 <strong>主机号</strong> host-id组成<br> <strong>主机号中全0表示网络地址，全1表示广播地址</strong></p><p> <img src="http://img.blog.csdn.net/20180107023041372?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHVzaGh3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="图片来源网络"><br> <img src="http://img.blog.csdn.net/20180107023943820?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHVzaGh3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="图片来源网络"></p><ul><li><p>A类</p><ol><li>由1字节的网络地址和3字节主机地址组成</li><li>网络地址的最高位必须是“0“，可指派的网络数为128-2，减2的原因是0.0.0.0对应“本网络”，另外一个是127.0.0.1是本地软件的回环地址，用于测试自己电脑IP地址是否可用。</li><li>地址范围1.0.0.0到126.255.255.255</li><li>最大主机数为256<sup>3</sup>-2=16777214台，减2的原因是全0的主机号字段代表该IP地址是”本主机“，全1表示”所有的“，表示该网络上的所有主机</li></ol></li><li><p>B类</p><ol><li>由2字节的网络地址和2字节主机地址组成</li><li>网络地址的最高位必须是“10”，可指派的网络数为 2<sup>14</sup> -1，因为最高位为10，所以不存在全0全1的情况，但是B类网络地址128.0.0.0是不指派的，可指派最小网络地址是128.1.0.0</li><li>地址范围128.0.0.0-191.255.255.255</li><li>最大主机数为256<sup>2</sup>-2=65534台，减2同样是全0全1情况。</li></ol></li><li><p>C类</p><ol><li>由3字节的网络地址和1字节主机地址组成</li><li>网络地址的最高位必须是“110”，可指派的网络数为2<sup>21</sup>-1，192.0.0.0不指派，最小可指派网络地址是192.0.1.0</li><li>地址范围192.0.0.0-223.255.255.255</li><li>最大主机数为256-2=254台，减2同样是全0全1情况。</li></ol></li><li><p>D类是多播地址，“lll0”开始</p></li><li><p>E类地址保留为今后使用，“llll0”开头</p></li></ul><h4 id="4-1-3-IP地址与硬件地址"><a href="#4-1-3-IP地址与硬件地址" class="headerlink" title="4.1.3 IP地址与硬件地址"></a>4.1.3 IP地址与硬件地址</h4><p> <strong>硬件地址</strong>是数据链路层和物理层使用的地址<br> <strong>IP地址</strong>是网络层和以上各层使用的地址，是一种逻辑地址</p><p> IP地址放在IP数据报的首部，而硬件地址放在MAC帧的首部。当数据报放入数据链路层的MAC帧中后，整个IP数据报就成为MAC帧的数据，因而在数据链路层看不见数据报的IP地址。</p><h4 id="4-1-4-地址解析协议ARP"><a href="#4-1-4-地址解析协议ARP" class="headerlink" title="4.1.4 地址解析协议ARP"></a>4.1.4 地址解析协议ARP</h4><p> ARP是解决<strong>同一个局域网上</strong>的主机或路由器的 IP 地址和硬件地址的映射问题。</p><p> 每一个主机都设有一个ARP高速缓存(ARP  cache)，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。<br> 如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。</p><h4 id="4-1-5-IP数据报"><a href="#4-1-5-IP数据报" class="headerlink" title="4.1.5 IP数据报"></a>4.1.5 IP数据报</h4><ol><li><p>IP数据报格式<br>一个IP数据报由首部（20 字节+可选字段）和数据两部分组成<br><img src="http://img.blog.csdn.net/20180107045436621?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHVzaGh3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="图片来源网络"><br><img src="http://img.blog.csdn.net/20180107045539001?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHVzaGh3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="图片来源网络"></p></li><li><p>分组转发<br> (1) 从数据报的首部提取目的主机的 IP 地址 D, 得出目的网络地址为 N。<br> (2) 若网络 N 与此路由器直接相连，则把数据报直接交付目的主机 D；否则是间接交付，执行(3)。<br> (3) 若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行(4)。<br> (4) 若路由表中有到达网络 N 的路由，则把数据报传送给路由表指明的下一跳路由器；否则，执行(5)。<br> (5) 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行(6)<br> (6) 报告转发分组出错。</p></li></ol><h3 id="4-2-划分子网-P128"><a href="#4-2-划分子网-P128" class="headerlink" title="4.2 划分子网 P128"></a>4.2 划分子网 P128</h3><ol><li><p>两级IP地址缺陷：</p><ol><li>IP 地址空间的利用率有时很低。</li><li>给每一个物理网络分配一个网络号会使路由表变得太大因而使网络性能变坏。</li><li>两级的 IP 地址不够灵活</li></ol></li><li><p>子网划分的基本思路：</p><ol><li>划分子网纯属一个单位内部的事情，单位对外仍然表现为没有划分子网的网络。</li><li>划分子网的方法是从主机号借用若干个位作为子网号。</li><li>路由器在收到IP数据报后，按目标网络号和子网号定位目标子网</li></ol></li><li><p>子网掩码<br>子网掩码是一个网络或一个子网的重要属性</p></li></ol><blockquote><p>这里要会已知IP地址，子网掩码，求网络地址</p></blockquote><h3 id="4-3-构造超网（无分类编址CIDR）"><a href="#4-3-构造超网（无分类编址CIDR）" class="headerlink" title="4.3 构造超网（无分类编址CIDR）"></a>4.3 构造超网（无分类编址CIDR）</h3><ol><li><p><strong>CIDR（无分类域间路由选择）</strong>的主要特点：</p><ul><li>CIDR消除了传统的A、B、C类地址以及划分子网的概念，用<strong>网络前缀</strong>代替网络号和子网号，后面的部分指明主机。因此，CIDR使IP地址从三级编址(使用子网掩码)，又回到了两级编址，但这已是无分类的两级编址。</li><li>CIDR把网络前缀相同的连续的IP地址组成一个”CIDR地址块”只要知道CIDR地址块中的任何一个地址，就可以知道这地址块的起始地址(即最小地址)和最大地址，以及地址块中的地址数。</li></ul></li><li><p>地址掩码：是一连串的1和0组成，而1的个数救赎网络前缀长度。在斜线记法中。斜线后面的数字就是地址掩码中1的个数。</p></li><li><p>构成超网：由于一个CIDR地址块中含有很多地址，所以在路由表中就利用CIDR地址块来查找目标网络，这种地址的聚合常称为路由聚合，也称构成超网。</p></li></ol><h3 id="4-4-网际控制报文协议ICMP"><a href="#4-4-网际控制报文协议ICMP" class="headerlink" title="4.4 网际控制报文协议ICMP"></a>4.4 网际控制报文协议ICMP</h3><p>为了更有效地转发IP数据报和提高交付成功的机会，在网际层使用了ICMP，ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告。</p><ol><li><p>ICMP报文的种类</p><ul><li>ICMP差错报告报文</li><li>ICMP询问报文</li></ul></li><li><p>ICMP 差错报告报文共有 5 种：</p><ul><li>终点不可达</li><li>源点抑制(Source quench)</li><li>时间超过</li><li>参数问题</li><li>改变路由（重定向）(Redirect)</li></ul></li><li><p>ICMP 询问报文有两种：</p><ul><li>回送请求和回答报文</li><li>时间戳请求和回答报文</li></ul></li></ol><h3 id="4-5-路由选择协议"><a href="#4-5-路由选择协议" class="headerlink" title="4.5 路由选择协议"></a>4.5 路由选择协议</h3><ol><li><p>两大类路由选择协议：</p><ul><li><strong>内部网关协议 IGP</strong>：一个自治系统内部使用的路由选择协议。有多种协议，如 RIP 和OSPF 协议。</li><li><strong>外部网关协议EGP</strong>：一个自治系统的边界，将路由选择信息传递到另一个自治系统中。目前使用的就是BGP</li></ul><p>RIP协议的优缺点：</p><ul><li>RIP 存在的一个问题是当网络出现故障时，要经过比较长的时间才能将此信息传送到所有的路由器。</li><li>RIP 协议最大的优点就是实现简单，开销较小。</li><li>RIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）。</li><li>路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。   </li></ul><blockquote><p>书上例题P149 例4-5<br>更新路由表</p></blockquote></li></ol><p> RIP是一种分布式的基于距离向量的路由选择协议，其主要特点：<br>（1）仅和相邻路由器交换信息。<br>（3）按固定的时间间隔交换路由信息，例如，每隔30秒。 </p><p> OSPF最主要的特征就是使用分布式的链路状态协议，其主要特点：<br>（1）使用洪泛法向本自治系统中所有路由器发送信息。<br>（2）发送的信息是与本路由器相邻的所有路由器的链路状态。<br>（3）只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。 </p><p> BGP是不同自治系统的路由器之间交换路由信息的协议，它采用路径向量路由选择协议，其主要特点：<br>（2）自治系统AS之间的路由选择必须考虑有关策略。<br>（3）BGP只能力求寻找一条能够到达目的网络且比较好的路由，而并非要寻找一条最佳路由。</p><h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><h3 id="5-1-运输层协议概述"><a href="#5-1-运输层协议概述" class="headerlink" title="5.1 运输层协议概述"></a>5.1 运输层协议概述</h3><ol><li><p>运输层功能</p><ul><li>运输层为应用进程之间提供端到端的逻辑通信（但网络层是为主机之间提供逻辑通信）</li><li>运输层还要对收到的报文进行差错检测</li><li>运输层需要有两种不同的运输协议，即面向连接的 <strong>TCP</strong> 和无连接的 <strong>UDP</strong></li></ul></li><li><p>运输层的两个主要协议<br>TCP/IP 的运输层有两个不同的协议：</p><ul><li><strong>用户数据报协议 UDP</strong>(User Datagram Protocol)</li><li><strong>传输控制协议 TCP</strong>(Transmission Control Protocol)</li></ul><p>UDP 在传送数据之前不需要先建立连接。对方的运输层在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 是一种最有效的工作方式。</p><p>TCP 则提供面向连接的服务。TCP 不提供广播或多播服务。由于 TCP 要提供可靠的、面向连接的运输服务，因此不可避免地增加了许多的开销。这不仅使协议数据单元的首部增大很多，还要占用许多的处理机资源。  </p></li></ol><p><img src="http://img.blog.csdn.net/20180108005811225?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHVzaGh3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="图片来源网络"></p><ol><li><p>运输层的端口<br>TCP/IP的运输层的端口用一个 16 位端口号进行标志<br>端口号只具备本地意义，即端口号只是为了标志本计算机应用层中的各进程。 </p><p>客户发起通讯请求时，必须先知道对方服务器的IP地址和端口号，运输层的端口号分为下面三大类：</p></li></ol><ul><li><p>熟知端口号，数值一般为 0~1023。<br> 一些常用的数值端口号：<br>  <strong>FTP 21</strong><br>  <strong>LELNET 23</strong><br>  <strong>SMTP 25</strong><br>  <strong>DNS 53</strong><br>  <strong>TFTP 69</strong><br>  <strong>HTTP 80</strong><br>  <strong>SNMP 161</strong><br>  <strong>SNMP(trap) 162</strong></p><ul><li><p>登记端口号，数值为1024~49151，为没有熟知端口号的应用程序使用的。</p></li><li><p>客户端口号或短暂端口号，数值为49152~65535，留给客户进程选择暂时使用。</p></li></ul></li></ul><h3 id="5-2-用户数据报协议-UDP"><a href="#5-2-用户数据报协议-UDP" class="headerlink" title="5.2 用户数据报协议 UDP"></a>5.2 用户数据报协议 UDP</h3><ol><li>UDP的主要特点：<ul><li><strong>UDP 是无连接的</strong>，即发送数据之前不需要建立连接。</li><li><strong>UDP 使用尽最大努力交付</strong>，即不保证可靠交付，同时也不使用拥塞控制</li><li><strong>UDP 是面向报文的</strong></li><li><strong>UDP 没有拥塞控制</strong>，很适合多媒体通信的要求。</li><li><strong>UDP 支持一对一、一对多、多对一和多对多的交互通信</strong></li><li><strong>UDP 的首部开销小</strong>，只有 8 个字节</li></ul></li></ol><h3 id="5-3-传输控制协议-TCP"><a href="#5-3-传输控制协议-TCP" class="headerlink" title="5.3 传输控制协议 TCP"></a>5.3 传输控制协议 TCP</h3><ol><li>TCP的主要特点：<ul><li><strong>TCP 是面向连接的运输层协议</strong></li><li><strong>每一条 TCP 连接只能有两个端点(endpoint)</strong>，每一条 TCP 连接只能是点对点的（一对一）</li><li><strong>TCP 提供可靠交付的服务</strong></li><li><strong>TCP 提供全双工通信</strong></li><li><strong>面向字节流</strong>  </li></ul></li></ol><h3 id="5-4-可靠运输的工作原理"><a href="#5-4-可靠运输的工作原理" class="headerlink" title="5.4 可靠运输的工作原理"></a>5.4 可靠运输的工作原理</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计算机网络复习笔记&quot;&gt;&lt;a href=&quot;#计算机网络复习笔记&quot; class=&quot;headerlink&quot; title=&quot;计算机网络复习笔记&quot;&gt;&lt;/a&gt;计算机网络复习笔记&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;本复习笔记基于谢希仁的《计算机网络》第五版教材整理。&lt;/li&gt;
&lt;/ul
      
    
    </summary>
    
      <category term="学习" scheme="https://hushhw.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="计算机网络" scheme="https://hushhw.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="复习笔记" scheme="https://hushhw.cn/tags/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《WebGL编程指南》学习笔记——4.绘制一个点</title>
    <link href="https://hushhw.cn/2017/12/24/04WebGL04/"/>
    <id>https://hushhw.cn/2017/12/24/04WebGL04/</id>
    <published>2017-12-24T08:39:08.000Z</published>
    <updated>2018-02-07T10:53:16.344Z</updated>
    
    <content type="html"><![CDATA[<p>之前，我们学习了如何建立一个WebGL程序，如何使用一些简单的WebGL相关函数。这一节，我们进一步在一个示例程序中绘制一个最简单的图形：一个点。这一小节中我们要弄懂一个重要的概念：着色器。</p><hr><p>我们进一步在一个示例程序中绘制一个最简单的图形：一个点。</p><p>此系列我编写的源码都可以在我的github下载到：<a href="https://github.com/hushhw/WebGL-Programming-Guide/tree/master/02HelloPoint1" target="_blank" rel="noopener">https://github.com/hushhw/WebGL-Programming-Guide/tree/master/02HelloPoint1</a></p><h2 id="HelloPoint1-html"><a href="#HelloPoint1-html" class="headerlink" title="HelloPoint1.html"></a>HelloPoint1.html</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"></span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line"></span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;title&gt;Draw a point&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body onload=&quot;main()&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;canvas id=&quot;webgl&quot; width=&quot;400&quot; height=&quot;400&quot;&gt;</span><br><span class="line"></span><br><span class="line">        Please use the browser supporting &quot;canvas&quot;.</span><br><span class="line"></span><br><span class="line">    &lt;/canvas&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;script src=&quot;../lib/webgl-utils.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script src=&quot;../lib/webgl-debug.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script src=&quot;../lib/cuon-utils.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script src=&quot;HelloPoint1.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>在HelloCanvas.html文件中比较简单，需要注意的是需要引入一些其他的文件来支持webgl，文件下载可以到<a href="https://github.com/hushhw/WebGL-Programming-Guide/tree/master/lib自行下载。" target="_blank" rel="noopener">https://github.com/hushhw/WebGL-Programming-Guide/tree/master/lib自行下载。</a></p><p><br></p><h2 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h2><p>WebGL依赖于一种新的称为着色器（shader）的绘图机制。着色器提供了灵活且强大的绘制二维或三维图形的方法，所有WebGL程序必须使用它。</p><p>HelloPoint1.js是这本书中使用着色器的第一个WebGL程序，在代码中，着色器程序是以字符串的形式“嵌入”在JavaScript文件中的，在程序真正开始运行前它已经设置好了。</p><p><br></p><p>WebGL需要两种着色器：</p><h3 id="1-顶点着色器（-Vertex-shader-）"><a href="#1-顶点着色器（-Vertex-shader-）" class="headerlink" title="1. 顶点着色器（ Vertex shader ）"></a><strong>1. 顶点着色器（ Vertex shader ）</strong></h3><p>顶点着色器是用来描述顶点特性（如位置、颜色等）的程序。<strong>顶点</strong>（vertex）是指二维或三维空间中的一个点，如二维或三维图形的端点或交点。</p><p><br></p><h3 id="2-片元着色器（Fragment-shader）"><a href="#2-片元着色器（Fragment-shader）" class="headerlink" title="2.片元着色器（Fragment shader）"></a><strong>2.片元着色器（Fragment shader）</strong></h3><p>片元着色器是进行逐片元处理过程如光照的程序。<strong>片元</strong>（fragment）是一个WebGL术语，你可以将其理解为像素（图像的单元）。</p><p><br></p><p>在后续，我们会详细的学习着色器。简单的说，在三维场景中，仅仅用线条和颜色把图形画出来是远远不够的。你必须考虑如光线照上去后，或者观察者的视角发生变化时，对场景会有什么影响。着色器可以高度灵活的完成这些工作；提供各种渲染效果。这也就是现在制作的三维场景如此逼真的原因。</p><p><img src="http://img.blog.csdn.net/20171224155525787?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHVzaGh3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>图的左侧是两个浏览器窗口。它们是同一个窗口，上面一个是执行JS程序之前的窗口，下面一个执行之后的。 </p><p>程序执行的流程大概是：</p><ul><li><p>运行JS程序，调用了WebGL的相关方法。 </p></li><li><p>顶点着色器和片元着色器会执行，在颜色缓冲区内进行绘制，这时就清空了绘图区。</p></li><li><p>颜色缓冲区中的内容会自动在浏览器的 &lt; canvas &gt;上显示出来。</p></li></ul><p><img src="http://img.blog.csdn.net/20171224155749311?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHVzaGh3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><br></p><h2 id="初始化着色器"><a href="#初始化着色器" class="headerlink" title="初始化着色器"></a>初始化着色器</h2><p>“初始化着色器”我们调用辅助函数initShaders()对字符串形式的着色器进行了初始化。该函数被定义在lib文件夹下，前文提到下载方式了。</p><p><img src="http://img.blog.csdn.net/20171224161606349?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHVzaGh3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><img src="http://img.blog.csdn.net/20171224161654909?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHVzaGh3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>Web系统由两部分组成，即顶点着色器和片元着色器。在初始化着色器之前，顶点着色器和片元着色器都是空白的，我们需要将字符串形式的着色器代码从JavaScript传给WebGL系统，并建立着色器，这就是initShaders()函数要做的事情。着色器运行在WebGL系统中，而不是JavaScript程序中。</p><p>initShaders()函数执行成功后，着色器被创建好了并随时可以使用，顶点着色器将被首先执行，它对gl_Position变量和gl_PointSize变量进行赋值，并将它们传入片元着色器，然后片元着色器再执行。实际上，片元着色器接收到的是经过光栅化（将几何图形变为二维图像的过程）处理后的片元值；现在可以简单认为这两个变量从顶点着色器传入了片元着色器。</p><h2 id="HelloPoint1-js"><a href="#HelloPoint1-js" class="headerlink" title="HelloPoint1.js"></a>HelloPoint1.js</h2><p>回到这个实例中来：示例程序的任务是，在屏幕上绘制一个10像素大小的点 ，它用到了两个着色器：</p><ul><li><p>顶点着色器指定了点的位置和尺寸。本例中：点的位置是（0.0，0.0，0.0），尺寸是10.0像素</p></li><li><p>片元着色器指定了点的颜色。本例中，点的颜色是红色（1.0，0.0，0.0，1.0）。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"></span><br><span class="line"> * Created by hushhw on 17/12/12.</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">//HelloPoint1.js</span><br><span class="line"></span><br><span class="line">//顶点着色器程序</span><br><span class="line"></span><br><span class="line">var VSHADER_SOURCE =</span><br><span class="line"></span><br><span class="line">    &apos;void main() &#123;\n&apos; +</span><br><span class="line"></span><br><span class="line">    &apos;gl_Position = vec4(0.5, 0.0, 0.0, 1.0);\n&apos; + //设置坐标</span><br><span class="line"></span><br><span class="line">    &apos;gl_PointSize = 50.0;\n&apos; + //设置尺寸</span><br><span class="line"></span><br><span class="line">    &apos;&#125;\n&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//片元着色器程序</span><br><span class="line"></span><br><span class="line">var FSHADER_SOURCE=</span><br><span class="line"></span><br><span class="line">    &apos;void main()&#123;\n&apos;+</span><br><span class="line"></span><br><span class="line">    &apos;gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n&apos;+ //设置颜色</span><br><span class="line"></span><br><span class="line">    &apos;&#125;\n&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function main() &#123;</span><br><span class="line"></span><br><span class="line">    var canvas = document.getElementById(&apos;webgl&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    var gl = getWebGLContext(canvas);</span><br><span class="line"></span><br><span class="line">    if(!gl)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        console.log(&apos;Failed to get the rendering context for WebGL&apos;);</span><br><span class="line"></span><br><span class="line">        return ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //初始化着色器</span><br><span class="line"></span><br><span class="line">    if(!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE))&#123;</span><br><span class="line"></span><br><span class="line">        console.log(&apos;Failed to initialize shaders.&apos;);</span><br><span class="line"></span><br><span class="line">        return ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    gl.clearColor(0.0, 0.0, 0.0, 1.0);</span><br><span class="line"></span><br><span class="line">    gl.clear(gl.COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    gl.drawArrays(gl.POINTS, 0, 1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个文件包含三个部分：</p><ul><li><p>顶点着色器程序（GLSL ES 语言）</p></li><li><p>片元着色器程序（GLSL ES 语言）</p></li><li><p>主程序（JavaScript语言）</p></li></ul><h3 id="顶点着色器程序和片元着色器程序"><a href="#顶点着色器程序和片元着色器程序" class="headerlink" title="顶点着色器程序和片元着色器程序"></a>顶点着色器程序和片元着色器程序</h3><p><img src="http://img.blog.csdn.net/20171224160348903?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHVzaGh3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>着色器程序代码必须预先处理成单个字符串的形式，所以我们用+号将多行字符串连成一个长字符串。（每一行以\n结束，这是由于当着色器内部出错时，就能获取出错的行号，这对于检查源代码中的错误很有帮助；但是，\n并不是必须的。为了更容易维护，也可以把着色器代码写到单独的文件中（就像javaScript文件一样），然后通过javaScript程序从文件中读取出来加载。）</p><p>就像JS一样，着色器程序使用 = 操作符为变量赋值。首先将点的位置赋值给 gl_Position 变量，然后将点的尺寸赋值给 gl_PointSize 变量，这两个变量是内置在顶点着色器中，而且有特殊含义；gl_Position 表示顶点的位置，gl_PointSize 表示点的尺寸。</p><p>在看代码的时候你可能会有疑问，好像在定义顶点着色器时的类型和JS不一样。那是因为GLSL ES是一种强类型的编程语言，也就是说，开发者必须明确指出某个变量是某种“类型”的。 </p><p>下面是这一节出现在GLSL ES代码中的几种类型：</p><p><img src="http://img.blog.csdn.net/20171224162729559?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHVzaGh3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><em>注意：如果向某类型的变量赋一个不同类型的值。就会出错，例如，gl_PointSize 是浮点型的变量，你就必须向其赋浮点型的值。</em> </p><p>在赋值给 gl_Position 时，我们添加了1.0作为第4个分量。由4个分量组成的矢量被称为齐次坐标。因为它能够提高处理三维数据的效率，所以在三维图形中被大量使用。虽然齐次坐标是四维的，但如果其最后一个分量是 1.0，那么这个齐次坐标就可以表示“前三个分量为坐标值”的那各个点。所以，当你需要用齐次坐标表示顶点坐标的时候，只要将最后一个分量赋为 1.0 就可以了。</p><p><br></p><h3 id="主程序"><a href="#主程序" class="headerlink" title="主程序"></a>主程序</h3><p><img src="http://img.blog.csdn.net/20171224161103636?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHVzaGh3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>main()函数的执行流程：</p><p><img src="http://img.blog.csdn.net/20171224161210334?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHVzaGh3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>这个流程和上一节的区别就是增加了“初始化着色器”和“绘图”部分。</p><h4 id="初始化着色器-1"><a href="#初始化着色器-1" class="headerlink" title="初始化着色器"></a>初始化着色器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//初始化着色器</span><br><span class="line"></span><br><span class="line">    if(!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE))&#123;</span><br><span class="line"></span><br><span class="line">        console.log(&apos;Failed to initialize shaders.&apos;);</span><br><span class="line"></span><br><span class="line">        return ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​    </p><h4 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h4><p>首先我们清空绘制区域，然后我们使用 gl.drawArrays(）来进行绘制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">gl.drawArrays(gl.POINTS, 0, 1);</span><br></pre></td></tr></table></figure><p>gl.drawArrays(）是一个强大的函数，它可以用来绘制各种图形：</p><p><img src="http://img.blog.csdn.net/20171224163102828?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHVzaGh3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><em>示例函数调用该函数时，因为我么绘制的是单独的点，所以设置第1个参数为 gl.POINTS， 设置第2个参数为0，表示从第1个顶点（虽然只有1个顶点）开始画，第3个参数 count 为1，表示在这个简单的程序中仅绘制了1个点。</em></p><p><br></p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>一旦顶点着色器执行完后，片元着色器就会开始执行，调用main()函数，将颜色值（红色）赋给gl_FragColor。最后，一个红色的10像素大小的点就被绘制在了（0.0，0.0，0.0，1.0）处，也就是绘制区域的中心位置。</p><p><img src="http://img.blog.csdn.net/20171224163358200?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHVzaGh3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><br></p><p>下小节我们介绍坐标系统</p><p><br></p><blockquote><p>文章内容借鉴于：</p><p>《WebGL编程指南》</p><p><a href="http://www.cnblogs.com/mirror-pc/p/4181398.html" target="_blank" rel="noopener">http://www.cnblogs.com/mirror-pc/p/4181398.html</a></p><p><a href="http://blog.csdn.net/weixin_40282619/article/details/78030629" target="_blank" rel="noopener">http://blog.csdn.net/weixin_40282619/article/details/78030629</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前，我们学习了如何建立一个WebGL程序，如何使用一些简单的WebGL相关函数。这一节，我们进一步在一个示例程序中绘制一个最简单的图形：一个点。这一小节中我们要弄懂一个重要的概念：着色器。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我们进一步在一个示例程序中绘制一个最简单的图形：一个点。&lt;
      
    
    </summary>
    
      <category term="学习" scheme="https://hushhw.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="WebGL" scheme="https://hushhw.cn/tags/WebGL/"/>
    
  </entry>
  
  <entry>
    <title>《WebGL编程指南》学习笔记——3.在Canvas中使用WebGL</title>
    <link href="https://hushhw.cn/2017/12/24/03WebGL03/"/>
    <id>https://hushhw.cn/2017/12/24/03WebGL03/</id>
    <published>2017-12-23T16:08:21.000Z</published>
    <updated>2018-02-07T10:53:12.874Z</updated>
    
    <content type="html"><![CDATA[<ul><li>上一节学习了使用&lt; canvas &gt;元素绘制二维图形，这一节里面我们在&lt; canvas &gt;中使用WebGL</li></ul><p>这一小节中我们通过个实例来讲解在&lt; canvas &gt;中使用WebGL</p><p>此系列我编写的源码都可以在我的github下载到：<a href="https://github.com/hushhw/WebGL-Programming-Guide/tree/master/01HelloCanvas" target="_blank" rel="noopener">https://github.com/hushhw/WebGL-Programming-Guide/tree/master/01HelloCanvas</a></p><h2 id="HelloCanvas-html"><a href="#HelloCanvas-html" class="headerlink" title="HelloCanvas.html"></a>HelloCanvas.html</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"></span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;meta charset=&quot;utf-8&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;title&gt;Clear canvas&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;body onload=&quot;main()&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;canvas id=&quot;webgl&quot; width=&quot;400&quot; height=&quot;400&quot;&gt;</span><br><span class="line"></span><br><span class="line">Please use the browser supporting &quot;canvas&quot;</span><br><span class="line"></span><br><span class="line">&lt;/canvas&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script src=&quot;../lib/webgl-utils.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src=&quot;../lib/webgl-debug.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src=&quot;../lib/cuon-utils.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src=&quot;HelloCanvas.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>在HelloCanvas.html文件中比较简单，需要注意的是需要引入一些其他的文件来支持webgl，文件下载可以到<a href="https://github.com/hushhw/WebGL-Programming-Guide/tree/master/lib自行下载。" target="_blank" rel="noopener">https://github.com/hushhw/WebGL-Programming-Guide/tree/master/lib自行下载。</a></p><h2 id="HelloCanvas-js"><a href="#HelloCanvas-js" class="headerlink" title="HelloCanvas.js"></a>HelloCanvas.js</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//HelloCanvas.js</span><br><span class="line"></span><br><span class="line">function main()&#123;</span><br><span class="line"></span><br><span class="line">//获取&lt;canvas&gt;元素</span><br><span class="line"></span><br><span class="line">var canvas = document.getElementById(&apos;webgl&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//获取WebGl绘图上下文</span><br><span class="line"></span><br><span class="line">var gl = getWebGLContext(canvas);</span><br><span class="line"></span><br><span class="line">if(!gl)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">console.log(&apos;Failed to get the rendering context for WebGL&apos;);</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//指定清空&lt;canvas&gt;的颜色</span><br><span class="line"></span><br><span class="line">gl.clearColor(1.0, 0.0, 0.0, 1.0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//清空&lt;canvas&gt;</span><br><span class="line"></span><br><span class="line">gl.clear(gl.COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回顾一下上一篇提到的绘制二维图形的三个步骤：</p><ul><li><p>获取 &lt; canvas &gt; 元素 </p></li><li><p>获取绘图上下文 </p></li><li><p>设置 &lt; canvas &gt;颜色</p></li><li><p>清空&lt; canvas &gt;</p></li></ul><p>在main()函数中，我们通过id找到&lt; canvas &gt;标签，这里跟绘制2d图形的步骤是一模一样的。</p><h3 id="获取绘图上下文"><a href="#获取绘图上下文" class="headerlink" title="获取绘图上下文"></a>获取绘图上下文</h3><p>在绘制2d图形的时候，我们是通过调用canvas的getContext方法，传入“2d”参数来获取2d图形的回绘图上下文的。</p><p>这里需要解释一下，通常来说，我们应该使用canvas.getContext()函数来获取绘图上下文（就像之前那样）。但是在获取WebGL绘图上下文时，canvas.getContext()函数接收的参数，在不同浏览器中会不同（虽然大部分浏览器都接收字符串“expeimental-webgl”或“webgl”，但并非所有浏览器都这样），所以我们使用getWebGLContext(canvas)来隐藏不同浏览器之间的差异。</p><p>getWebGLContext(canvas, opt_debug)函数位于cuon-utils.js文件中。</p><p>getWebGLContext(canvas, opt_debug)函数的功能是：获取WebGL绘图上下文；如果开启了debug属性，遇到错误时将在控制台显示错误消息。以下是该函数的具体说明：</p><p><img src="http://images.cnitblog.com/blog/332382/201412/232358247656436.png" alt="图片来源www.cnblogs.com/mirror-pc/p/4181398.html"></p><h3 id="设置-lt-canvas-gt-颜色"><a href="#设置-lt-canvas-gt-颜色" class="headerlink" title="设置 &lt; canvas &gt;颜色"></a>设置 &lt; canvas &gt;颜色</h3><p>在获取到绘图上下文以后，我们就可以绘制图形了，并且可以绘制3d图形了；这也说明，WebGL已经调用成功，我们现在可以使用WebGL函数了。</p><p>　　</p><p>我们将上下文放到名为gl的变量中。有了这个上下文，我们就可以设置颜色来清除&lt; canvas &gt;标签指定的绘图区了。在之前绘制2d图形时，我们在绘制之前就指定了绘图颜色。在WebGL中，是相似的，清空绘图区之前也需要指定颜色。</p><p>gl.clearColor(RGBA)函数通过传入RGBA格式的颜色参数指定颜色。我们在代码中指定了黑色，也可以随意指定其他颜色。在绘制2d图形时，RGBA每个分量的取值范围是0-255之间；但是在WebGL中，每个分量的取值范围是0-1，这和OpenGL保持了一致。一旦指定了颜色，这个颜色就会驻存在WebGL系统中，直到你重新指定新的颜色。在这之前，你可以无数次的使用该颜色进行清除绘图区而无须重新指定。</p><h3 id="清空-lt-canvas-gt"><a href="#清空-lt-canvas-gt" class="headerlink" title="清空&lt; canvas &gt;"></a>清空&lt; canvas &gt;</h3><p>最后调用这个函数，用之前指定的背景色清空（用背景色填充，擦除已经绘制的内容）绘图区域。</p><p>　　</p><p>清除绘图区我们使用 gl.clear(gl.COLOR_BUFFER_BIT)函数；你可能觉得很奇怪，参数不应该是表示绘图区的&lt; canvas &gt;吗？这是由于gl.Clear()函数继承自OpenGL，它基于多基本缓冲区模型，比二维绘图上下文要复杂得多。清空绘图区，实际上是在清空颜色缓冲区（通过指定的颜色去擦除已经绘制的内容），传递gl.COLOR_BUFFER_BIT参数就是在告诉WebGL清空颜色缓冲区。</p><p>　　</p><p>如果在使用该函数之前我们没有指定任何颜色，那么默认会以RGBA(0,0,0,0)作为清除颜色，这个颜色是全透明的，替换出来的结果就是什么颜色都没有，显示为浏览器本身的颜色。</p><p>下小节我们正式开始学习如何使用WebGL绘制基本图形</p><blockquote><p>文章内容借鉴于：</p><p>《WebGL编程指南》</p><p><a href="http://www.cnblogs.com/mirror-pc/p/4181398.html" target="_blank" rel="noopener">http://www.cnblogs.com/mirror-pc/p/4181398.html</a></p><p><a href="http://blog.csdn.net/weixin_40282619/article/details/78030629" target="_blank" rel="noopener">http://blog.csdn.net/weixin_40282619/article/details/78030629</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;上一节学习了使用&amp;lt; canvas &amp;gt;元素绘制二维图形，这一节里面我们在&amp;lt; canvas &amp;gt;中使用WebGL&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这一小节中我们通过个实例来讲解在&amp;lt; canvas &amp;gt;中使用WebGL&lt;/p&gt;
&lt;p&gt;此系列
      
    
    </summary>
    
      <category term="学习" scheme="https://hushhw.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="WebGL" scheme="https://hushhw.cn/tags/WebGL/"/>
    
  </entry>
  
  <entry>
    <title>《WebGL编程指南》学习笔记——2.使用canvas元素</title>
    <link href="https://hushhw.cn/2017/12/21/02WebGL02/"/>
    <id>https://hushhw.cn/2017/12/21/02WebGL02/</id>
    <published>2017-12-21T07:06:40.000Z</published>
    <updated>2018-02-07T10:53:09.829Z</updated>
    
    <content type="html"><![CDATA[<p>上一节初步认识了WebGL，这一小节我们来开始学习使用&lt; canvas &gt;元素绘制二维图形</p><p>WebGL采用HTML5中新引入的&lt; canvas &gt;元素，它定义了网页上的绘图区域，如果没有WebGL，JS只能在&lt; canvas &gt;上绘制二维图形，有了WebGL，就可以在上面绘制三维图形了。</p><h2 id="认识-lt-canvas-gt-标签"><a href="#认识-lt-canvas-gt-标签" class="headerlink" title="认识&lt; canvas &gt;标签"></a>认识&lt; canvas &gt;标签</h2><p>HTML5出现以前，如果你想在网页上显示图像，只能使用HTML提供的原生方案<img>标签。用这个标签显示图像虽然简单，但只能显示静态的图片，不能进行实时绘制和渲染。因为，后来出现了一些第三方解决方案，如Flash Player等。</p><p>​        </p><p>HTML5的出现改变了一切，它引入了&lt; canvas &gt;标签，允许JS动态地绘制图形。</p><p>艺术家们将画布（canvas译为”画布”）作为绘画的地方，类似地，&lt; canvas &gt;标签定义了网页上的绘图区域。有了&lt; canvas &gt;，你就可以使用JS绘制任何你想画的东西。&lt; canvas &gt;提供一些简单的会凸函数，用来描绘点、线、矩形、圆等。</p><h2 id="使用-lt-canvas-gt-标签"><a href="#使用-lt-canvas-gt-标签" class="headerlink" title="使用&lt; canvas &gt;标签"></a>使用&lt; canvas &gt;标签</h2><p>为了在&lt; canvas &gt;上绘制二维图形，需经过以下几个步骤：</p><ul><li><p><strong>创建&lt; canvas &gt;标签，指定绘图范围。</strong></p></li><li><p><strong>利用JavaScript获取到&lt; canvas &gt;标签。</strong></p></li><li><p><strong>向该标签请求二维图形的“绘图上下文”。</strong></p></li><li><p><strong>使用绘图上下文调用相应的绘图函数，绘制二维图形。</strong></p></li></ul><h2 id="HelloCanvas2d实例"><a href="#HelloCanvas2d实例" class="headerlink" title="HelloCanvas2d实例"></a>HelloCanvas2d实例</h2><p>下面是HelloCanvas2d实例，我们利用&lt; canvas &gt;画个矩形，并用红色填充</p><p>此系列我编写的源码都可以在我的github下载到：<a href="https://github.com/hushhw/WebGL-Programming-Guide/tree/master/00HelloCanvas2d" target="_blank" rel="noopener">https://github.com/hushhw/WebGL-Programming-Guide/tree/master/00HelloCanvas2d</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"></span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;meta charset=&quot;utf-8&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;title&gt;Clear canvas&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;body onload=&quot;main()&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;canvas id=&quot;mycanvas&quot; width=&quot;400&quot; height=&quot;400&quot;&gt;</span><br><span class="line"></span><br><span class="line">Please use the browser supporting &quot;canvas&quot;</span><br><span class="line"></span><br><span class="line">&lt;/canvas&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src=&quot;HelloCanvas2d.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//HelloCanvas2d.js</span><br><span class="line"></span><br><span class="line">function main() &#123;</span><br><span class="line"></span><br><span class="line">//获取&lt;canvas&gt;标签</span><br><span class="line"></span><br><span class="line">var canvas = document.getElementById(&quot;mycanvas&quot;);</span><br><span class="line"></span><br><span class="line">//如果没找到&lt;canvas&gt;标签，则输出错误信息</span><br><span class="line"></span><br><span class="line">if (!canvas) &#123;</span><br><span class="line"></span><br><span class="line">console.log(&apos;Failed to retrieve the &lt;canvas&gt; element.&apos;);</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//要在&lt;canvas&gt;上绘制图像，须先获取绘图上下文，“2d”代表我们要绘制二维图形。</span><br><span class="line"></span><br><span class="line">var ctx = canvas.getContext(&quot;2d&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//fillstyle：设置或返回用于填充绘画的颜色、渐变或模式；这里我们设置填充颜色为红色。</span><br><span class="line"></span><br><span class="line">ctx.fillStyle = &quot;red&quot;;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"></span><br><span class="line"> 使用填充颜色填充矩形。</span><br><span class="line"></span><br><span class="line"> fillRect(x,y,width,height)</span><br><span class="line"></span><br><span class="line"> x    矩形左上角的 x 坐标</span><br><span class="line"></span><br><span class="line"> y    矩形左上角的 y 坐标</span><br><span class="line"></span><br><span class="line"> width        矩形的宽度</span><br><span class="line"></span><br><span class="line"> height   矩形的高度</span><br><span class="line"></span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">ctx.fillRect(120, 10, 150, 150);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取-lt-canvas-gt-元素"><a href="#获取-lt-canvas-gt-元素" class="headerlink" title="获取&lt; canvas &gt;元素"></a>获取&lt; canvas &gt;元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//获取&lt;canvas&gt;标签</span><br><span class="line"></span><br><span class="line">var canvas = document.getElementById(&quot;mycanvas&quot;);</span><br><span class="line"></span><br><span class="line">//如果没找到&lt;canvas&gt;标签，则输出错误信息</span><br><span class="line"></span><br><span class="line">if (!canvas) &#123;</span><br><span class="line"></span><br><span class="line">console.log(&apos;Failed to retrieve the &lt;canvas&gt; element.&apos;);</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在HTML文件中通过JS程序获取&lt; canvas &gt;元素。可以使用document.getElementById 的函数来获取。这个方法只有一个参数，就是HTML文件中&lt; canvas &gt;标签的 id 属性</p><p>　　</p><h3 id="通过元素来获取二维图形的绘图上下文"><a href="#通过元素来获取二维图形的绘图上下文" class="headerlink" title="通过元素来获取二维图形的绘图上下文"></a>通过元素来获取二维图形的绘图上下文</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//要在&lt;canvas&gt;上绘制图像，须先获取绘图上下文，“2d”代表我们要绘制二维图形。</span><br><span class="line"></span><br><span class="line">var ctx = canvas.getContext(&quot;2d&quot;);</span><br></pre></td></tr></table></figure><p>&lt; canvas &gt;元素可以同时支持二维图形和三维图形，它不直接提供绘图方法，而是提供一种叫<strong>上下文</strong>的机制来绘图。</p><p>　　</p><p>在上述代码中，canvas.getContext() 方法的参数制订了上下文的类型（二维或三维）。如果你想要绘制二维图形，就必须指定为2d（区分大小写）。</p><p>　　</p><p>　　</p><h3 id="绘制二维图形"><a href="#绘制二维图形" class="headerlink" title="绘制二维图形"></a>绘制二维图形</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//fillstyle：设置或返回用于填充绘画的颜色、渐变或模式；这里我们设置填充颜色为红色。</span><br><span class="line"></span><br><span class="line">ctx.fillStyle = &quot;red&quot;;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"></span><br><span class="line"> 使用填充颜色填充矩形。</span><br><span class="line"></span><br><span class="line"> fillRect(x,y,width,height)</span><br><span class="line"></span><br><span class="line"> x    矩形左上角的 x 坐标</span><br><span class="line"></span><br><span class="line"> y    矩形左上角的 y 坐标</span><br><span class="line"></span><br><span class="line"> width        矩形的宽度</span><br><span class="line"></span><br><span class="line"> height   矩形的高度</span><br><span class="line"></span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">ctx.fillRect(120, 10, 150, 150);</span><br></pre></td></tr></table></figure><p>　　&lt; canvas &gt;的坐标系横轴为x轴（正方向朝右），纵轴为y轴（正方向朝下）。原点（0，0）在左上方。fillRect方法中设置的x，y指的是从&lt; canvas &gt;坐标的开始算，右移x像素，下移y像素的位置，就是矩形左上角的位置。如图所示：</p><p>　　<img src="http://img.blog.csdn.net/20171216202917965?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHVzaGh3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>下小节我们正式开始学习如何在&lt; canvas &gt;中使用WebGL</p><blockquote><p>文章内容借鉴于： </p><p>《WebGL编程指南》</p><p> <a href="http://www.cnblogs.com/mirror-pc/p/4179062.html" target="_blank" rel="noopener">http://www.cnblogs.com/mirror-pc/p/4179062.html</a></p><p><a href="http://blog.csdn.net/weixin_40282619/article/details/78019085" target="_blank" rel="noopener">http://blog.csdn.net/weixin_40282619/article/details/78019085</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一节初步认识了WebGL，这一小节我们来开始学习使用&amp;lt; canvas &amp;gt;元素绘制二维图形&lt;/p&gt;
&lt;p&gt;WebGL采用HTML5中新引入的&amp;lt; canvas &amp;gt;元素，它定义了网页上的绘图区域，如果没有WebGL，JS只能在&amp;lt; canvas &amp;g
      
    
    </summary>
    
      <category term="学习" scheme="https://hushhw.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="WebGL" scheme="https://hushhw.cn/tags/WebGL/"/>
    
  </entry>
  
  <entry>
    <title>《WebGL编程指南》学习笔记——1.WebGL概述</title>
    <link href="https://hushhw.cn/2017/12/21/01WebGL01/"/>
    <id>https://hushhw.cn/2017/12/21/01WebGL01/</id>
    <published>2017-12-21T06:55:24.000Z</published>
    <updated>2018-02-07T10:53:06.200Z</updated>
    
    <content type="html"><![CDATA[<p><strong>此系列用来记录我学习《WebGL编程指南》这本书后的心得，重点内容和总结</strong></p><h2 id="WebGL概述"><a href="#WebGL概述" class="headerlink" title="WebGL概述"></a>WebGL概述</h2><p>　　WebGL，是一项用来在网页上绘制和渲染复杂三维图形（3D图形），并允许用户与之交互的技术。随着个人计算机和浏览器的性能越来越强，我们能够在Web上创建越来越精美、越来越复杂的3D图形。<a href="http://webglsamples.org/" target="_blank" rel="noopener">http://webglsamples.org/</a> 这个网址展示了Google发布的一些示例WebGL程序，在惊叹美轮美奂的效果的同时，我们发现发布和运行也变得非常简单。</p><p>　　从传统意义上来说，为了显示三维图形，开发者需要使用C或C++语言，辅以专门的计算机图形库，如OpenGL或Direct3D，来开发一个独立的应用程序。现在有了WebGL，我们只需要向已经熟悉的HTML和JS中添加一些额外的三维图形学的代码，就可以在网页上显示三维图形了。</p><p>　　WebGL是内嵌在浏览器中的，你不必安装插件和库就可以直接使用它。而且，因为它是基于浏览器的，你可以在多种平台上运行WebGL程序，而且使用起来有诸多便利点：</p><ul><li><p>你只需要一个<strong>文本编辑器</strong>和一个<strong>浏览器</strong>，就可以开始编写三维图形程序了。</p></li><li><p>你可以使用通用的Web技术发布三维图形程序，展示给你的朋友和其他开发者</p></li><li><p>你可以充分利用浏览器的功能。</p></li><li><p>互联网上有大量现成的资料，它们可以帮助你学习WebGL，编写三维程序等。</p></li></ul><hr><h2 id="WebGL起源"><a href="#WebGL起源" class="headerlink" title="WebGL起源"></a>WebGL起源</h2><p>　　在个人计算机上使用最广泛的两种三维图形渲染技术是<strong>Direct3D</strong>和<strong>OpenGL</strong>。</p><p>　　Direct3D是微软DirectX技术的一部分，是一套由微软控制的编程接口API，主要用在Windows平台。 </p><p>OpenGL由于其开发和免费的特性，在多种平台上都有广泛的使用。Windows对OpenGL也提供了良好的支持，开发者也可以用它来代替Direct3D。</p><p>　　OpenGL最初由SGI开发，并在1992年发布为开源标准。多年以来，OpenGL发展了数个版本，并对三维图形开发，软件产品开发，甚至电影制作产生了深远影响。 </p><p>　　虽然WebGL根植于OpenGL，但它实际上是从OpenGL的一个特殊版本OpenGL ES中派生出来的，后者专用于嵌入式计算机、智能手机、家用游戏机等设备。OpenGL ES于2003-2004年被首次提出，并在2007年（ES 2.0）和2012年（ES 3.0）进行了两次升级，<strong>WebGL是基于OpenGL ES 2.0的</strong>。</p><p>下图显示了OpenGL、OpenGL ES 1.1/2.0/3.0和WebGL的关系。 </p><p><img src="http://images.cnitblog.com/blog/332382/201412/222059338585675.png" alt="图片来源www.cnblogs.com/mirror-pc/p/4178897.html"></p><p>从2.0版本开始，OpenGL支持了一项非常重要的特性，即<strong>可编程着色器方法</strong>。该特性被OpenGL ES 2.0继承，并成为了WebGL 1.0标准的核心部分。</p><p>　　着色器，使用一种类似于C的编程语言实现了精美的视觉效果。编写着色器的语言又称为<strong>着色器语言</strong>。WebGL基于OpenGL ES 2.0，使用GLSL ES语言编写着色器。</p><p>　　虽然WebGL强大到令人惊叹，但使用这项技术进行开发却异常简单：只需要一个文本编辑器（Notepad或TextEdit）和一个浏览器（Chrome）即可；并且不需要去搭建开发环境，因为WebGL是内嵌在浏览器中的。</p><p>　　下图显示了WebGL程序的结构：</p><p>　　<img src="http://images.cnitblog.com/blog/332382/201412/222120593439118.png" alt="图片来源www.cnblogs.com/mirror-pc/p/4178897.html"></p><p>​       </p><p>　　由于GLSL ES通常是以字符串的形式在JavaScript中编写的，所以虽然WebGL网页更加复杂，但它仍然保持着与传统的动态网页相同的结构：只用到HTML文件和JavaScript文件。</p><p>　　</p><blockquote><p>文章内容借鉴于：             </p><p>《WebGL编程指南》</p><p> <a href="https://www.cnblogs.com/mirror-pc/p/4178897.html" target="_blank" rel="noopener">https://www.cnblogs.com/mirror-pc/p/4178897.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;此系列用来记录我学习《WebGL编程指南》这本书后的心得，重点内容和总结&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;WebGL概述&quot;&gt;&lt;a href=&quot;#WebGL概述&quot; class=&quot;headerlink&quot; title=&quot;WebGL概述&quot;&gt;&lt;/a&gt;WebG
      
    
    </summary>
    
      <category term="学习" scheme="https://hushhw.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="WebGL" scheme="https://hushhw.cn/tags/WebGL/"/>
    
  </entry>
  
</feed>
