<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>iOS 砸壳总结</title>
    <url>/posts/125bcd75.html</url>
    <content><![CDATA[<h2 id="dumpdecrypted-砸壳"><a href="#dumpdecrypted-砸壳" class="headerlink" title="dumpdecrypted 砸壳"></a>dumpdecrypted 砸壳</h2><h3 id="1-应用场景"><a href="#1-应用场景" class="headerlink" title="1. 应用场景"></a>1. 应用场景</h3><p>应用上传 appstore 后，苹果会对应用的代码部分进行加密，当应用运行的时候才会动态解密，所以市面上的应用即使我们可以拿到 ipa 包也无法对二进制程序进行分析，这时可以使用 dumpdecrypted 时dump 内存中解密后的代码。</p>
<h3 id="2-环境配置"><a href="#2-环境配置" class="headerlink" title="2. 环境配置"></a>2. 环境配置</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">手机</th>
<th>越狱设备（iOS11以下越狱比较好做）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Cydia 依赖</td>
<td>安装 cycript</td>
</tr>
<tr>
<td style="text-align:center">PC 端</td>
<td>正常mac环境 + ssh client</td>
</tr>
<tr>
<td style="text-align:center">PC 端依赖</td>
<td>Classdump下载 + xcode</td>
</tr>
</tbody>
</table>
</div>
<h3 id="3-砸壳步骤"><a href="#3-砸壳步骤" class="headerlink" title="3. 砸壳步骤"></a>3. 砸壳步骤</h3><ol>
<li><p>打开一个 mac 终端窗口用于生成 <code>dumpdecrypted.dylib</code> 动态库文件（砸壳的锤子）</p>
<ol>
<li>终端命令：git clone <a href="https://github.com/stefanesser/dumpdecrypted.git" target="_blank" rel="noopener">https://github.com/stefanesser/dumpdecrypted.git</a></li>
<li>cd dumpdecrypted 文件目录下执行命令 <code>make</code> 既可。</li>
</ol>
</li>
<li><p>ssh 连接手机</p>
<ol>
<li>方法一：iOS 8 和 iOS 9 的越狱设备在手机上安装 OpenSSH，在 Wifi 设置中当前连接 Wi-Fi 获取到 IP 地址，如：10.28.173.46。再打开一个 mac 终端窗口用于连接手机，输入：ssh root@192.168.2.202，回车后输入”yes”，再回车输入密码”qwert”（默认密码为“alpine”）。</li>
<li>方法二：通过 USB 登录。打开一个 mac 终端安装 libimobiledevice，输入：brew install libimobiledevice，安装完成后使用里面提供的工具 iproxy 把本地端口 2222 映射到设备的 TCP 端口 22，执行命令：iproxy 2222 22，当看到 waiting for connection 时，另开一个 Mac 终端窗口，执行 ssh root@localhost -p 2222 来连接手机，后面同样输入密码等操作。</li>
</ol>
</li>
<li><p>查找要反编译的 app 的路径，在连接到手机的 mac 终端窗口进行下面操作：</p>
<ol>
<li><p>ps -e 获取手机中当前运行的进程</p>
</li>
<li><p>抓取手机上运行的 APP 进程：</p>
<ol>
<li>直接执行 ps -A | grep mobile 命令，可自动抓取手机上运行的 APP进程</li>
<li>或者知道应用的名称，直接执行 ps -e | grep PostalSavingsBankOfChina （这里以邮政银行为例）来抓取该应用进程。若不知道应用名称，可以在所有进程中找到带有 <code>bundle</code> 路径的进程，该进程就是我们正在打开的应用，路径最后即该应用的名称。</li>
</ol>
</li>
<li><p>使用 cycript 找出反编译 APP 的 Documents 目录路径：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cycript -p PostalSavingsBankOfChina </span><br><span class="line">cy# directory = NSHomeDirectory()</span><br></pre></td></tr></table></figure>
<p>这样就得到了 Data 目录，在后面加上 /Documents 即可。</p>
</li>
<li><p>拷贝 dumpdecrypted.dylib 到 iPhone 该应用的 Documents 文件夹下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp /users/bupt/test1127/dumpdecrypted/dumpdecrypted.dylib root@10.28.173.46:/var/mobile/Containers/Data/Application/BD1E0C3F-6C65-4A2B-B881-2BBA9E3B3594/Documents</span><br></pre></td></tr></table></figure>
</li>
<li><p>砸壳，打开连接到 iPhone 的终端窗口，cd 到 Data 路径的 Document 目录前面放 dumpdecrypted.dylib 文件夹下，执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib /var/containers/Bundle/Application/AB511F0D-D3D4-46A6-86BD-DFB017F07A87/PostalSavingsBankOfChina.app/PostalSavingsBankOfChina</span><br></pre></td></tr></table></figure>
<p>砸壳成功后，用 ls 命令查看 PostalSavingsBankOfChina.decrypted 文件即我们要破解的文件。</p>
</li>
<li><p>拷贝生成的 decryption 文件到电脑</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp -r root@10.28.173.46:/var/mobile/Containers/Data/Application/BD1E0C3F-6C65-4A2B-B881-2BBA9E3B3594/Documents/PostalSavingsBankOfChina.decrypted /Users/bupt/Desktop/PostalSavingsBankOfChina</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h2 id="frida-ios-dump-砸壳使用总结"><a href="#frida-ios-dump-砸壳使用总结" class="headerlink" title="frida-ios-dump 砸壳使用总结"></a>frida-ios-dump 砸壳使用总结</h2><p>   该工具基于 frida 提供的强大功能通过注入 js 实现内存 dump 然后通过 python 自动拷贝到电脑生成 ipa 文件。</p>
<h3 id="1-越狱手机配置"><a href="#1-越狱手机配置" class="headerlink" title="1. 越狱手机配置"></a>1. 越狱手机配置</h3><p>   1、打开<code>cydia</code>添加源：<a href="http://build.frida.re" target="_blank" rel="noopener">http://build.frida.re</a> 并在搜索中下载安装<code>frida</code>。</p>
<p>   2、安装完成后在<code>Mac</code>端执行<code>frida-ps -U</code>查看是否可以工作。</p>
<h3 id="2-Mac-配置"><a href="#2-Mac-配置" class="headerlink" title="2. Mac 配置"></a>2. Mac 配置</h3><p>   安装 <code>frida</code>：</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pip install frida –-upgrade –-ignore-installed six</span><br></pre></td></tr></table></figure>
<p>   克隆项目<a href="https://github.com/AloneMonkey/frida-ios-dump" target="_blank" rel="noopener">frida-ios-dump</a>：</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/AloneMonkey/frida-ios-dump</span><br></pre></td></tr></table></figure>
<p>   cd 到 <code>frida-ios-dump</code> 文件夹下，安装脚本依赖环境，执行：</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pip install -r requirements.txt --upgrade</span><br></pre></td></tr></table></figure>
<p>   修改 <code>dump.py</code> 配置：</p>
   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">User = <span class="string">'root'</span></span><br><span class="line">Password = <span class="string">'qwert'</span> <span class="comment">#我们修改了ssh默认密码，故需要修改</span></span><br><span class="line">Host = <span class="string">'localhost'</span></span><br><span class="line">Port = <span class="number">2222</span></span><br></pre></td></tr></table></figure>
<h3 id="3-使用"><a href="#3-使用" class="headerlink" title="3. 使用"></a>3. 使用</h3><p>   默认采用 USB 方式连接 ssh，将<code>22</code>映射到电脑上的<code>2222端口</code>：</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iproxy 2222 22</span><br></pre></td></tr></table></figure>
<p>   到 frida-ios-dump 文件夹下执行<code>dump.py -l</code>，查看安装的应用的名字和bundle id：</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python dump.py -l</span><br></pre></td></tr></table></figure>
<p>   执行<code>dump.py 应用名或包名</code>，即可砸壳生成 ipa 文件在当前目录下。例如：</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python dump.py 个人所得税</span><br></pre></td></tr></table></figure>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python dump.py cn.gov.tax.its</span><br></pre></td></tr></table></figure>
<p>   生成的 ipa 文件需解压后打开包内容查看同名文件，该文件仅为砸壳成功的 arm64 位。</p>
]]></content>
      <categories>
        <category>移动安全</category>
        <category>iOS安全</category>
      </categories>
      <tags>
        <tag>iOS逆向</tag>
        <tag>移动安全</tag>
        <tag>iOS安全</tag>
      </tags>
  </entry>
  <entry>
    <title>常见 APK 恶意行为的代码特征总结</title>
    <url>/posts/5b0e059c.html</url>
    <content><![CDATA[<h3 id="隐藏应用图标"><a href="#隐藏应用图标" class="headerlink" title="隐藏应用图标"></a>隐藏应用图标</h3><p>扣费类应用：VT-Ubsod- 0e5b5fa86172554a3b9c5ebea668a39c649bf8c6badd4e12e1829f59993e1690</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.a.getPackageManager().setComponentEnabledSetting(<span class="keyword">new</span> ComponentName(<span class="string">"mob.wu.hece.fofocuwera"</span>, <span class="string">"mob.wu.hece.fofocuwera.vawogavovix"</span>), <span class="number">2</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>使用到的敏感 API 为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setComponentEnabledSetting</span> <span class="params">(ComponentName componentName, <span class="keyword">int</span> newState, <span class="keyword">int</span> flags)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>componentName：组件名称 </li>
<li>newState：组件新的状态，可以设置三个值，分别是如下： <ul>
<li>默认状态：COMPONENT_ENABLED_STATE_DEFAULT </li>
<li><strong>显示应用图标</strong>：COMPONENT_ENABLED_STATE_ENABLED </li>
<li><strong>隐藏应用图标</strong>：COMPONENT_ENABLED_STATE_DISABLED </li>
</ul>
</li>
<li>flags：行为标签，值可以是DONT_KILL_APP或者0。 0说明杀死包含该组件的app</li>
</ul>
<h3 id="设备是否-root"><a href="#设备是否-root" class="headerlink" title="设备是否 root"></a>设备是否 root</h3><p>扣费类应用：VT-Ubsod- 0e5b5fa86172554a3b9c5ebea668a39c649bf8c6badd4e12e1829f59993e1690</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">if</span>(v2_1 == <span class="number">0</span>) &#123;</span><br><span class="line">   String[] v3 = <span class="keyword">new</span> String[v6];</span><br><span class="line">   v3[<span class="number">0</span>] = <span class="string">"/system/app/Superuser.apk"</span>;</span><br><span class="line">   v3[<span class="number">1</span>] = <span class="string">"/sbin/su"</span>;</span><br><span class="line">   v3[<span class="number">2</span>] = <span class="string">"/system/bin/su"</span>;</span><br><span class="line">   v3[<span class="number">3</span>] = <span class="string">"/system/xbin/su"</span>;</span><br><span class="line">   v3[<span class="number">4</span>] = <span class="string">"/data/local/xbin/su"</span>;</span><br><span class="line">   v3[<span class="number">5</span>] = <span class="string">"/data/local/bin/su"</span>;</span><br><span class="line">   v3[<span class="number">6</span>] = <span class="string">"/system/sd/xbin/su"</span>;</span><br><span class="line">   v3[<span class="number">7</span>] = <span class="string">"/system/bin/failsafe/su"</span>;</span><br><span class="line">   v3[<span class="number">8</span>] = <span class="string">"/data/local/su"</span>;</span><br><span class="line">   v3[<span class="number">9</span>] = <span class="string">"/su/bin/su"</span>;</span><br><span class="line">   v2_1 = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    v2 = Runtime.getRuntime().exec(<span class="keyword">new</span> String[]&#123;<span class="string">"/system/xbin/which"</span>, <span class="string">"su"</span>&#125;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-检查是否存在Superuser-apk"><a href="#1-检查是否存在Superuser-apk" class="headerlink" title="1. 检查是否存在Superuser.apk"></a>1. 检查是否存在Superuser.apk</h4><p>Superuser.apk 是一个被广泛使用的用来 root 安卓设备的软件，所以可以检查这个 app 是否存在。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkSuperuserApk</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       File file = <span class="keyword">new</span> File(<span class="string">"/system/app/Superuser.apk"</span>);</span><br><span class="line">       <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">           Log.i(LOG_TAG,<span class="string">"/system/app/Superuser.apk exist"</span>);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123; &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-检查-su-命令"><a href="#2-检查-su-命令" class="headerlink" title="2. 检查 su 命令"></a>2. 检查 su 命令</h4><p>su 是 Linux 下切换用户的命令，在使用时不带参数，就是切换到超级用户。通常我们获取 root 权限，就是使用su命令来实现的，所以可以检查这个命令是否存在。</p>
<ul>
<li>检测在常用目录下是否存在 su，那么就有可能漏过不常用的目录。</li>
<li>使用 which 命令查看是否存在 su，which 是 linux 下的一个命令，可以在系统 PATH 变量指定的路径中搜索某个系统命令的位置并且返回第一个搜索结果。</li>
<li>执行su，看能否获取到root权限，但是在已经root的设备上，会弹出提示框，请求给app开启root权限。这个提示不太友好，可能用户会不喜欢。</li>
</ul>
<h3 id="收集、泄漏手机信息"><a href="#收集、泄漏手机信息" class="headerlink" title="收集、泄漏手机信息"></a>收集、泄漏手机信息</h3><p>扣费类应用：VT-Ubsod- 0e5b5fa86172554a3b9c5ebea668a39c649bf8c6badd4e12e1829f59993e1690</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">a</span><span class="params">(Activity arg4)</span> </span>&#123;</span><br><span class="line">	String v0_2;</span><br><span class="line">	Object v0 = arg4.getSystemService(<span class="string">"phone"</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">		JSONObject v1 = <span class="keyword">new</span> JSONObject();</span><br><span class="line">    v1.put(<span class="string">"STREAM"</span>, <span class="string">"myandroid"</span>);</span><br><span class="line">    v1.put(<span class="string">"VERSION"</span>, Build$VERSION.SDK_INT);</span><br><span class="line">    <span class="keyword">if</span>(BaweqCenejaxe_关闭WIFI并打开移动数据网络.b != <span class="keyword">null</span>) &#123;</span><br><span class="line">       v1.put(<span class="string">"ANDROID_ID"</span>, BaweqCenejaxe_关闭WIFI并打开移动数据网络.b);</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="keyword">if</span>(arg4.getString(<span class="number">2131099669</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">			v1.put(<span class="string">"APP_NAME"</span>, arg4.getString(<span class="number">2131099669</span>));</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="keyword">if</span>(Build.MODEL != <span class="keyword">null</span>) &#123;</span><br><span class="line">			v1.put(<span class="string">"MODEL"</span>, Build.MODEL);</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="keyword">if</span>(Build$VERSION.SDK_INT &lt; <span class="number">23</span> &amp;&amp; ((TelephonyManager)v0).getDeviceId() != <span class="keyword">null</span>) &#123;</span><br><span class="line">			v1.put(<span class="string">"IMEI"</span>, ((TelephonyManager)v0).getDeviceId());</span><br><span class="line">  </span><br><span class="line">		v0_2 = v1.toString();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这类行为并不一定恶意行为，因为某些正常应用也会进行收集。</p>
<p>要获取手机硬件信息，首先获得 SystemServer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">context.getSystemServer(<span class="string">"phone"</span>);</span><br></pre></td></tr></table></figure>
<p>然后利用 server 获取信息，重点在 SystemServer 以及一些固定 API，如 getDeviceId 等等。</p>
<h3 id="申请设备管理器权限"><a href="#申请设备管理器权限" class="headerlink" title="申请设备管理器权限"></a>申请设备管理器权限</h3><p>拦截马类：0A2CA97D070A04AECB6EC9B1DA5CD987.apk</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TargetApi</span>(value=<span class="number">8</span>) <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Object v0 = <span class="keyword">this</span>.getSystemService(<span class="string">"device_policy"</span>);  <span class="comment">// 获取安全管理服务</span></span><br><span class="line">  ComponentName v1 = <span class="keyword">new</span> ComponentName(((Context)<span class="keyword">this</span>), PAReceiver<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  <span class="keyword">if</span>(!((DevicePolicyManager)v0).isAdminActive(v1)) &#123;  <span class="comment">// 若设备不具备设备管理权限，执行</span></span><br><span class="line">		Intent v0_1 = <span class="keyword">new</span> Intent(<span class="string">"android.app.action.ADD_DEVICE_ADMIN"</span>);</span><br><span class="line">    v0_1.putExtra(<span class="string">"android.app.extra.DEVICE_ADMIN"</span>, ((Parcelable)v1));</span><br><span class="line">    v0_1.putExtra(<span class="string">"android.app.extra.ADD_EXPLANATION"</span>, <span class="keyword">this</span>.getResources().getString(<span class="number">2131034113</span>));</span><br><span class="line">    <span class="keyword">this</span>.startActivityForResult(v0_1, <span class="number">1</span>);  <span class="comment">// 添加隐式意图，获取管理员权限</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="发送短信"><a href="#发送短信" class="headerlink" title="发送短信"></a>发送短信</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.SEND_SMS"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PendingIntent localPendingIntent1 = PendingIntent.getBroadcast(<span class="keyword">this</span>.ctx, <span class="number">0</span>, <span class="keyword">new</span> Intent(<span class="string">"SMS_SENT"</span>), <span class="number">0</span>);</span><br><span class="line">PendingIntent localPendingIntent2 = PendingIntent.getBroadcast(<span class="keyword">this</span>.ctx, <span class="number">0</span>, <span class="keyword">new</span> Intent(<span class="string">"SMS_DELIVERED"</span>), <span class="number">0</span>);</span><br><span class="line">SmsManager localSmsManager = SmsManager.getDefault();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        localSmsManager.sendTextMessage(paramString1, <span class="keyword">null</span>, paramString2, localPendingIntent1, localPendingIntent2);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception paramString) &#123;</span><br><span class="line">        paramString.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读取短信"><a href="#读取短信" class="headerlink" title="读取短信"></a>读取短信</h3><p>申请权限：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.SEND_SMS"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.RECEIVE_SMS"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过短信数据库获取短信内容，注册 SMS 监视器，监听短信数据库的变化，添加删除修改，变化的时候会回调 <strong>onChange</strong> 方法，提取刚刚变化的那条短信的内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">v0.registerContentObserver(Uri.parse(<span class="string">"content://sms"</span>), <span class="keyword">true</span>, <span class="keyword">this</span>.f);  <span class="comment">// 注册SMS监视器</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ArrayList v6 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        Cursor v0 = <span class="keyword">this</span>.a.getContentResolver().query(Uri.parse(<span class="string">"content://sms/"</span>), <span class="keyword">new</span> String[]&#123;<span class="string">"_id"</span>, <span class="string">"address"</span>, <span class="string">"body"</span>, <span class="string">"date"</span>, <span class="string">"type"</span>&#125;, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">" date desc "</span>);</span><br><span class="line">        <span class="keyword">while</span>(v0.moveToNext()) &#123;</span><br><span class="line">            e v1 = <span class="keyword">new</span> e();</span><br><span class="line">            String v2 = v0.getString(<span class="number">0</span>);</span><br><span class="line">            String v3 = v0.getString(<span class="number">1</span>);</span><br><span class="line">            String v4 = v0.getString(<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">long</span> v8 = v0.getLong(<span class="number">3</span>);</span><br><span class="line">            String v5 = v0.getString(<span class="number">4</span>);</span><br><span class="line">            String v7 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd hh:mm:ss"</span>).format(<span class="keyword">new</span> Date(v8));</span><br><span class="line">            v1.a(v2);</span><br><span class="line">            v1.c(v3);</span><br><span class="line">            v1.b(v4);</span><br><span class="line">            v1.d(v7);</span><br><span class="line">            v1.e(v5);</span><br><span class="line">            ((List)v6).add(v1);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="拦截短信"><a href="#拦截短信" class="headerlink" title="拦截短信"></a>拦截短信</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span> <span class="attr">android:name</span>=<span class="string">"com.t20.receiver.SmsReceiver"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">intent-filter</span> <span class="attr">android:priority</span>=<span class="string">"1000"</span> &gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 有序广播设置优先级：priority表示优先级（0-1000），默认是500 ,1000的优先级最高--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.provider.Telephony.SMS_RECEIVED"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.t20.receiver;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> android.content.BroadcastReceiver;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.telephony.SmsMessage;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="comment">//1、接收短信协议</span></span><br><span class="line">		Bundle bundle= intent.getExtras(); <span class="comment">//Bundle表示MAP套装(键值对)</span></span><br><span class="line">		<span class="comment">//2、通过Bundle取值</span></span><br><span class="line">		Object[] objs= (Object[]) bundle.get(<span class="string">"pdus"</span>);</span><br><span class="line">		<span class="keyword">for</span> (Object obj : objs) &#123;</span><br><span class="line">			 <span class="comment">//3、获取短信对象</span></span><br><span class="line">			 SmsMessage sms=SmsMessage.createFromPdu((<span class="keyword">byte</span>[])obj);</span><br><span class="line">			 System.out.println(<span class="string">"短信联系人："</span>+sms.getOriginatingAddress());</span><br><span class="line">			 System.out.println(<span class="string">"短信内容："</span>+sms.getDisplayMessageBody());</span><br><span class="line">			 <span class="comment">//4、短信拦截（收到短信时，系统会发一个有序广播，默认优先级是500，我们可以设置短信窃听器的广播优先级为1000）</span></span><br><span class="line">			 <span class="keyword">if</span>(sms.getOriginatingAddress().equals(<span class="string">"110"</span>))&#123;</span><br><span class="line">				  abortBroadcast();<span class="comment">//终止广播</span></span><br><span class="line">			 &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="设置为默认短信应用"><a href="#设置为默认短信应用" class="headerlink" title="设置为默认短信应用"></a>设置为默认短信应用</h3><p>通过 Telephony.Sms.getDefaultSmsPackage()方法来判断自己的应用是否为Default SMS app。</p>
<h3 id="删除短信"><a href="#删除短信" class="headerlink" title="删除短信"></a>删除短信</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getContentResolver().delete(Uri.parse(<span class="string">"content://sms/sms_id"</span>), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<h3 id="设置锁屏密码"><a href="#设置锁屏密码" class="headerlink" title="设置锁屏密码"></a>设置锁屏密码</h3><p>继承 DeviceAdminReceiver，采用了系统的设备管理器来获取权限进而修改密码，使用 resetPassword 设置密码</p>
<h3 id="屏蔽-back-键"><a href="#屏蔽-back-键" class="headerlink" title="屏蔽 back 键"></a>屏蔽 back 键</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onKeyDown</span><span class="params">(<span class="keyword">int</span> arg2, KeyEvent arg3)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote>
<p><a href="https://blog.csdn.net/ydt_lwj/article/details/9419239" target="_blank" rel="noopener">Android 如何隐藏应用程序的图标</a></p>
<p><a href="https://blog.csdn.net/lintax/article/details/70988565" target="_blank" rel="noopener">Android root检测方法小结</a></p>
</blockquote>
]]></content>
      <categories>
        <category>移动安全</category>
        <category>Android安全</category>
      </categories>
      <tags>
        <tag>移动安全</tag>
        <tag>恶意软件</tag>
        <tag>Android安全</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习中评估分类器性能</title>
    <url>/posts/f2b20d45.html</url>
    <content><![CDATA[<h2 id="混淆矩阵（Confusion-Matrix）"><a href="#混淆矩阵（Confusion-Matrix）" class="headerlink" title="混淆矩阵（Confusion Matrix）"></a>混淆矩阵（Confusion Matrix）</h2><p>在机器学习领域和统计分类问题中，<strong>混淆矩阵</strong>（<strong>confusion matrix</strong>）是可视化工具，特别用于监督学习，在无监督学习一般叫做匹配矩阵。矩阵的每一列代表一个类的实例预测，而每一行表示一个实际的类的实例。之所以如此命名，是因为通过这个矩阵可以方便地看出机器是否将两个不同的类混淆了（比如说把一个类错当成了另一个）。<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>
<p>对于二分类问题，混淆矩阵为一个 2*2 的表，行代表真实值，列代表预测值，见下表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">真实 \ 预测</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>0</strong></td>
<td style="text-align:center">预测 negative 正确（<strong>TN</strong>）</td>
<td style="text-align:center">预测 positive 错误（<strong>FP</strong>）</td>
</tr>
<tr>
<td style="text-align:center"><strong>1</strong></td>
<td style="text-align:center">预测 negative 错误（<strong>FN</strong>）</td>
<td style="text-align:center">预测 positive 正确（<strong>TP</strong>）</td>
</tr>
</tbody>
</table>
</div>
<p>以「患癌症问题」举例，上表中 <code>0</code> 代表未得癌症，<code>1</code> 代表得了癌症，行代表患癌症的真实值，列代表患癌症的预测值，那么，<code>TN</code> 就代表着真实情况没有得癌症且预测没有得癌症正确，同样 <code>FN</code> 代表真实情况得了癌症但预测其未得癌症。</p>
<p>​          </p>
<h2 id="精准率和召回率"><a href="#精准率和召回率" class="headerlink" title="精准率和召回率"></a>精准率和召回率</h2><p><strong>精准率（precision）</strong>：在所有预测值为 <code>1</code> 的情况下，实际也正确的概率。例如在癌症问题中表示预测患癌症成功的概率。公式如下：</p>
<script type="math/tex; mode=display">
precision = \frac{TP}{TP+FP}</script><p><strong>召回率（recall）</strong>：在所有真实值为 <code>1</code> 的情况下，预测正确的概率。例如在癌症问题中表示患癌症的人群中成功预测的概率。公式如下：</p>
<script type="math/tex; mode=display">
recall = \frac{TP}{TP+FN}</script><p>下面代码实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"></span><br><span class="line"><span class="comment"># 引入手写识别数据集</span></span><br><span class="line">digits = datasets.load_digits()</span><br><span class="line">X = digits.data</span><br><span class="line">y = digits.target.copy()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了让数据集变成二分类问题，做如下处理</span></span><br><span class="line">y[digits.target == <span class="number">9</span>] = <span class="number">1</span></span><br><span class="line">y[digits.target != <span class="number">9</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line">log_reg = LogisticRegression()</span><br><span class="line">log_reg.fit(X_train, y_train)</span><br><span class="line">log_reg.score(X_test, y_test)</span><br><span class="line"><span class="comment"># 0.97555555555555551</span></span><br><span class="line"></span><br><span class="line">y_log_predict = log_reg.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># TN</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">TN</span><span class="params">(y_true, y_predict)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> len(y_true) == len(y_predict)</span><br><span class="line">    <span class="keyword">return</span> np.sum((y_true == <span class="number">0</span>) &amp; (y_predict == <span class="number">0</span>))</span><br><span class="line">TN(y_test, y_log_predict)</span><br><span class="line"><span class="comment"># 397</span></span><br><span class="line"><span class="comment"># FP</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">FP</span><span class="params">(y_true, y_predict)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> len(y_true) == len(y_predict)</span><br><span class="line">    <span class="keyword">return</span> np.sum((y_true == <span class="number">0</span>) &amp; (y_predict == <span class="number">1</span>))</span><br><span class="line">FP(y_test, y_log_predict)</span><br><span class="line"><span class="comment"># 5</span></span><br><span class="line"><span class="comment"># FN</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">FN</span><span class="params">(y_true, y_predict)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> len(y_true) == len(y_predict)</span><br><span class="line">    <span class="keyword">return</span> np.sum((y_true == <span class="number">1</span>) &amp; (y_predict == <span class="number">0</span>))</span><br><span class="line">FN(y_test, y_log_predict)</span><br><span class="line"><span class="comment"># 6</span></span><br><span class="line"><span class="comment"># TP</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">TP</span><span class="params">(y_true, y_predict)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> len(y_true) == len(y_predict)</span><br><span class="line">    <span class="keyword">return</span> np.sum((y_true == <span class="number">1</span>) &amp; (y_predict == <span class="number">1</span>))</span><br><span class="line">TP(y_test, y_log_predict)</span><br><span class="line"><span class="comment">#42</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 混淆矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">confusion_matrix</span><span class="params">(y_true, y_predict)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.array([</span><br><span class="line">        [TN(y_true, y_predict), FP(y_true, y_predict)],</span><br><span class="line">        [FN(y_true, y_predict), TP(y_true, y_predict)]</span><br><span class="line">    ])</span><br><span class="line">confusion_matrix(y_test, y_log_predict)</span><br><span class="line"><span class="comment">#array([[397,   5],</span></span><br><span class="line"><span class="comment">#       [  6,  42]])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 精准率</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">precision_score</span><span class="params">(y_true, y_predict)</span>:</span></span><br><span class="line">    tp = TP(y_true, y_predict)</span><br><span class="line">    fp = FP(y_true, y_predict)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> tp / (tp + fp)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>   </span><br><span class="line">precision_score(y_test, y_log_predict)</span><br><span class="line"><span class="comment"># 0.8936170212765957</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 召回率</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recall_score</span><span class="params">(y_true, y_predict)</span>:</span></span><br><span class="line">    tp = TP(y_true, y_predict)</span><br><span class="line">    fn = FN(y_true, y_predict)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> tp / (tp + fn)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span></span><br><span class="line">recall_score(y_test, y_log_predict)</span><br><span class="line"><span class="comment"># 0.875</span></span><br></pre></td></tr></table></figure>
<p>在 <code>Scikit-learn</code> 中实现混淆矩阵、精准率和召回率</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix</span><br><span class="line">confusion_matrix(y_test, y_log_predict)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> precision_score</span><br><span class="line">precision_score(y_test, y_log_predict)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> recall_score</span><br><span class="line">recall_score(y_test, y_log_predict)</span><br></pre></td></tr></table></figure>
<p>​          </p>
<h2 id="F1-Score"><a href="#F1-Score" class="headerlink" title="F1 Score"></a>F1 Score</h2><p>对于精准率和召回率，在不同的场景有不同的侧重点。</p>
<p>在股票预测问题中，设股票增长为 <code>1</code>，我们更加关注精准率，即我们预测股票增长情况下预测正确的概率，而对于回归率我们并不太关心，因为召回率代表着实际会增长的股票我们预测到会增长的股票的概率，而增长的股票有很多，我们只是漏掉了部分会增长的股票而已，我们并没有什么损失；在病人诊断问题中，我们就更加关注召回率，即病人已经得病了能够诊断出其患病的概率，显然这时候召回率越高越好，能够不漏掉任何一个患病的病人，而精准率低一些并没有关系，即有一些人没有病被预测为有病，再继续做检查确诊就行了，不会造成巨大危害。</p>
<p>如果要同时关注这两个指标，就需要引入一个新的指标——<strong>F1 Score</strong></p>
<p>F1 Score 是精准率和召回率的调和平均值</p>
<script type="math/tex; mode=display">
F_1 = \frac2{\frac1{precision}+\frac1{recall}} = \frac{2\times precision\times recall}{precision + recall}</script><p>下面尝试不同的精准率和召回率下，F1 Score 的值变化</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1_score</span><span class="params">(precision, recall)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * precision * recall / (precision + recall)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">precision = <span class="number">0.5</span></span><br><span class="line">recall = <span class="number">0.5</span></span><br><span class="line">f1_score(precision, recall)</span><br><span class="line"><span class="comment"># 0.5</span></span><br><span class="line"></span><br><span class="line">precision = <span class="number">0.1</span></span><br><span class="line">recall = <span class="number">0.9</span></span><br><span class="line">f1_score(precision, recall)</span><br><span class="line"><span class="comment"># 0.18000000000000002</span></span><br><span class="line"></span><br><span class="line">precision = <span class="number">0.0</span></span><br><span class="line">recall = <span class="number">1.0</span></span><br><span class="line">f1_score(precision, recall)</span><br><span class="line"><span class="comment"># 0.0</span></span><br></pre></td></tr></table></figure>
<p>在前面的例子中我们测得了精准率和召回率，现在使用 <code>Scikit-learn</code> 计算 f1_score：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix</span><br><span class="line">confusion_matrix(y_test, y_log_predict)</span><br><span class="line"><span class="comment">#array([[403,   2],</span></span><br><span class="line"><span class="comment">#       [  9,  36]])</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> precision_score</span><br><span class="line">precision_score(y_test, y_log_predict)</span><br><span class="line"><span class="comment"># 0.94736842105263153</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> recall_score</span><br><span class="line">recall_score(y_test, y_log_predict)</span><br><span class="line"><span class="comment"># 0.80000000000000004</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> f1_score</span><br><span class="line">f1_score(y_test, y_log_predict)</span><br><span class="line"><span class="comment"># 0.8842105263157894</span></span><br></pre></td></tr></table></figure>
<p>F1 Score 对那些具有相近的精准率和召回率的分类器更为有利。</p>
<p>​            </p>
<h2 id="Precision-recall-的平衡"><a href="#Precision-recall-的平衡" class="headerlink" title="Precision-recall 的平衡"></a>Precision-recall 的平衡</h2><p>下图中用竖线代表阈值，划分左右两边分别为预测为 0 和 1，五角星代表实际值为 1，圆代表 0。</p>
<p><img src="https://photo.hushhw.cn/20191021200918.png" alt></p>
<p>当阈值为 0 ，小于 0，大于 0 时分别不同的精准率和召回率，由此可知鱼与熊掌不可兼得。</p>
<p><code>Scikit-learn</code> 不允许直接设置阈值，但可以访问它用于预测的决策分数。不是调用分类器的 predict() 方法，而是调用 decision_function() 方法，这个方法返回每个实例的分数，然后就可以根据这些分数，使用任意阈值进行预测了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">decision_scores = log_reg.decision_function(X_test)</span><br><span class="line"></span><br><span class="line">np.min(decision_scores)</span><br><span class="line"><span class="comment"># -61.02813630853092</span></span><br><span class="line">np.max(decision_scores)</span><br><span class="line"><span class="comment"># 17.504275181503946</span></span><br><span class="line"></span><br><span class="line">y_predict_2 = np.array(decision_scores &gt;= <span class="number">5</span>, dtype=<span class="string">'int'</span>)</span><br><span class="line">confusion_matrix(y_test, y_predict_2)</span><br><span class="line"><span class="comment">#array([[402,   0],</span></span><br><span class="line"><span class="comment">#       [ 20,  28]], dtype=int64)</span></span><br><span class="line">precision_score(y_test, y_predict_2)</span><br><span class="line"><span class="comment"># 1.0</span></span><br><span class="line">recall_score(y_test, y_predict_2)</span><br><span class="line"><span class="comment"># 0.5833333333333334</span></span><br><span class="line"></span><br><span class="line">y_predict_3 = np.array(decision_scores &gt;= <span class="number">-5</span>, dtype=<span class="string">'int'</span>)</span><br><span class="line">confusion_matrix(y_test, y_predict_3)</span><br><span class="line"><span class="comment">#array([[379,  23],</span></span><br><span class="line"><span class="comment">#       [  2,  46]], dtype=int64)</span></span><br><span class="line">precision_score(y_test, y_predict_3)</span><br><span class="line"><span class="comment"># 0.6666666666666666</span></span><br><span class="line">recall_score(y_test, y_predict_3)</span><br><span class="line"><span class="comment"># 0.9583333333333334</span></span><br></pre></td></tr></table></figure>
<p>下面用 for 循环拿到所有的阈值，绘制成图：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">precisions = []</span><br><span class="line">recalls = []</span><br><span class="line">thresholds = np.arange(np.min(decision_scores), np.max(decision_scores), <span class="number">0.1</span>)</span><br><span class="line"><span class="keyword">for</span> threshold <span class="keyword">in</span> thresholds:</span><br><span class="line">    y_predict = np.array(decision_scores &gt;= threshold, dtype = <span class="string">'int'</span>)</span><br><span class="line">    precisions.append(precision_score(y_test, y_predict))</span><br><span class="line">    recalls.append(recall_score(y_test, y_predict))</span><br><span class="line">    </span><br><span class="line">plt.plot(thresholds, precisions)</span><br><span class="line">plt.plot(thresholds, recalls)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://photo.hushhw.cn/20191021205050.png" alt></p>
<p>​         </p>
<h2 id="Precision-Recall-曲线"><a href="#Precision-Recall-曲线" class="headerlink" title="Precision-Recall 曲线"></a>Precision-Recall 曲线</h2><p>将 Precision 和 Recall 分别放在坐标轴的 x 和 y 轴上，可以清晰的观察到两者的关系：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.plot(precisions, recalls)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://photo.hushhw.cn/20191021205339.png" alt></p>
<p>在 <code>Scikit-learn</code> 中可以直接调用 <code>precision_recall_curve</code> 方法来得到相应参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> precision_recall_curve</span><br><span class="line">precisions, recalls, thresholds = precision_recall_curve(y_test, decision_scores)</span><br></pre></td></tr></table></figure>
<p>返回了三个参数，分别是 precisions、recalls 和 thresholds（阈值），下面看看这几个参数的元素个数：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">precisions.shape</span><br><span class="line"><span class="comment"># (93,)</span></span><br><span class="line">recalls.shape</span><br><span class="line"><span class="comment"># (93,)</span></span><br><span class="line">thresholds.shape</span><br><span class="line"><span class="comment"># (92,)</span></span><br></pre></td></tr></table></figure></p>
<p>翻阅官方文档<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>可以知道最后一个精准率或回归率的值默认为 1 或 0，且没有 threshold。</p>
<p>最后用 <code>matplotlib</code> 绘制即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.plot(thresholds, precisons[:<span class="number">-1</span>])</span><br><span class="line">plt.plot(thresholds, recalls[:<span class="number">-1</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://photo.hushhw.cn/20191021210859.png" alt></p>
<p>若绘制前面那种 precison 与 recall 的坐标系：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.plot(precisions, recalls)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://photo.hushhw.cn/20191021211010.png" alt></p>
<p>对比前面的图会发现这里只是前面的中间部分，是因为 precision_recall_curve 选择了它认为最重要的数据。</p>
<p>​           </p>
<h2 id="ROC-曲线"><a href="#ROC-曲线" class="headerlink" title="ROC 曲线"></a>ROC 曲线</h2><p>ROC 曲线经常与二元分类器一起使用，它与 precison-recall 曲线非常相似，但绘制的不是精准率和召回率，而是真正类率（<strong>TPR</strong>）与假正类率（<strong>FPR</strong>）。</p>
<p>回到前面的混淆矩阵二分类问题上，其实 TPR = recall，二者是一样的含义，而 FPR 表示在真实值为 0 的情况下，预测 为 1 的概率，公式：</p>
<script type="math/tex; mode=display">
FPR = \frac{FP}{TN+FP}</script><p>TPR 和 FPR 二者的关系如下图，同大同小：</p>
<p><img src="https://photo.hushhw.cn/20191021213307.png" alt></p>
<p>使用 <code>Scikit-learn</code> 中的 <code>roc_curve</code> 方法可以得到想要的参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_curve</span><br><span class="line">fprs, tprs, thresholds = roc_curve(y_test, decision_scores)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.plot(fprs, tprs)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>绘制结果：</p>
<p><img src="https://photo.hushhw.cn/20191021213534.png" alt></p>
<p>ROC 曲线一般用来比较两个模型孰优孰劣，其<strong>曲线下面积（AUC）</strong>是非常重要的参数，完美的 ROC AUC 等于 1，而纯随机分类器的 ROC AUC 等于 0.5。</p>
<p>下面是 <code>Scikit-learn</code> 中提供的方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_auc_score</span><br><span class="line">roc_auc_score(y_test, decision_scores)</span><br><span class="line"><span class="comment"># 0.98304526748971188</span></span><br></pre></td></tr></table></figure>
<p>​             </p>
<p>完整代码：<a href="https://github.com/hushhw/Machine_Learning_Algorithms_Note/blob/master/Classification-Performance-Measures.ipynb" target="_blank" rel="noopener"><strong>Classification-Performance-Measures.ipynb</strong></a></p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="https://zh.wikipedia.org/wiki/%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5" target="_blank" rel="noopener">维基百科</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;"><a href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.precision_recall_curve.html#sklearn.metrics.precision_recall_curve" target="_blank" rel="noopener">precision_recall_curve</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>笔记整理</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>使用virtualenv创建隔离环境</title>
    <url>/posts/6adc5586.html</url>
    <content><![CDATA[<p>如果你希望在一个隔离的环境里工作（强烈推荐，这样你可以在库版本不冲突的情况下处理不同的项目），可以通过运行以下 pip 命令来安装 <code>virtualenv</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pip3 install --user --upgrade virtualenv</span><br><span class="line">Collecting virtualenv</span><br><span class="line">[...]</span><br><span class="line">Successfully installed virtualenv</span><br></pre></td></tr></table></figure>
<p>输入以下命令创建一个隔离的 Python 环境：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd $ML_PATH</span><br><span class="line">$ virtualenv env</span><br><span class="line">Using base prefix &apos;[...]&apos;</span><br><span class="line">New Python executable in [...]/ml/env/bin/python3.5</span><br><span class="line">Also creating executable in [...]/ml/env/bin/python</span><br><span class="line">Installing setuptools, pip, wheel...done.</span><br></pre></td></tr></table></figure>
<p>现在开始，每当要激活这个环境时，只需要打开终端并输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd $ML_PATH</span><br><span class="line">$ source env/bin/activate</span><br></pre></td></tr></table></figure>
<p>当这个环境处于激活状态时，你使用 pip 安装的任何软件包都将被安装在这个隔离的环境中，Python 只拥有这些包的访问权限（如果你还希望访问系统站点的软件包，则需要使用 <code>virtualenv</code> 的 <code>`--system-site-packages</code> 命令选项）。更多详情可以参考 <a href="https://virtualenv.pypa.io/en/latest/" target="_blank" rel="noopener">virtualenv文档</a>。</p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>环境配置</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>virtualenv</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTPS协议 &amp; TLS协议</title>
    <url>/posts/d30e9e5e.html</url>
    <content><![CDATA[<h2 id="1-HTTPS协议"><a href="#1-HTTPS协议" class="headerlink" title="1. HTTPS协议"></a>1. HTTPS协议</h2><h3 id="1-1-HTTP-和-HTTPS-协议的区别"><a href="#1-1-HTTP-和-HTTPS-协议的区别" class="headerlink" title="1.1 HTTP 和 HTTPS 协议的区别"></a>1.1 HTTP 和 HTTPS 协议的区别</h3><p>HTTP 协议存在一定的缺点：</p>
<ul>
<li>通信使用明文，不提供任何方式的数据加密，内容可能被窃听（重要密码泄露）</li>
<li>不验证通信方身份，有可能遭遇伪装（跨站点请求伪造）</li>
<li>无法证明报文的完整性，有可能已遭篡改（运营商劫持）</li>
</ul>
<p>为了解决 HTTP 存在的这些漏洞使数据传输更加安全，引入了另一种协议 HTTPS，HTTPS 协议是在 HTTP 协议的基础上加入了加密处理和认证机制和完整性保护，只是 HTTP 通信接口部分用 SSL/TLS 协议代替而已，简单讲就是 HTTP 的安全版，通常 HTTP 直接和 TCP 通信，当使用 SSL 时，就演变成先与 SSL 通信，再由 SSL 和 TCP 通信。</p>
<p><img src="https://photo.hushhw.cn/20190923193436.png" alt></p>
<p>HTTP 和 HTTPS 的区别：</p>
<ul>
<li>HTTPS 协议需要到 CA 申请证书，一般免费证书较少，因而需要一定费用；</li>
<li>HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是安全性的 SSL 加密传输协议；</li>
<li>HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口不一样，前者是 80，后者是 443；</li>
<li><p>HTTP 的连接很简单，是无状态的，HTTPS 协议是由 SSL + HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。</p>
<p>​        </p>
</li>
</ul>
<h3 id="1-2-HTTPS-的工作原理"><a href="#1-2-HTTPS-的工作原理" class="headerlink" title="1.2 HTTPS 的工作原理"></a>1.2 HTTPS 的工作原理</h3><ul>
<li><p>客户用 HTTPS 的 URL 访问 Web 服务器，要求与 Web 服务器建立 SSL 连接；</p>
</li>
<li><p>Web 服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端；</p>
</li>
<li><p>客户端的浏览器与 Web 服务器开始协商 SSL 连接的安全等级，也就是信息加密的等级；</p>
</li>
<li><p>客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站；</p>
</li>
<li><p>Web 服务器利用自己的私钥解密出会话密钥；</p>
</li>
<li><p>Web 服务器利用会话密钥加密与客户端之间的通信；</p>
<p>​           </p>
</li>
</ul>
<h2 id="2-TLS-协议"><a href="#2-TLS-协议" class="headerlink" title="2. TLS 协议"></a>2. TLS 协议</h2><blockquote>
<p>SSL/TLS 是保护计算机网络通讯安全的一类加密协议，它们在传输层上给原先非安全的应用层协议提供加密保护，如非安全的 HTTP 协议即可被 SSL/TLS 保护形成安全的 HTTPS 协议。</p>
<p>TLS 可以理解为 SSL（Secure Socket Layer）安全套接字层的后续版本，TLS 协议是继承了 SSL 协议并写入 RFC 标准化后的产物。</p>
</blockquote>
<p><strong>SSL (Secure Socket Layer)安全套接字层协议</strong></p>
<ul>
<li><p>SSL通过互相认证、使用数字签名确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯。</p>
</li>
<li><p>分为SSL记录协议和SSL握手协议。</p>
</li>
</ul>
<p><strong>TLS(Transport Layer Security)传输层安全协议</strong></p>
<ul>
<li>用于两个应用程序之间提供保密性和数据完整性。</li>
<li><p>分为TLS记录协议和TLS握手协议。 </p>
<p>​       </p>
</li>
</ul>
<h3 id="2-1-TLS-通信握手过程"><a href="#2-1-TLS-通信握手过程" class="headerlink" title="2.1 TLS 通信握手过程"></a>2.1 TLS 通信握手过程</h3><ul>
<li>客户端给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法列表；</li>
<li>服务器从算法列表中选择一种加密算法确认双方使用的加密方法，并给出包含服务器公钥的数字证书、以及一个服务器生成的随机数（Server random）；</li>
<li>客户端确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥加密这个随机数，将加密后的信息发给服务器；</li>
<li>服务器使用自己的私钥，获取客户端发来的随机数（即Premaster secret）；</li>
<li>客户端和服务器根据约定的加密方法，使用前面的三个随机数，生成「对话密钥」（session key），用来加密接下来的整个对话过程。</li>
</ul>
<p><img src="https://photo.hushhw.cn/20190924150109.png" alt></p>
<p>握手阶段有三点需要注意：</p>
<ul>
<li>「对话密钥」由前面提到的三个随机数一起组成。</li>
<li>握手之后的对话使用「对话密钥」加密，属于对称加密；服务器的公钥和私钥只用于加密和解密「对话密钥」，为非对称加密。</li>
<li>服务器的公钥放在服务器的数字证书之中，只要证书是可信的公钥就是可信的，保证了公钥不被篡改。</li>
<li>每一次对话（session），客户端和服务器端都生成一个「对话密钥」（session key），用它来加密信息。由于”对话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密”对话密钥”本身，这样就减少了加密运算的消耗时间。</li>
</ul>
<p>​           </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://www.cnblogs.com/jesse131/p/9080925.html" target="_blank" rel="noopener">我是这样理解HTTP和HTTPS区别的</a></p>
<p><a href="https://www.freebuf.com/articles/network/116497.html" target="_blank" rel="noopener">传输层安全协议抓包分析之SSL/TLS</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="noopener">图解SSL/TLS协议</a></p>
<p><a href="https://www.cnblogs.com/snowater/p/7804889.html" target="_blank" rel="noopener">HTTPS协议、TLS协议、证书认证过程解析</a> </p>
</blockquote>
]]></content>
      <categories>
        <category>笔记整理</category>
        <category>流量分析</category>
      </categories>
      <tags>
        <tag>TLS</tag>
        <tag>Encrypted Traffic Analytics</tag>
      </tags>
  </entry>
  <entry>
    <title>吴恩达《机器学习》笔记（九）——支持向量机SVM</title>
    <url>/posts/f95480d6.html</url>
    <content><![CDATA[<h2 id="Support-Vector-Machines"><a href="#Support-Vector-Machines" class="headerlink" title="Support Vector Machines"></a>Support Vector Machines</h2><h3 id="12-1-Optimization-Objective"><a href="#12-1-Optimization-Objective" class="headerlink" title="12.1. Optimization Objective"></a>12.1. Optimization Objective</h3><p><strong>支持向量机（Support Vector Machines，SVM）</strong>在学习复杂的非线性方程时提供了一种更为清晰更为强大的方式，属于监督学习算法。</p>
<p>为了描述 SVM，我们从 logistic 回归开始，下图是回顾 logistic 回归的假设函数的一些特性：</p>
<p><img src="https://photo.hushhw.cn/20190906130133.png" alt></p>
<p>再看看 logistic 回归的代价函数：</p>
<script type="math/tex; mode=display">
\begin{align}
J(\theta) &= \frac{1}{m}\sum^{m}_{i=1}\left[-y^{(i)}log\ h_{\theta}(x^{(i)}) - (1-y^{(i)})log(1-h_{\theta}(x^{(i)}))\right] \\
&= \frac{1}{m}\sum^{m}_{i=1}\left[-y^{(i)}log\left( \frac1{1+e^{-\theta^Tx^{(i)}}}\right) - (1-y^{(i)})log\left(1-\frac1{1+e^{-\theta^Tx^{(i)}}}\right)\right]
\end{align}</script><p>令 $z=\theta^Tx​$ 后画出两条光滑的 sigmoid 函数曲线如下图：</p>
<p><img src="https://photo.hushhw.cn/20190906132048.png" alt></p>
<p>用两条粉色线段代替曲线，这被称为 hinge loss 函数。</p>
<ul>
<li><p>当 y = 1 时，命名为 $cost_1(z)$ ，当 z 大于 1 时为零，小于 1 时斜率可以不用考虑。</p>
</li>
<li><p>当 y = 0 时，命名为 $cost_0(z)$ ，当 z 小于 -1 时为零，大于 -1 时斜率可以不用考虑。</p>
</li>
</ul>
<p>logistic 回归正则化后的待见函数为：</p>
<script type="math/tex; mode=display">
J(\theta) = \frac{1}{m}\sum^{m}_{i=1}\left[y^{(i)}\left(-log\ h_{\theta}(x^{(i)})\right) + (1-y^{(i)})\left(-log(1-h_{\theta}(x^{(i)}))\right)\right] + \frac{\lambda}{2m}\sum^n_{j=1}\theta^2_j</script><p>用命名后的线段代替 logistic 回归代价函数的第一项和第二项得到：</p>
<script type="math/tex; mode=display">
J(\theta) = \frac{1}{m}\sum^{m}_{i=1}\left[y^{(i)}cost_1(\theta^Tx^{(i)}) + (1-y^{(i)})cost_0(\theta^Tx^{(i)})\right] + \frac{\lambda}{2m}\sum^n_{j=1}\theta^2_j</script><p>现在我们考虑去掉 1/m 这一项，去掉后依然可以得到同样的 𝜃 最优值，因为 1/m 仅是一个常量。我们做一下变形，乘以一个 m/λ：</p>
<script type="math/tex; mode=display">
J(\theta) = \frac{1}{\lambda}\sum^{m}_{i=1}\left[y^{(i)}cost_1(\theta^Tx^{(i)}) + (1-y^{(i)})cost_0(\theta^Tx^{(i)})\right] + \frac12\sum^n_{j=1}\theta^2_j</script><p>最后我们记 C=1/λ，得到：</p>
<script type="math/tex; mode=display">
J(\theta) = C\sum^{m}_{i=1}\left[y^{(i)}cost_1(\theta^Tx^{(i)}) + (1-y^{(i)})cost_0(\theta^Tx^{(i)})\right] + \frac12\sum^n_{j=1}\theta^2_j</script><p>这就是通常使用的 SVM 代价函数，这个系数 C 本质上和 λ 一样，都是改变普通代价函数项和正则项的权重关系。也就是说，如果我们想要加强正则化强度来处理过拟合，那么减小 C；如果想要减少正则化强度来处理欠拟合，那么增大 C。</p>
<p>最后，有别于 logistic 回归的一点是 SVM 算法的假设函数并不代表 y = 0 或 1 的概率，而只是输出 0 或 1：</p>
<script type="math/tex; mode=display">
h_{\theta}(x)= \begin{cases}
1 \quad if\: \theta^Tx\geq0 \\
0 \quad otherwise
\end{cases}</script><p>​           </p>
<h3 id="12-2-Large-Margin-Intuition"><a href="#12-2-Large-Margin-Intuition" class="headerlink" title="12.2. Large Margin Intuition"></a>12.2. Large Margin Intuition</h3><p>把 SVM 算法当作<strong>大间距分类器（Large Margin Classifier）</strong>来理解是比较直观的理解方式。</p>
<p>下图回顾了 SVM 算法的最小化代价函数的结论：</p>
<p><img src="https://photo.hushhw.cn/20190906144938.png" alt></p>
<p>如果代价函数中的 C 被设置的非常非常大，想要是的代价函数最小，就必须让代价函数项为 0 ，即：</p>
<script type="math/tex; mode=display">
\begin{align}
J(\theta) &= C\cdot0 + \frac12\sum^n_{j=1}\theta^2_j \\
when: \quad&\theta^Tx^{(i)}\geq 1 \quad if \:y^{(i)}=1 \\
&\theta^Tx^{(i)}\leq -1 \quad if \:y^{(i)}=0 \\
\end{align}</script><p><img src="https://photo.hushhw.cn/20190906150428.png" alt></p>
<p>在上图的决策边界选择中，黑线决策边界的选择是符合 SVM 算法要求的，黑线有与正负数据集更大的距离，这个距离叫做支持向量机的<strong>间距（margin）</strong>，因此支持向量机有时被称为<strong>大间距分类器（Large Margin Classifier）</strong>。在 SVM 算法中，决策边界的性质是尽可能地远离正数据集与负数据集。</p>
<p>事实上，支持向量机 SVM 现在比大间距分类器要成熟得多，使用大间距分类器的学习算法容易受到异常点（outlier）的影响，如下图中会因为一个异常点导致决策边界发生很大的偏移。</p>
<p><img src="https://photo.hushhw.cn/20190906151419.png" alt></p>
<p>如果想要使得这些异常点不过分影响决策边界，这时应该减小 C 的数值。</p>
]]></content>
      <categories>
        <category>笔记整理</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>吴恩达《机器学习》笔记（七）——神经网络的学习</title>
    <url>/posts/18a3eba2.html</url>
    <content><![CDATA[<h2 id="Neural-Networks：-Learning"><a href="#Neural-Networks：-Learning" class="headerlink" title="Neural Networks： Learning"></a>Neural Networks： Learning</h2><h3 id="9-1-Cost-Function"><a href="#9-1-Cost-Function" class="headerlink" title="9.1. Cost Function"></a>9.1. Cost Function</h3><p>首先引入一些标记：</p>
<ul>
<li>$L$：神经网络的总层数</li>
<li>$s_l$：第 L 层的单元数量（不含偏置单元）</li>
<li>$K$：输出单元的数量</li>
<li>$h_{\Theta}(x)_k$：假设函数中的第 k 个输出</li>
</ul>
<p>下图中分别为单类和多类分类的表示形式：</p>
<p><img src="https://photo.hushhw.cn/20190905174159.png" alt></p>
<p>在 logistic 回归问题中我们的代价函数是：</p>
<script type="math/tex; mode=display">
J(\theta) = -\frac{1}{m}\sum^{m}_{i=1}\left[y^{(i)}log\ h_{\theta}(x^{(i)}) + (1-y^{(i)})log(1-h_{\theta}(x^{(i)}))\right] + \frac{λ}{2m}\sum^n_{j=1}\theta^2_j</script><p>而神经网络中的代价函数是 logistic 回归代价函数的推广，在 logistic 回归中只有一个输出变量且只有一个因变量 y，而在神经网络中却有很多输出变量，其代价函数要复杂一些，如下：</p>
<script type="math/tex; mode=display">
\begin{align}
J(\theta) &= -\frac{1}{m}\left[\sum^{m}_{i=1}\sum^k_{k=1}y_k^{(i)}log\left( h_{\Theta}(x^{(i)})\right)_k + (1-y_k^{(i)})log\left(1-h_{\Theta}(x^{(i)})\right)_k\right] \\
&+ \frac{λ}{2m}\sum^{L-1}_{l=1}\sum^{s_l}_{i=1}\sum^{s_{l+1}}_{j=1}(\Theta^{(l)}_{j,i})^2
\end{align}</script><h3 id="9-2-Backpropagation-Algorithm"><a href="#9-2-Backpropagation-Algorithm" class="headerlink" title="9.2. Backpropagation Algorithm"></a>9.2. Backpropagation Algorithm</h3><p>待补充。。。</p>
]]></content>
      <categories>
        <category>笔记整理</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>吴恩达《机器学习》笔记（六）——神经网络的表述</title>
    <url>/posts/e75b0cdb.html</url>
    <content><![CDATA[<blockquote>
<p>本节表述了神经网络在机器学习中的应用及表达形式，并做了简单的举例说明。</p>
</blockquote>
<h2 id="Neural-Networks-Representation"><a href="#Neural-Networks-Representation" class="headerlink" title="Neural Networks: Representation"></a>Neural Networks: Representation</h2><h3 id="8-1-Non-linear-Hypotheses"><a href="#8-1-Non-linear-Hypotheses" class="headerlink" title="8.1. Non-linear Hypotheses"></a>8.1. Non-linear Hypotheses</h3><p>我们前面学到的线性回归和逻辑回归在面临有很多特征时，计算的负荷都会非常大。</p>
<p>使用非线性的多项式项能够帮助我们建立更好的分类模型。假设我们有非常多的特征，例如大于 100 个变量，我们希望用这 100 个特征来构建一个非线性的多项式模型，结果将是数据非常惊人的特征组合，即便我们只采用两两特征的组合（$x<em>1x_2 + x_1x_3 + x_1x_4 + \cdots + x_2x_3 + x_2x_4 + \cdots + x</em>{99}x_{100}$），这样也有接近 5000 个组合而成的特征，这对于一般的逻辑回归来说需要计算的特征太多了。</p>
<p>所以，我们需要引入神经网络。</p>
<p>​             </p>
<h3 id="8-2-Neurons-and-the-Brain"><a href="#8-2-Neurons-and-the-Brain" class="headerlink" title="8.2. Neurons and the Brain"></a>8.2. Neurons and the Brain</h3><p>神经网络是计算量有些偏大的算法，大概由于近些年计算机的运行速度变快，才足以真正运行起大<br>规模的神经网络。正是由于这个原因和其他一些我们后面会讨论到的技术因素，如今的神经网络对于许多应用来说是最先进的技术。</p>
<p>​                </p>
<h3 id="8-3-Model-Representation"><a href="#8-3-Model-Representation" class="headerlink" title="8.3. Model Representation"></a>8.3. Model Representation</h3><h4 id="8-3-1-简单表达"><a href="#8-3-1-简单表达" class="headerlink" title="8.3.1. 简单表达"></a>8.3.1. 简单表达</h4><p>为了构建神经网络模型，我们需要首先思考大脑中的神经网络是怎样的？</p>
<p>每一个神经元都可以被认为是一个<strong>处理单元/神经核（processing unit/Nucleus）</strong>，它含有许多<strong>输入/树突（input/Dendrite）</strong>，并且有一个<strong>输出/轴突（output/Axon）</strong>。神经网络是大量神经元相互链接并通过电脉冲来交流的一个网络。 </p>
<p><img src="https://photo.hushhw.cn/20190811162118.png" alt></p>
<p>神经网络模型建立在很多神经元之上，每一个神经元又是一个个学习模型。这些神经元采纳一些特征作为输出，并且根据本身的模型提供一个输出。下面是一个以 logistic 回归模型作为自身学习模型的神经元示例：</p>
<p><img src="https://photo.hushhw.cn/20190904173829.png" alt></p>
<p>其中，在神经网络中，参数（parameter）又可被称为<strong>权重（weight）</strong>；$x_0=1​$ 称为<strong>偏置单元（bias unit）</strong>，是否写出根据情况来定；红色的圈代表神经元，又称<strong>激活单元（activation unit）</strong>；g(z) 称为<strong>激活函数（activation function）</strong>，一般指「由……驱动的神经元计算函数 g(z)」，上面就是逻辑激活函数。</p>
<p>我们推演到多个神经元的情况：</p>
<p><img src="https://photo.hushhw.cn/20190904175859.png" alt></p>
<p>其中，第一层是输入层（Input layer），第三层是输出层（Output Layer），而中间数据处理的一层为隐藏层（Hidden Layers），有输入层加权组合后重新映射而成，每一层都可以加上偏置单元。</p>
<p>其中一些符号标记：</p>
<script type="math/tex; mode=display">
\begin{align}
a_i^{(j)} &= 第j层的第i个激活单元 \\
\Theta^{(j)} &= 控制从第j层到j+1层的映射函数的权重矩阵
\end{align}</script><p>其中，每一个激活结点都可以用 sigmoid 激活函数表示：</p>
<p><img src="https://photo.hushhw.cn/20190904191827.png" alt></p>
<p>由矩阵乘法可知：因此如果要从含有 $s<em>j$ 个单元的第 j 层映射到含有 $s_j+1$ 个单元的第 j+1 层，那么权重矩阵 Θ(j) 的尺寸为 $s</em>{j+1}×(s_j+1)​$，其中的 +1是因为要考虑偏置单元。</p>
<p>这种从左到右的算法称为<strong>前向传播算法（Forward propagation）</strong>。</p>
<h4 id="8-3-2-向量形式表达"><a href="#8-3-2-向量形式表达" class="headerlink" title="8.3.2. 向量形式表达"></a>8.3.2. 向量形式表达</h4><p>下面利用向量形式来表达该算法，以上面神经网络为例，试着计算第二层的值：</p>
<script type="math/tex; mode=display">
x=\left[ \begin{matrix} x_0 \\x_1 \\ x_2 \\x_3 \end{matrix} \right]、 
z^{(2)} = \left[ \begin{matrix} z_1^{(2)} \\ z_2^{(2)} \\ z_3^{(2)}\end{matrix} \right]</script><p>其中，$z^{(2)} = \Theta^{(1)}x，a^{(2)} = g(z^{(2)})$。</p>
<p>进而，我们得到了参数 z 计算的表达式，计算第 j-1 层到第 j 层映射 g(z) 的参数 z：</p>
<script type="math/tex; mode=display">
z^{(j)} = \Theta^{(j-1)}a^{(j-1)}</script><p>接着，用同样的方法计算下一层的信息：</p>
<script type="math/tex; mode=display">
z^{(j+1)} = \Theta^{(j)}a^{(j)}</script><p>这样上例中 $h_{\theta}(x)=a^{(3)}=g(z^{(3)})$。</p>
<h4 id="8-3-3-例子"><a href="#8-3-3-例子" class="headerlink" title="8.3.3. 例子"></a>8.3.3. 例子</h4><p>从本质上讲，神经网络能够通过学习得出其自身的一系列特征。在神经网络中，原始特征只是输入层，在我们上面三层的神经网络例子中，第三层也就是输出层做出的预测利用的是第二层的特征，而非输入层中的原始特征，我们可以认为第二层中的特征是神经网络通过学习后自己得出的一系列用于预测输出变量的新特征。 </p>
<p>神经网络中，单层神经元（无中间层）的计算可用来表示逻辑运算，比如逻辑与(AND)、逻辑或(OR)。 </p>
<p><img src="https://photo.hushhw.cn/20190905075722.png" alt></p>
<p><img src="https://photo.hushhw.cn/20190905075911.png" alt></p>
<p>当输入特征为布尔值时，我们可以用一个单一的激活层作为二元逻辑运算符（binary logical operators），为了表示不同的运算符，只需要修改不同的权重即可。</p>
<p>​          </p>
<h3 id="8-7-Multicalss-Classification"><a href="#8-7-Multicalss-Classification" class="headerlink" title="8.7. Multicalss Classification"></a>8.7. Multicalss Classification</h3><p>当我们有不止两种分类时，可通过神经网络算法来输出不同的结果进行判断，如第一个值是 1 或 0 来预测是否是行人，第二个值是否是 1 或 0 来预测是否是汽车等。</p>
<p><img src="https://photo.hushhw.cn/20190905171102.png" alt></p>
<p>​            </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://www.zhouyongyi.com/andrew-ng-machine-learning-notes-6/" target="_blank" rel="noopener">驿舟小站</a></p>
<p><a href="https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes" target="_blank" rel="noopener">Coursera-ML-AndrewNg-Notes</a></p>
<p><a href="https://www.coursera.org/course/ml" target="_blank" rel="noopener">斯坦福大学 2014 机器学习</a></p>
</blockquote>
]]></content>
      <categories>
        <category>笔记整理</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>吴恩达《机器学习》笔记（五）——正则化</title>
    <url>/posts/76f89b87.html</url>
    <content><![CDATA[<blockquote>
<p>评价一个模型拟合度是否优良的参考之一是它与实际数据集的偏差程度，我们用代价函数来定量，一般代价函数越小越好，但是当将它们应用在某些特定的机器学习应用时，会遇到<strong>过拟合（over-fitting）</strong>的问题。这时就需要采取一些措施，正则化就是其中一种方式。</p>
</blockquote>
<h2 id="Regularization"><a href="#Regularization" class="headerlink" title="Regularization"></a>Regularization</h2><h3 id="7-1-Overfitting"><a href="#7-1-Overfitting" class="headerlink" title="7.1. Overfitting"></a>7.1. Overfitting</h3><p>机器学习训练的目的是为了让模型更好的拟合实际情况，从而指导我们进行预测。评价一个模型拟合度是否优良的参考之一是它与实际数据集的偏差程度，我们用代价函数来定量，一般代价函数越小越好，但是当将它们应用在某些特定的机器学习应用时，会遇到<strong>过拟合（over-fitting）</strong>的问题。</p>
<p>下图是一个回归问题的例子：</p>
<p>第一个模型是一个线性模型，欠拟合，不能很好地适应我们的训练集；第三个模型是一个四次方的模型，过于强调拟合原始数据，而丢失了算法的本质：预测新数据。我们可以看出，若给出一个新的值使之预测，它将表现的很差，是过拟合，虽然能非常好地适应我们的训练集但在新输入变量进行预测时可能会效果不好；而中间的模型似乎最合适。 </p>
<p><img src="https://photo.hushhw.cn/20190805144528.png" alt></p>
<p>下图是一个分类问题的例子：</p>
<p>以多项式理解，𝑥 的次数越高，拟合的越好，但相应的预测的能力就可能变差。 </p>
<p><img src="https://photo.hushhw.cn/20190805144934.png" alt></p>
<p>由上述分析，我们可以由两种解决过拟合的方案：</p>
<ul>
<li>丢弃一些不能帮助我们正确预测的特征：可以手动选择保留哪些特征，或者使用一些模型选择的算法来帮忙</li>
<li>正则化：保留所有的特征变量，但是减少量级或参数 $\theta_j$ 的大小</li>
</ul>
<p>​            </p>
<h3 id="7-2-Cost-Function"><a href="#7-2-Cost-Function" class="headerlink" title="7.2. Cost Function"></a>7.2. Cost Function</h3><p>为了避免过拟合的问题，这里介绍前面提到的正则化的方法。</p>
<p>上面的回归问题中我们知道，正是那些高次项导致了过拟合的问题，所以如果我们能让这些高次项的系数接近于 0 的话，我们就能很好的拟合了。</p>
<p>所以，这里我们通过降低三次项和四次项的权重，即令 $𝜃_3$ 和 $𝜃_4$ 的值很小，使得拟合模型在大方向上是「二次多项式」在发挥作用。我们要做的便是修改代价函数，在其中 $𝜃_3$ 和 $𝜃_4$ 设置一点惩罚（penalize）。这样做的话，我们在尝试最小化代价时也需要将这个惩罚纳入考虑中，并最终导致选择较小一些的 $𝜃_3$ 和 $𝜃_4$ 。 </p>
<p><img src="https://photo.hushhw.cn/20190805152238.png" alt></p>
<p>通过这样的代价函数选择出的 $𝜃_3$ 和 $𝜃_4$ 对预测结果的影响就比之前要小许多。假如我们有非常多的特征，我们并不知道其中哪些特征我们要惩罚，我们将对所有的特征进行惩罚，并且让代价函数最优化的软件来选择这些惩罚的程度。这样的结果是得到了一个较为简单的能防止过拟合问题的假设：</p>
<script type="math/tex; mode=display">
J(\theta) = \frac{1}{2m}\left[ \sum^{m}_{i=1}(h_{\theta}(x^{(i)}-y^{(i)})^2 + \lambda\sum^n_{j=1}\theta^2_j\right]</script><p>其中 𝜆 又称为<strong>正则化参数（Regularization Parameter）</strong>。 根据惯例，我们不对 $𝜃_0​$ 进行惩罚。</p>
<p>对 𝜆 的取值要合理，如果 𝜆 过大的话，为了使得代价函数尽可能小，所有的 𝜃 值（不包括 $𝜃_0$）就都会在一定程度上减小，我们只能得到一条平行于 𝑥 轴的直线，这样会导致<strong>欠拟合（underfitting)</strong>。</p>
<p>​                 </p>
<h3 id="7-3-Regularized-Linear-Regression"><a href="#7-3-Regularized-Linear-Regression" class="headerlink" title="7.3. Regularized Linear Regression"></a>7.3. Regularized Linear Regression</h3><p>对于线性回归的求解，我们之前推到了两种学习算法：</p>
<ul>
<li>梯度下降</li>
<li>正规方程</li>
</ul>
<p>正则化线性回归的代价函数为：</p>
<script type="math/tex; mode=display">
J(\theta) = \frac{1}{2m}\left[ \sum^{m}_{i=1}(h_{\theta}(x^{(i)}-y^{(i)})^2 + \lambda\sum^n_{j=1}\theta^2_j\right]</script><p>如果我们要使用梯度下降法令这个代价函数最小化，其正则化迭代式如下：</p>
<script type="math/tex; mode=display">
\begin{align}
Repeat \{ \\
θ_0 &:= θ_0-\alpha\frac1m\sum^m_{i=1}(h_θ(x^{(i)})-y^{(i)})x^{(i)}_0 \\
θ_j &:= θ_j-\alpha \left[ \left( \frac1m\sum^m_{i=1}(h_θ(x^{(i)})-y^{(i)})x^{(i)}_j\right) + \frac{\lambda}{m}θ_j \right] \ j\in\{1,2,\cdots,n\}\\
\}
\end{align}</script><p>将 $θ_0$ 单独分开的原因上面提到了，其对应的特征量是 1，约定俗成不必正则化。上式可在整理为：</p>
<script type="math/tex; mode=display">
θ_j := θ_j(1-\alpha\frac{\lambda}{m})-\alpha\frac1m\sum^m_{i=1}(h_θ(x^{(i)})-y^{(i)})x^{(i)}_j</script><p>在这个形式下，我们可以理解得到，每一次迭代都会多乘一个小于一的系数 $1–α\fracλm$，进而缩小。</p>
<p>​              </p>
<p>如果我们要使用正规方程来求解正则化线性回归模型，方法如下：</p>
<p><img src="https://photo.hushhw.cn/20190805165041.png" alt></p>
<script type="math/tex; mode=display">
\theta = (X^TX + \lambda L)^{-1}X^Ty  \\
where \ L = \left[
\begin{matrix}
0 \qquad\qquad\qquad\qquad \\
\qquad 1  \qquad\qquad\qquad\\
\qquad\qquad1 \qquad\qquad \\
\qquad\qquad\qquad\ddots \qquad \\
\qquad\qquad\qquad\qquad 1
\end{matrix}
\right]</script><pre><code> 其中 L 为(n+1)*(n+1)。
</code></pre><p>​              </p>
<h3 id="7-4-Regularized-Logistic-Regression"><a href="#7-4-Regularized-Logistic-Regression" class="headerlink" title="7.4. Regularized Logistic Regression"></a>7.4. Regularized Logistic Regression</h3><p><img src="https://photo.hushhw.cn/20190811143857.png" alt></p>
<p>对于 logistic 回归模型，如果你得模型中有很多的特征，有无关紧要的多项式，这些大量的特征就会造成过拟合现象。</p>
<p>logistic 回归模型正则化后的代价函数为：</p>
<script type="math/tex; mode=display">
J(\theta) = -\frac{1}{m}\sum^{m}_{i=1}\left[y^{(i)}log\ h_{\theta}(x^{(i)}) + (1-y^{(i)})log(1-h_{\theta}(x^{(i)}))\right] + \frac{λ}{2m}\sum^n_{j=1}\theta^2_j</script><p>如果使用梯度下降算法最小化代价函数的话，其正则化迭代式为：</p>
<script type="math/tex; mode=display">
\begin{align}
Repeat \{ \\
θ_0 &:= θ_0-\alpha\frac1m\sum^m_{i=1}(h_θ(x^{(i)})-y^{(i)})x^{(i)}_0 \\
θ_j &:= θ_j-\alpha \left[ \left( \frac1m\sum^m_{i=1}(h_θ(x^{(i)})-y^{(i)})x^{(i)}_j\right) + \frac{\lambda}{m}θ_j \right] \ j\in\{1,2,\cdots,n\}\\
\}
\end{align}</script><p>看上去和线性回归一样，但是因为 $h_{\theta}(x) = g({\theta}^TX)$，所以与线性回归不同。</p>
<p>​                 </p>
<h2 id="专业名词整理"><a href="#专业名词整理" class="headerlink" title="专业名词整理"></a>专业名词整理</h2><ul>
<li><code>overfitting</code>：过拟合、<code>underfitting</code>：欠拟合</li>
</ul>
<p>​            </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://www.zhouyongyi.com/andrew-ng-machine-learning-notes-5/" target="_blank" rel="noopener">驿舟小站</a></p>
<p><a href="https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes" target="_blank" rel="noopener">Coursera-ML-AndrewNg-Notes</a></p>
<p><a href="https://www.coursera.org/course/ml" target="_blank" rel="noopener">斯坦福大学 2014 机器学习</a></p>
</blockquote>
]]></content>
      <categories>
        <category>笔记整理</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Google Hacking 语法使用总结</title>
    <url>/posts/4884afb4.html</url>
    <content><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>虽然一直知道 Google Hacking 功能的强大，平常也会用到一些语法，但是终究用的不熟练，或者没有充分发挥它的功能，所以写下这篇文章总结一下。</p>
<h2 id="Google-Hacking-常用语法"><a href="#Google-Hacking-常用语法" class="headerlink" title="Google Hacking 常用语法"></a>Google Hacking 常用语法</h2><ul>
<li><strong>intext</strong>：把网页中的正文内容中的某个字符作为搜索条件</li>
<li><strong>intitle</strong>：把网页标题中的某些字符作为搜索条件</li>
<li><strong>cache</strong>：搜索搜索引擎里关于某些内容的缓存</li>
<li><strong>filetype</strong>：指定一个格式类型的文件作为搜索对象</li>
<li><strong>inurl</strong>：搜索包含指定字符的 URL</li>
<li><strong>site</strong>：在指定的站点搜索相关内容</li>
</ul>
<h2 id="Google-Hacking-其它语法"><a href="#Google-Hacking-其它语法" class="headerlink" title="Google Hacking 其它语法"></a>Google Hacking 其它语法</h2><ul>
<li><strong>引号「””</strong>」：把关键字打上引号后把引号部分作为整体来搜索</li>
<li><strong>or</strong>：同时搜索两个或更多的关键字</li>
<li><strong>link</strong>：搜索某个网站的链接<br>这些语法可叠加使用。</li>
</ul>
]]></content>
      <categories>
        <category>日常技巧</category>
      </categories>
      <tags>
        <tag>搜索技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>吴恩达《机器学习》笔记（四）——Logistic回归</title>
    <url>/posts/f72c23ef.html</url>
    <content><![CDATA[<blockquote>
<p>本文内容介绍「logistic 回归」解决分类问题。</p>
</blockquote>
<h2 id="Logistic-Regression"><a href="#Logistic-Regression" class="headerlink" title="Logistic Regression"></a>Logistic Regression</h2><h3 id="6-1-Classification"><a href="#6-1-Classification" class="headerlink" title="6.1. Classification"></a>6.1. Classification</h3><p>与回归问题不同的是，分类问题中输出 y 不是连续的值，只能是 0 或者 1。并且 0 一般用来代表负向类（negative class），1 代表正向类（positive class），当然也可以任意指定。</p>
<p>如果我们要用线性回归算法来解决一个分类问题，对于分类， 𝑦 取值为 0 或者 1，那么假设函数的输出值可能远大于 1，或者远小于 0，即使所有训练样本的标签 𝑦 都等于 0 或 1。尽管我们知道标签应该取值 0 或者 1，但是如果算法得到的值远大于 1 或者远小于 0 的话，就会感觉很奇怪。所以我们在接下来的要研究的算法就叫做 <strong>Logistic 回归</strong>，这个算法的性质是：它的输出值永远在 0 到 1 之间。 </p>
<p>​        </p>
<h3 id="6-2-Hypothesis-Representation"><a href="#6-2-Hypothesis-Representation" class="headerlink" title="6.2 Hypothesis Representation"></a>6.2 Hypothesis Representation</h3><p>在分类问题中，要用什么样的函数来表示我们的假设。希望我们的分类器的输出值在 0 和 1 之间，因此，我们希望想出一个满足某个性质的假设函数，这个性质是它的预测值要在 0 和 1 之间，于是我们引入了一个新的模型——逻辑回归（Logistic Regression），该模型的输出变量范围式中在 0 和 1 之间。</p>
<p>logistic 回归模型的假设是：$h_{\theta}(x) = g(\theta^TX)$，其中 X 代表特征向量，g 代表 logistic 函数（logistic function）是一个常用的逻辑函数为 <strong>sigmoid 函数（Sigmoid function）</strong>，公式为：$g(z)= \frac1{1+e^{-z}} $，该函数图像如下图：</p>
<p> <img src="https://photo.hushhw.cn/20190721154842.png" alt></p>
<p>下面我们来理解一下 logistic 回归模型的假设：</p>
<script type="math/tex; mode=display">
h_{\theta}(x) = \frac1{1+e^{-\theta^Tx}}</script><p>其中，h 表示对于给定的输入变量，根据选择的参数计算输出变量为 1 的可能性（estimated probablity），即 $ℎ_𝜃(𝑥) = 𝑃(𝑦 = 1|𝑥;𝜃)​$。</p>
<p>例如，如果对于给定的 𝑥，通过已经确定的参数计算得出 $ℎ_𝜃(𝑥) = 0.7​$，则表示有 70% 的几率 𝑦 为正向类，相应地 𝑦 为负向类的几率为 1-0.7=0.3。 </p>
<p>​           </p>
<h3 id="6-3-Decision-Boundary"><a href="#6-3-Decision-Boundary" class="headerlink" title="6.3. Decision Boundary"></a>6.3. Decision Boundary</h3><p>这一节讨论<strong>决策边界（Decision Boundary）</strong>问题，根据上面 sigmoid 函数的图像我们知道，当 $z\geq 0​$ 时 $g(z) \geq 0.5​$，反之小于 0.5，对应的 logistic 回归模型的假设得到：</p>
<script type="math/tex; mode=display">
\theta^Tx \geq 0\ 时，预测\ y = 1\\
\theta^Tx < 0 \ 时，预测\ y=0</script><p>假设有一个模型其假设函数为：$h_{\theta}(x) = g(\theta_0 + \theta_1x_1 + \theta_2x_2)​$，并且假设我们已经得到了参数 𝜃 的转置向量为 [-3 1 1]。则当 $-3 + x_1 + x_2 \geq 0​$，即 $x_1 + x_2 \geq 3​$ 时，模型将预测 y = 1。我们绘制出这条直线 $x_1 + x_2 = 3​$，这条线便是模型的分界线，即<strong>决策边界</strong>。</p>
<p><img src="https://photo.hushhw.cn/20190721162039.png" alt></p>
<p>更进一步，若假设函数是非线性的，$h_θ=g(θ_0+θ_1x_1+θ_2x_2+θ_3x^2_1+θ_4x^2_2)​$，当我们通过算法得出 θ 后，画出图形如下，此时决策边界不一定是直线了：</p>
<p><img src="https://photo.hushhw.cn/20190721162441.png" alt></p>
<p>​           </p>
<h3 id="6-4-Cost-Function"><a href="#6-4-Cost-Function" class="headerlink" title="6.4. Cost Function"></a>6.4. Cost Function</h3><p>如何拟合 logistic 回归模型的参数 θ 呢？我们定义用来拟合参数的优化目标或者叫代价函数（cost function）。</p>
<p>在线性回归模型中，我们定义的代价函数是所有模型误差的平方和，即代价函数为：</p>
<script type="math/tex; mode=display">
J(\theta) = \frac{1}{2m}\sum^m_{i=1}(h^{(i)}_{\theta}-y^{(i)})^2</script><p>它的结构形式可以写成：</p>
<script type="math/tex; mode=display">
J(\theta) = \frac{1}{m}\sum^m_{i=1}\frac12(h^{(i)}_{\theta}-y^{(i)})^2 \\
=\frac{1}{m}\sum^m_{i=1}Cost(h_{\theta}(x^{(i)}),y)</script><p>理论上来说，我们也可以对逻辑回归模型沿用这个定义，但是问题在于当我们将 $h_{\theta}(x) = \frac1{1+e^{-\theta^Tx}}$ 带入到这样定义了的代价函数中时，我们得到的代价函数将是一个<strong>非凸函数（non-convex）</strong>。 </p>
<p><img src="https://photo.hushhw.cn/20190731144737.png" alt></p>
<p>这意味着我们的代价函数有许多局部最小值，这将影响梯度下降算法寻找全局最小值。</p>
<p>这里 Andrew Ng 不加证明的重新给出了代价函数：</p>
<script type="math/tex; mode=display">
Cost(h_{\theta}(x),y) = 
\begin{cases}
\begin{align}
-log(h_{\theta}(x)) \qquad if\quad y=1 \\
-log(1-h_{\theta}(x)) \qquad if\quad y=0
\end{align}
\end{cases}</script><p>$h_{\theta}(x)​$ 与代价函数之间的关系如下图：</p>
<p><img src="https://photo.hushhw.cn/20190731150435.png" alt></p>
<p><img src="https://photo.hushhw.cn/20190731150528.png" alt></p>
<p>这样构建的代价函数的特点是：</p>
<ul>
<li><p>当实际的 y = 1 时，$h_{\theta}(x)$ 为 1 时误差为 0，不为 1 时误差随着趋于 0 而变大；</p>
</li>
<li><p>当实际的 y = 0 时，$h_{\theta}(x)$ 为 0 时误差为 0，不为 0 时误差随着趋于 1 而变大。</p>
</li>
</ul>
<p>由于 y 只能取 0 或 1，可以把这个式子整合成：</p>
<script type="math/tex; mode=display">
Cost(h_{\theta}(x), y) = -ylog(h_{\theta}(x)) - (1-y)log(1-h_{\theta}(x))</script><p>即 logistic 回归的代价函数为：</p>
<script type="math/tex; mode=display">
\begin{align}
J(\theta) &= \frac{1}{m}\sum^{m}_{i=1}Cost(h_{\theta}(x^{(i)}),y^{(i)}) \\
&= -\frac{1}{m}\sum^{m}_{i=1}\left[y^{(i)}log\ h_{\theta}(x^{(i)}) + (1-y^{(i)})log(1-h_{\theta}(x^{(i)}))\right]
\end{align}</script><p>​            </p>
<h3 id="6-5-Gradient-Descent"><a href="#6-5-Gradient-Descent" class="headerlink" title="6.5. Gradient Descent"></a>6.5. Gradient Descent</h3><p>在得到这样一个代价函数后，我们便可以用<strong>梯度下降算法</strong>来求得使代价函数最小的参数了，即最小化 J(𝜃)。</p>
<p>梯度下降算法前面我们已经用过，用循环运算表达的形式如下：</p>
<script type="math/tex; mode=display">
\theta_j:=\theta_j-\alpha\frac{∂}{∂\theta_j}J(\theta)</script><p>用上面的式子来不断更新所有的 𝜃 值，如果将 J(θ) 的偏导数带入后，我们得到：</p>
<script type="math/tex; mode=display">
\theta_j:=\theta_j-\alpha\sum^{m}_{i=1}(h_{\theta}(x^{(i)})-y^{(i)})x^{(i)}_j</script><p>现在，如果你把这个更新规则和我们之前用在线性回归上的进行比较的话，你会惊讶地发现，这个式子正是我们用来做线性回归梯度下降的。 但是线性回归和 logistic 回归并不一样，因为两者的假设函数 $h_{\theta}(x)$ 不一样。</p>
<hr>
<p><strong>代价函数偏导数的过程</strong></p>
<p>首先计算 sigmoid 函数的导数：</p>
<script type="math/tex; mode=display">
\begin{split}
σ(x)^{'} &=(\frac{1}{1+e^{-x}})^{'} 
=\frac{e^{-x}}{(1+e^{-x})^2}=(\frac{1}{1+e^{-x}})(\frac{e^{-x}}{1+e^{-x}})=σ(x)(\frac{1+e^{-x}-1}{1+e^{-x}}) \\
&= σ(x)(1-σ(x))
\end{split}</script><p>再来对代价函数求偏导：</p>
<script type="math/tex; mode=display">
\begin{align}
\frac{∂}{∂θ_j}J(θ) 
&= \frac{∂}{∂θ_j}\frac{-1}{m}\sum^{m}_{i=1}\left[y^{(i)}log\ h_{\theta}(x^{(i)}) + (1-y^{(i)})log(1-h_{\theta}(x^{(i)}))\right] \\
&= -\frac1m\sum^{m}_{i=1}\left[y^{(i)}\frac{∂}{∂θ_j}log\ h_{\theta}(x^{(i)}) + (1-y^{(i)})\frac{∂}{∂θ_j}log(1-h_{\theta}(x^{(i)}))\right] \\
&= -\frac1m\sum^{m}_{i=1}\left[y^{(i)}\frac{\frac{∂}{∂θ_j}h_{\theta}(x^{(i)})}{h_{\theta}(x^{(i)})} + (1-y^{(i)})\frac{\frac{∂}{∂θ_j}(1-h_{\theta}(x^{(i)}))}{1-h_{\theta}(x^{(i)})}\right] \\
&= -\frac1m\sum^{m}_{i=1}\left[y^{(i)}\frac{\frac{∂}{∂θ_j}σ({\theta}^Tx^{(i)})}{σ({\theta}^Tx^{(i)})} + (1-y^{(i)})\frac{\frac{∂}{∂θ_j}(1-σ({\theta}^Tx^{(i)}))}{1-σ({\theta}^Tx^{(i)})}\right] \\
&= -\frac1m\sum^{m}_{i=1}\left[y^{(i)}\frac{σ(1-σ)\frac{∂}{∂θ_j}({\theta}^Tx^{(i)})}{σ} + (1-y^{(i)})\frac{σ(1-σ)\frac{∂}{∂θ_j}(1-{\theta}^Tx^{(i)})}{1-σ}\right] \\
&= -\frac1m\sum^{m}_{i=1}\left[y^{(i)}(1-σ)x^{(i)}_j - (1-y^{(i)})σx^{(i)}_j\right] \\
&= -\frac1m\sum^{m}_{i=1}\left[y^{(i)}(1-h_{\theta}(x^{(i)})) - (1-y^{(i)})h_{\theta}(x^{(i)})\right]x^{(i)}_j \\
&= -\frac1m\sum^{m}_{i=1}\left[y^{(i)}-y^{(i)}h_{\theta}(x^{(i)}) - h_{\theta}(x^{(i)})+y^{(i)}h_{\theta}(x^{(i)})\right]x^{(i)}_j \\
&= -\frac1m\sum^{m}_{i=1}\left[y^{(i)} - h_{\theta}(x^{(i)})\right]x^{(i)}_j \\
&= \frac1m\sum^{m}_{i=1}\left[h_{\theta}(x^{(i)})-y^{(i)}\right]x^{(i)}_j \\
\end{align}</script><p>​             </p>
<h3 id="6-6-Advanced-Optimization"><a href="#6-6-Advanced-Optimization" class="headerlink" title="6.6. Advanced Optimization"></a>6.6. Advanced Optimization</h3><p>上面我们讨论了用梯度下降的方法最小化逻辑回归中代价函数 𝐽(𝜃)。这一节介绍一些一些高级优化算法和一些高级的优化概念，利用这些方法我们就能够使通过梯度下降进行 logistic 回归的速度大大提高，而这也将使算法更加适合解决大型的机器学习问题。</p>
<p> 如果我们能用这些方法来计算代价函数 𝐽(𝜃) 和偏导数项的话，那么这些算法就是为我们优化代价函数的不同方法，<strong>共轭梯度法</strong>、<strong>BFGS（变尺度法）</strong>和 <strong>L-BFGS（限制变尺度法）</strong>就是其中一些更高级的优化算法，它们需要有一种方法来计算 𝐽(𝜃) 以及需要一种方法计算导数项，然后使用比梯度下降更复杂的算法来最小化代价函数。</p>
<p>他们相对比较复杂，优势主要有两点</p>
<ul>
<li>不需要选择学习率α，算法会自适应</li>
<li>经常比梯度下降算法快</li>
</ul>
<p>​           </p>
<h3 id="6-7-Multi-class-classification-One-vs-all"><a href="#6-7-Multi-class-classification-One-vs-all" class="headerlink" title="6.7. Multi-class classification: One-vs-all"></a>6.7. Multi-class classification: One-vs-all</h3><p>前面我们讨论的分类问题都是<strong>二元分类（Binary classification）</strong>，这一节介绍使用 logistic 回归来解决<strong>多类别分类（Multi-class classfication）</strong>问题，具体来说讨论「一对多」的分类问题。</p>
<p><img src="https://photo.hushhw.cn/20190801162235.png" alt></p>
<p>解决多类别分类问题的思路是将其分成多个二元分类问题。</p>
<p><img src="https://photo.hushhw.cn/20190801162837.png" alt></p>
<p>​                               </p>
<h2 id="专业名词整理"><a href="#专业名词整理" class="headerlink" title="专业名词整理"></a>专业名词整理</h2><ul>
<li><code>dependent variable</code>：因变量</li>
<li><code>convex function</code>：凸函数、<code>non-convex function</code>：非凸函数</li>
<li><code>maximum likelihood estimation</code>：极大似然估计</li>
<li><code>binary classification</code>：二元分类、<code>multi-class classfication</code>：多类别分类</li>
</ul>
<p>​             </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://www.zhouyongyi.com/andrew-ng-machine-learning-notes-4/" target="_blank" rel="noopener">驿舟小站</a></p>
<p><a href="https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes" target="_blank" rel="noopener">Coursera-ML-AndrewNg-Notes</a></p>
<p><a href="https://www.coursera.org/course/ml" target="_blank" rel="noopener">斯坦福大学 2014 机器学习</a></p>
</blockquote>
]]></content>
      <categories>
        <category>笔记整理</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>吴恩达《机器学习》笔记（三）——多变量线性回归</title>
    <url>/posts/92253a1a.html</url>
    <content><![CDATA[<blockquote>
<p>本文内容介绍「多变量线性回归」问题。</p>
<p>首先引入一个多维特征模型，利用「多变量梯度下降」来迭代求出代价函数最小值。</p>
<p>之后介绍了「多项式回归」问题，以及「正规方程」，并把正规方程和梯度下降问题做了比较。</p>
</blockquote>
<h2 id="Linear-Algebra-Review"><a href="#Linear-Algebra-Review" class="headerlink" title="Linear Algebra Review"></a>Linear Algebra Review</h2><p>这部分线性代数的只是非常基础，仅仅整理了一些专业名词的英文去熟悉学习。</p>
<p>​        </p>
<h2 id="Linear-Regression-with-Multiple-Variables"><a href="#Linear-Regression-with-Multiple-Variables" class="headerlink" title="Linear Regression with Multiple Variables"></a>Linear Regression with Multiple Variables</h2><h3 id="4-1-Multiple-Features"><a href="#4-1-Multiple-Features" class="headerlink" title="4.1. Multiple Features"></a>4.1. Multiple Features</h3><p>前面我们讨论了单变量特征（single variable）的回归模型（影响房屋价格的因素仅有面积大小），现在我们对房价模型增加更多的特征 $(x_1,x_2,…,x_n)$，构成一个多变量的模型。</p>
<p>下面这个例子为四个特征的模型，其中一些参数的说明如图：</p>
<p><img src="https://photo.hushhw.cn/20190716173040.png" alt></p>
<p>支持多变量的假设 ℎ 表示为：</p>
<script type="math/tex; mode=display">
ℎ_{\theta}(𝑥) = \theta_0 + \theta_1x_1 + \theta_2x_2+...+\theta_𝑛x_𝑛</script><p>这个公式中有 𝑛 + 1 个参数和 𝑛 个变量，为了使得公式能够简化一些，引入 $x_0 = 1$，则公式转化为：</p>
<script type="math/tex; mode=display">
ℎ_{\theta}(𝑥) = \theta_0x_0 + \theta_1x_1 + \theta_2x_2+...+\theta_𝑛x_𝑛</script><p>改写成矩阵的形式：</p>
<script type="math/tex; mode=display">
h_{\theta}(x) = \left[
\begin{matrix}
\theta_0 & \theta_1 & \theta_2 \cdots & \theta_n 
\end{matrix}
\right]
\left[
\begin{matrix}
x_0 \\ x_1 \\x_2 \\ \vdots\\ x_n
\end{matrix}
\right]
 = \theta^TX</script><p>此时模型中的参数是一个 𝑛 + 1 维的向量，任何一个训练实例也都是 𝑛 + 1 维的向量，相乘就相当于参数向量的转置乘以实例向量，因此公式可以简化为：</p>
<script type="math/tex; mode=display">
h_{\theta}(x) = \theta^TX</script><p>​        </p>
<h3 id="4-2-Gradient-Descent-for-Multiple-Variables"><a href="#4-2-Gradient-Descent-for-Multiple-Variables" class="headerlink" title="4.2. Gradient Descent for Multiple Variables"></a>4.2. Gradient Descent for Multiple Variables</h3><p>与单变量线性回归类似，在多变量线性回归中，我们也构建一个代价函数（cost function），则这个代价函数是所有建模误差的平方和，即：</p>
<script type="math/tex; mode=display">
J(\theta_0,\theta_1,\cdots,\theta_n)=\frac{1}{2m}\sum^m_{i=1}(h_{\theta}(x^{(i)})-y^{(i)})^2</script><p>我们可以简写成 $J(\theta)$ ，其中：$h_{\theta}(x) = \theta^TX = \theta_0 + \theta_1x_1 + \theta_2x_2 + \cdots + \theta_nx_n$</p>
<p>我们的目标和单变量线性回归问题一样，要找到使得代价函数最小的系列参数，使用梯度下降的方法来求，就是要不断的更新每一个 $\theta_j$ 参数，通过 $\theta_j$ 减去 $\alpha$ 乘以导数项，具体过程如下图，分别是单特征和有多个特征的模型的情况。</p>
<p><img src="https://photo.hushhw.cn/20190716183159.png" alt></p>
<p>​          </p>
<h3 id="4-3-Feature-Scaling"><a href="#4-3-Feature-Scaling" class="headerlink" title="4.3. Feature Scaling"></a>4.3. Feature Scaling</h3><p>机器学习中我们使用参数的目标是为了通过数据集改善每一个特征量 x 对应的权重 θ，最终得到拟合度高的假设方程。这时就出现了一种情况，如果某个特征量的数量级远大于其它特征量，就会导致该特征在学习算法中占主导位置。所以，我们需要通过预处理的方式让初始的特征量具有同等的地位，才能让机器学习算法更快地学习得到他们的权重。</p>
<p>使用这里「房价预估」的例子，假设有两个特征影响房价，分别是「面积」和「房间数」，很显然这两个数据差别是非常大的，在没有进行单位统一之前，由于变量的单位相差很大，导致了椭圆型的梯度轮廓；缩放之后将变量变成同一单位，产生了圆形轮廓。</p>
<p><img src="https://photo.hushhw.cn/20190721103703.png" alt></p>
<p><img src="https://photo.hushhw.cn/20190721103741.png" alt="图片来源：TingMind.cn"></p>
<p>由于梯度下降是按切线方向下降，所以导致了系统在椭圆轮廓不停迂回地寻找最优解，而圆形轮廓就能轻松找到。</p>
<p>特征缩放的方法有很多，比如使用 $x_n = \frac{x_n-\mu}{max-min}$ 的方式，将数据缩放为 [-1, 1] 的范围，例如房屋面积范围在 [100, 2000]，平均值为 1000，就可以将均值 1000 以及最大最小值差带入。</p>
<p>更一般的方法，可以使用<strong>均值归一化（mean normalization）</strong>使得数据集的平均值为零：$x_n = \frac{x_n-\mu_n}{s_n}​$，其中 𝜇 是平均值，𝑠 是标准差。 </p>
<blockquote>
<p>埋坑：这里需要去理解特征标准化和归一化的区别，有待深入学习。</p>
</blockquote>
<p>​        </p>
<h3 id="4-4-Learning-Rate"><a href="#4-4-Learning-Rate" class="headerlink" title="4.4. Learning Rate"></a>4.4. Learning Rate</h3><p>梯度下降算法收敛所需要的迭代次数根据模型的不同而不同，我们不能提前预知，我们可以绘制迭代次数和代价函数的图表来观测算法在何时趋于收敛。 也有一些自动测试是否收敛的方法，例如将代价函数的变化值与某个阀值（例如 0.001）进行比较。</p>
<p>梯度下降算法的每次迭代受到学习率的影响，如果学习率 𝑎 过小，则达到收敛所需的迭代次数会非常高；如果学习率 𝑎 过大，每次迭代可能不会减小代价函数，可能会越过局部最小值导致无法收敛。</p>
<p>​         </p>
<h3 id="4-5-Polynomial-Regression"><a href="#4-5-Polynomial-Regression" class="headerlink" title="4.5. Polynomial Regression"></a>4.5. Polynomial Regression</h3><p>前面学习了线性回归，但是线性回归并不适用于所有数据，有时我们需要曲线来适应我们的数据，这一节继续学习<strong>多项式回归（Polynomial Regression）</strong>，比如一个三次方模型：$h_{\theta}(x) = \theta_0+\theta_1x_1+\theta_2x^2_2+\theta_3x_3^3$，下图是一个一元多项式回归的例子。</p>
<p><img src="https://photo.hushhw.cn/20190721123805.png" alt></p>
<p>如果我们采用多项式回归模型，在运行梯度下降算法前，特征缩放非常有必要。 </p>
<p>​            </p>
<h3 id="4-6-Normal-Equation"><a href="#4-6-Normal-Equation" class="headerlink" title="4.6. Normal Equation"></a>4.6. Normal Equation</h3><p>在前面我们学习了使用梯度下降法来计算参数最优解，其过程是对代价函数相对于每个参数求偏导数，通过迭代算法一步一步进行同步更新，直到收敛到全局最小值，从而得到最优参数值。但是对于某些线性回归问题，<strong>正规方程（Normal Equation）</strong>方法是更好的解决方案，正规方程则是通过数学方法一次性求得最优解。</p>
<p>下面这个例子中，我们有 4 个训练样本，我们构建一个矩阵 X 包含训练样本的所有特征变量，构成一个 m*(n+1) 维矩阵，所有的预测值放入向量 y，构成一个 m 维向量。代价函数最小化的 $\theta = (X^TX)^{-1}X^Ty​$。</p>
<p><img src="https://photo.hushhw.cn/20190721130118.png" alt></p>
<p>对于更一般的情况，假设有 m 组训练样本分别为 $(x^{(1)},y^{(1)},\cdots,x^{(m)},y^{(m)})$，每组训练样本有 n 个特征值。其中，</p>
<script type="math/tex; mode=display">
x^{(i)} = 
\left[
    \begin{matrix}
    x_0^{(i)}\\x_1^{(i)}\\x_2^{(i)}\\\vdots\\x_n^{(i)}
    \end{matrix}
\right]
\in R^{n+1}
,对应的 X = \left[
    \begin{matrix}
    \cdots {x^{(1)}}^T \cdots \\
    \cdots {x^{(2)}}^T \cdots \\
    \vdots  \\
    \cdots {x^{(m)}}^T \cdots \\
    \end{matrix}
\right]</script><p>对于那些不可逆的矩阵（通常是因为特征之间不独立，如同时包含英尺为单位的尺寸和米为单位的尺寸两个特征，也有可能是特征数量大于训练集的数量），正规方程方法是不能用的。 </p>
<p>梯度下降与正规方程比较：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">梯度下降</th>
<th style="text-align:center">正规方程</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">需要选择学习率𝛼</td>
<td style="text-align:center">不需要</td>
</tr>
<tr>
<td style="text-align:center">需要多次迭代</td>
<td style="text-align:center">一次运算得出</td>
</tr>
<tr>
<td style="text-align:center">当特征数量 𝑛 大时也能较好适用</td>
<td style="text-align:center">需要计算 ${(X^TX)}^{-1}$ 如果特征数量 𝑛 较大则运算代价大，因为矩阵逆的计算时间复杂度 为 $𝑂(𝑛^3)$，通常来说当 𝑛 小于 10000 时还是可以接受的</td>
</tr>
<tr>
<td style="text-align:center">适用于各种类型的模型</td>
<td style="text-align:center">只适用于线性模型，不适合逻辑回归模型等其他模型</td>
</tr>
</tbody>
</table>
</div>
<p>只要特征变量的数目并不大，标准方程是一个很好的计算参数𝜃的替代方法。具体地说，只要特征变量数量小于一万，我通常使用标准方程法，而不使用梯度下降法。<br>随着我们要讲的学习算法越来越复杂，例如，当我们讲到分类算法，像逻辑回归算法，我们会看到，实际上对于那些算法，并不能使用标准方程法。对于那些更复杂的学习算法，我们将不得不仍然使用梯度下降法。因此，梯度下降法是一个非常有用的算法，可以用在有大量特征变量的线性回归问题。</p>
<p>​         </p>
<h2 id="专业名词整理"><a href="#专业名词整理" class="headerlink" title="专业名词整理"></a>专业名词整理</h2><ul>
<li><code>linear algebra</code>：线性代数</li>
<li><code>matrix(matrices)</code>：矩阵</li>
<li><code>vector</code>：向量</li>
<li><code>two dimensional array</code>：二维数组</li>
<li><code>multiplication</code>：乘法</li>
<li><code>inverse</code>：逆、<code>transpose</code>：转置</li>
<li><code>superscript</code>：上标、<code>subscript</code>：下标</li>
<li><code>feature scaling</code>：特征放缩</li>
<li><code>standard deviation</code>：标准差</li>
<li><code>average value</code>：平均值</li>
<li><code>polynomial</code>：多项式</li>
<li><code>normal equation</code>：正规方程</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://www.tinymind.cn/articles/1217" target="_blank" rel="noopener">数据特征 标准化和归一化你了解多少？</a></p>
<p><a href="https://www.zhouyongyi.com/andrew-ng-machine-learning-notes-3/" target="_blank" rel="noopener">驿舟小站</a></p>
<p><a href="https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes" target="_blank" rel="noopener">Coursera-ML-AndrewNg-Notes</a></p>
<p><a href="https://www.coursera.org/course/ml" target="_blank" rel="noopener">斯坦福大学 2014 机器学习</a></p>
</blockquote>
]]></content>
      <categories>
        <category>笔记整理</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>吴恩达《机器学习》笔记（二）——单变量线性回归</title>
    <url>/posts/df3b9948.html</url>
    <content><![CDATA[<blockquote>
<p>本文内容主要介绍「单变量线性回归」的问题。</p>
<p>借助一个单变量线性回归模型，求得它的「代价函数」，并利用「梯度下降」的方法来最小化代价函数，从而达到训练模型的目的。</p>
</blockquote>
<h2 id="Linear-Regression-with-One-Variable"><a href="#Linear-Regression-with-One-Variable" class="headerlink" title="Linear Regression with One Variable"></a>Linear Regression with One Variable</h2><h3 id="2-1-Univariate-linear-regression"><a href="#2-1-Univariate-linear-regression" class="headerlink" title="2.1 Univariate linear regression"></a>2.1 Univariate linear regression</h3><ul>
<li>$𝑚$ 代表训练集中实例的数量 </li>
<li>$𝑥$ 代表特征/输入变量 </li>
<li>$𝑦​$ 代表目标变量/输出变量 </li>
<li>$(𝑥,𝑦)​$ 代表训练集中的实例 </li>
<li>$(𝑥^{(𝑖)},𝑦^{(𝑖)})$ 代表第𝑖 个观察实例 </li>
<li>$ℎ$ 代表学习算法的解决方案或函数也称为假设（<strong>hypothesis</strong>） </li>
</ul>
<p>这里以房屋价格预测为例，我们的学习算法中，我么需要通过学习得到一个假设 h，h 表示一个函数，输入房屋尺寸大小 x，从而得到输出房屋的价格 y，因此 h 是一个从 x 到 y 的函数映射。<br><img src="https://photo.hushhw.cn/20190716121509.png" alt></p>
<p>这里我们采用 $h_{\theta}(x) = \theta_0 + \theta_1x$ 来表达 h，因为只含有一个特征/输入变量，因此被称为<strong>单变量线性回归问题（Univariate linear regression）</strong>。</p>
<p>​           </p>
<h3 id="2-2-Cost-function"><a href="#2-2-Cost-function" class="headerlink" title="2.2 Cost function"></a>2.2 Cost function</h3><p>我们前面得到了预测的函数是一个线性函数：$h_{\theta}(x) = \theta_0 + \theta_1x$，下面我们需要选择合适的参数（parameters）$\theta_0$ 和 $\theta_1$ 来使得我们的预测更加准确，模型所预测的值和训练集中实际值之间的差距就是<strong>建模误差（modeling error）</strong>。</p>
<p>一般而言，我们通过调整 θ，使得所有训练集数据与其拟合数据的差的平方和更小，即认为得到了拟合度更好的函数。从而我们得到<strong>代价函数（cost function）</strong>：</p>
<script type="math/tex; mode=display">
J（\theta_0,\theta_1) = \frac{1}{2m}\sum^m_{i=1}(h_{\theta}(x^{(i)})-y^{(i)})^2</script><p>这里的$\frac{1}{2}$ 是为了方便后面的运算而加上的。</p>
<p>代价函数又被称为<strong>平方误差函数</strong>，有时也被称为<strong>平方误差代价函数</strong>。求误差的平方在大多数问题，特别是回归问题都是一个合理的选择。</p>
<p>回顾一下目前为止我们的思路：</p>
<p><img src="https://photo.hushhw.cn/20190716133921.png" alt></p>
<p>​          </p>
<h3 id="2-3-Gradient-Descent"><a href="#2-3-Gradient-Descent" class="headerlink" title="2.3 Gradient Descent"></a>2.3 Gradient Descent</h3><p>本节来解决如何求 $minimize J(\theta_0, \theta_1)$ 的问题。</p>
<p><strong>梯度下降（Gradient Descent)</strong> 是一个用来求函数最小值的算法，我们将使用梯度下降算法求出代价函数最小值。</p>
<p>梯度下降背后的思想是：开始时我们随机选择一个参数的组合 $(𝜃<em>0,𝜃_1,…,𝜃</em>𝑛)$，计算代价函数，然后我们寻找下一个能让代价函数值下降最多的参数组合。我们持续这么做直到到到一个局部最小值（local minimum），因为我们并没有尝试完所有的参数组合，所以不能确定我们得到的局部最小值是否便是全局最小值（global minimum），选择不同的初始参数组合，可能会找到不同的局部最小值。 </p>
<p><img src="https://photo.hushhw.cn/20190716135043.png" alt></p>
<p><img src="https://photo.hushhw.cn/20190716135116.png" alt></p>
<p>上面是一个非线性函数的代价函数，我们可以看到，选取不同的初始值 θ，可能会使得迭代的代价函数最后进入不同的极小值点。</p>
<p>梯度下降算法公式：</p>
<p><img src="https://photo.hushhw.cn/20190716135452.png" alt></p>
<p>其中，</p>
<ul>
<li>$\alpha$ 是<strong>学习率（learning rate）</strong>，它决定了我们沿着能让代价函数下降程度最大的方向向下迈出的步子有多大。$\alpha​$ 不能太大也不能太小，太小了会使得移动的速率很慢，需要很多步才能到达全局最低点。太大了可能会直接越过了最低点，甚至可能无法收敛，甚至发散。</li>
<li>:= 表示赋值（assignment）</li>
</ul>
<p>对于单变量线性回归的梯度函数而言，其代价函数 J 关于参数 θ的图像如下，只有一个极值以及最值：</p>
<p><img src="https://photo.hushhw.cn/20190716141637.png" alt></p>
<p>我们让模型再简化一下，取J(θ)=θx,其代价函数关于θ的图像如下。我们通过观察他的迭代过程，有助于理解梯度下降算法：</p>
<p><img src="https://photo.hushhw.cn/20190716141721.png" alt></p>
<p>可以看到：</p>
<ul>
<li>当 θ 大于最小值时，导数为正，那么迭代公式 $\theta := \theta - \alpha\frac{∂}{∂{\theta}}J(\theta)​$ 里，θ 减去一个正数，向左往最小值逼近；</li>
<li>当θ小于最小值时，导数为负，那么迭代公式 $\theta := \theta - \alpha\frac{∂}{∂{\theta}}J(\theta)$ 里，θ 减去一个负数，向右往最小值逼近。</li>
</ul>
<p>​          </p>
<h3 id="2-4-Gradient-Descent-For-Linear-Regression"><a href="#2-4-Gradient-Descent-For-Linear-Regression" class="headerlink" title="2.4 Gradient Descent For Linear Regression"></a>2.4 Gradient Descent For Linear Regression</h3><p>梯度下降（Gradient Descent）是很常用的算法，这一节我们将用到此算法，并将其应用于具体的拟合直线的线性回归算法里。 </p>
<p><img src="https://photo.hushhw.cn/20190716165528.png" alt></p>
<p>​          </p>
<h2 id="专业名词整理"><a href="#专业名词整理" class="headerlink" title="专业名词整理"></a>专业名词整理</h2><ul>
<li><code>hypothesis</code>：假设</li>
<li><code>parameters</code>：参数</li>
<li><code>Gradient Descent</code>：梯度下降</li>
<li><code>Univariate linear regression</code>：单变量线性回归</li>
<li><code>cost function</code>：代价函数</li>
<li><code>local minimun</code>：局部最小值</li>
<li><code>learning rate</code>：学习率</li>
<li><code>iterative algorithm</code>：迭代算法</li>
<li><code>derivative term</code>：导数项、<code>partial derivative</code>：偏导数</li>
<li><code>equation</code>：方程式</li>
<li><code>positive slope</code>：正斜率、<code>negative slope</code>：负斜率</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://www.zhouyongyi.com/andrew-ng-machine-learning-notes-2/" target="_blank" rel="noopener">驿舟小站</a></p>
<p><a href="https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes" target="_blank" rel="noopener">Coursera-ML-AndrewNg-Notes</a></p>
<p><a href="https://www.coursera.org/course/ml" target="_blank" rel="noopener">斯坦福大学 2014 机器学习</a> </p>
<p><a href="https://wei2624.github.io/MachineLearning/sv_discriminative_model/" target="_blank" rel="noopener">Discriminative Algorithm</a> </p>
</blockquote>
]]></content>
      <categories>
        <category>笔记整理</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>吴恩达《机器学习》笔记（一）——介绍</title>
    <url>/posts/ef2d7590.html</url>
    <content><![CDATA[<blockquote>
<p> 本系列学习笔记用来记录我学习吴恩达教授的《机器学习》课程，课程版本为在 Coursera 版，在 B 站、网易云课堂都可以找到相应的视频资源，配合 <a href="https://github.com/fengdu78" target="_blank" rel="noopener">@fengdu78</a> 整理的笔记「<a href="https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes" target="_blank" rel="noopener"><strong>Coursera-ML-AndrewNg-Notes</strong></a>」来学习。</p>
<p> 限于本人是机器学习的初学者，在笔记过程中难免有思考不周之处，读者请自行查阅吴恩达教授课程内容。</p>
<p>本文内容包括对「机器学习」定义的阐述，及「监督学习」和「非监督学习」的基本理解。</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="1-1-What-is-Machine-Learning"><a href="#1-1-What-is-Machine-Learning" class="headerlink" title="1.1 What is Machine Learning"></a>1.1 What is Machine Learning</h3><p>什么是机器学习？即使是在机器学习的专业人士中，也不存在一个被广泛认可的定义来准确定义机器学习。</p>
<p><strong>1. Arthur Samue 提出的定义：</strong></p>
<blockquote>
<p>“The field of study that gives computers the ability to learn without being explicitly programmed.”</p>
</blockquote>
<p>在进行特定编程的情况下，给予计算机学习能力的领域。</p>
<p><strong>2. Tom Mitchell 提出的定义：</strong></p>
<blockquote>
<p>“A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E.”</p>
</blockquote>
<p>一个好的学习问题定义如下，一个程序被认为能从经验 E 中学习，解决任务 T，达到性能度量值 P，当且仅当，有了经验 E 后，经过 P 评判，程序在处理 T 时的性能有所提升。</p>
<p>​         </p>
<h3 id="1-2-Supervised-Learning"><a href="#1-2-Supervised-Learning" class="headerlink" title="1.2 Supervised Learning"></a>1.2 Supervised Learning</h3><blockquote>
<p>In supervised learning, we are given a data set and already know what our correct output should look like, having the idea that there is a relationship between the input and the output.</p>
</blockquote>
<p>在监督学习中，我们已经得到了一个数据集，并且数据集中的每一个样本都是“正确答案”，再根据这些样本来做出预测。</p>
<p>监督学习的问题被分为<strong>“回归（regression）</strong>和<strong>“分类（classification）”</strong>两类。</p>
<ul>
<li>在回归问题中，我们尝试预测出<strong>连续的</strong>输出。</li>
<li>在分类问题中，我们尝试预测出<strong>离散的</strong>输出。</li>
</ul>
<p>在这种监督学习模式下，我们有输入模块叫<strong>特征（features）</strong>，和输出模块叫<strong>目标（target）</strong>。学习的目的是基于给定的输入和对应的标签训练模型，然后用训练好的模型对给定的新输入来预测输出。</p>
<p>为此，我们收集一个训练<strong>数据集（training set）</strong>，在这个数据集中，我们有许多成对的<strong>训练样本</strong>，每对样本包含<strong>特征向量（feature vector）</strong>作为输入（用符号 X 表示所有的特征向量）及其相应的<strong>目标（output）</strong>作为输出（用符号 Y 表示所有的目标值）。 由于每一个输入都有来自事实对应的标签，我们将这种学习称为监督学习（supervised learning），同时将训练好的模型称为<strong>假设（hypothesis）</strong>。 </p>
<p>​       </p>
<h3 id="1-3-Unsupervised-Learning"><a href="#1-3-Unsupervised-Learning" class="headerlink" title="1.3 Unsupervised Learning"></a>1.3 Unsupervised Learning</h3><blockquote>
<p>Unsupervised learning, allows us to approach problems with little or no idea what our results should look like. We can derive structure from data where we don’t necessarily know the effect of the variables.</p>
</blockquote>
<p>无监督学习中，我们对对已知的数据集不知道如何处理，未被告知每一个数据点是什么。我们可以在不知道变量的具体影响的情况下，从数据中提取出结构（structure）。</p>
<p>我们可以根据数据中的变量关系对数据进行<strong>聚类（clustering）</strong>，来提取出数据的结构。</p>
<p><img src="https://photo.hushhw.cn/20190716112626.png" alt></p>
<p>聚类应用的例子，如在谷歌新闻中，将同一主题的新闻事件聚类在一起显示。我们没有提前告知算法一些信息，算法自动地聚类，我们没有算法正确答案来回应数据集中的数据。</p>
<h2 id="专业名词整理"><a href="#专业名词整理" class="headerlink" title="专业名词整理"></a>专业名词整理</h2><ul>
<li><code>supervised learning</code>：监督学习</li>
<li><code>regresssion</code>：回归</li>
<li><code>classification</code>：分类</li>
<li><code>horizontal axis</code>：横轴、<code>vertical axis</code>：纵轴</li>
<li><code>quadratic function</code>：二次函数、<code>cubic function</code>：三次函数</li>
<li><code>discrete value</code>：离散值、<code>continuous value</code>：连续值</li>
<li><code>training set</code>：训练集、<code>data set</code>：数据集</li>
<li><code>unsupervised learning</code>：非监督学习</li>
<li><code>cluster</code>：簇、<code>clustering algorithm</code>：聚类算法</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://www.zhouyongyi.com/andrew-ng-machine-learning-notes-1/" target="_blank" rel="noopener">驿舟小站</a></p>
<p><a href="https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes" target="_blank" rel="noopener">Coursera-ML-AndrewNg-Notes</a></p>
<p><a href="https://www.coursera.org/course/ml" target="_blank" rel="noopener">斯坦福大学 2014 机器学习</a></p>
</blockquote>
]]></content>
      <categories>
        <category>笔记整理</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>《图解密码技术》学习笔记之密码(二)</title>
    <url>/posts/feaace02.html</url>
    <content><![CDATA[<blockquote>
<p>本文接『<a href="https://wiki.hushhw.cn/posts/418f8d38.html">《图解密码技术》学习笔记之密码(一)</a>』继续补充密码部分的基础知识。</p>
<p>内容概述：</p>
<ul>
<li>公钥密码</li>
<li>混合密码系统</li>
</ul>
</blockquote>
<a id="more"></a>
<h2 id="5-公钥密码"><a href="#5-公钥密码" class="headerlink" title="5. 公钥密码"></a>5. 公钥密码</h2><h3 id="5-1-密钥配送问题"><a href="#5-1-密钥配送问题" class="headerlink" title="5.1 密钥配送问题"></a>5.1 密钥配送问题</h3><p>在对称密码中，由于加密和解密的密钥是相同的，因此必须像接收者配送密钥。用于解密的密钥必须配送给接收者，这一问题称为密钥配送问题。</p>
<p>解决密钥配送问题的方法：</p>
<ul>
<li>通过事先共享密钥来解决：事先用安全的方式将密钥交给对方。</li>
<li>通过密钥分配中心来解决：有一个密钥分配中心生成通信密钥，每个人只要和密钥分配中心实现共享密钥就可以了。</li>
<li>通过 Diffie-Hellman 密钥交换来解决：发送者和接收者之间相互传递信息，利用这些信息各自生成相同的密钥。</li>
<li>通过公钥密码来解决</li>
</ul>
<h3 id="5-2-公钥密码"><a href="#5-2-公钥密码" class="headerlink" title="5.2 公钥密码"></a>5.2 公钥密码</h3><p><strong>公钥密码</strong>（public-key cryptography）（又称<strong>非对称密码</strong>）中，密钥分为加密密钥和解密密钥两种。发送者用加密密钥对消息进行加密，接收者用解密密钥对密文进行解密。两者的区别：</p>
<ul>
<li>发送者只需要加密密钥</li>
<li>接收者只需要解密密钥</li>
<li>解密密钥不可以被窃听者获取</li>
<li>加密密钥被窃听者获取也没问题</li>
</ul>
<p>解密密钥一开始就是由接收者自己保管，因此只要将加密密钥发给发送者就可以解决密钥配送问题了，而根本不需要配送解密密钥。</p>
<p><strong>公钥</strong>（public key）：加密密钥可以被任意公开，被称为公钥。</p>
<p><strong>私钥</strong>（private key）：解密密钥是绝对不能公开的，称为私钥。</p>
<p>公钥和私钥一一对应，一对公钥和私钥统称为密钥对（key pair）。由公钥进行加密的密文，必须使用与该公钥配对的私钥才能够解密。</p>
<p>公钥密码解决了密码配送问题，但我们还需要判断所得到的公钥是否正确合法，并且其处理速度只有对称密码的几百分之一。</p>
<h3 id="5-3-RSA"><a href="#5-3-RSA" class="headerlink" title="5.3 RSA"></a>5.3 RSA</h3><p><strong>RSA</strong> 是一种公钥密码算法，名字来自三位开发者 Ron Rivest、Adi Shamir 和 Leonard Adleman。RSA 可以被用于公钥密码和数字签名。</p>
<p>RSA 加密公式：$密文 = 明文^EmodN$ ，即 RSA 的密文是对代表明文的数字的 E 次方求 mod N 的结果，这里的 E（Encryption，加密） 和 N（number，数字） 的组合就是公钥。</p>
<p>RSA 解密公式：$明文 = 密文^D modN$ ，即 RSA 的明文是对代表密文的数字的 D 次方求 mod N 的结果，这里d的 D（Decryption，解密）和 N 的组合就是密钥。</p>
<p><img src="https://photo.hushhw.cn/images/wKioL1hemhCT2YyuAAB521Eadok617.png" alt></p>
<p>RSA 密码对的生成步骤即求 N、L（一个中间数字）、E 和 D 的过程，如下图：</p>
<p><img src="https://photo.hushhw.cn/images/20190113152536907.png" alt></p>
<h3 id="5-4-其他公钥密码"><a href="#5-4-其他公钥密码" class="headerlink" title="5.4 其他公钥密码"></a>5.4 其他公钥密码</h3><p><strong>ElGamal 方式</strong>：由 Taher ElGamal 设计的公钥算法。RSA 利用了质因数分解的困难度，而 ElGamal 方式则利用了 mod N 下求离散对数的困难度。其缺点是经过加密的密文长度会变成明文的两倍。</p>
<p><strong>Rabin 方式</strong>：由 M.O.Rabin 设计的公钥算法。Rabin 方式利用了 mod N 下求平方根的困难度。</p>
<p><strong>椭圆曲线密码</strong>（Elliptic Curve Cryptography，ECC）：通过将椭圆曲线上的特定点进行特殊的乘法运算来实现，它利用了乘法运算的逆运算非常困难这一特性。</p>
<p>​       </p>
<h2 id="6-混合密码系统"><a href="#6-混合密码系统" class="headerlink" title="6. 混合密码系统"></a>6. 混合密码系统</h2><p>对称密码无法解决密钥配送问题，公钥密码的处理速度远远低于对称密码并且难以抵御中间人攻击。</p>
<p><strong>混合密码系统</strong>（hybrid cryptosystem）是将对称密码和公钥密码的优势相结合的方法。一般情况下，将两种不同的方式组合的做法就称为混合（hybrid）。</p>
<p>混合密码系统的本质是将消息通过对称密码来加密，将加密消息时使用的密钥通过公钥密码来加密。</p>
<p>由于对称密码的密钥一般比消息本身要短，因此公钥密码速度慢的问题就可以忽略了。</p>
<p>混合密码系统的组成机制：</p>
<ul>
<li><p>用对称密码加密消息</p>
</li>
<li><p>通过伪随机数生成器生成对称密码加密中使用的会话密钥</p>
</li>
<li><p>用公钥密码加密会话密钥</p>
</li>
<li><p>从混合密码系统外部赋予公钥密码加密时使用的密钥</p>
</li>
</ul>
<p>混合密码系统运用了伪随机数生成器、对称密码和公钥密钥这三种密码技术，正是通过这三种密码技术的结合，才创造出了一种兼具对称密码和公钥密码优点的密码方式。</p>
<p>混合密码系统的加密过程如下：</p>
<p><img src="https://photo.hushhw.cn/images/101_22.png" alt></p>
<p>混合密码系统的解密过程如下：</p>
<p><img src="https://photo.hushhw.cn/images/101_21.png" alt></p>
<p>怎样才是高强度的混合密码系统：</p>
<ul>
<li><p>伪随机数生成器：采用算法较佳</p>
</li>
<li><p>对称密码：使用高强度</p>
</li>
<li><p>公钥密码：高强度</p>
</li>
</ul>
<p>密码长度的平衡：对称密码和公钥密码的密钥长度必须具备同等的强度。然而，考虑到长期运用的情况，公钥密码的强度应该要高于对称密码，因为对称密码的会话密钥被破译只会影响本次通信的内容，而公钥密码一旦被破译，从过去到未来的（用相同公钥加密的）所有通信内容就能够被破译了。</p>
]]></content>
      <categories>
        <category>笔记整理</category>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机 VMware 中安装 Ubuntu 操作系统</title>
    <url>/posts/6fbc30d9.html</url>
    <content><![CDATA[<blockquote>
<p>大三下学期在上的「操作系统」课程的时候就想装个虚拟机来学习一下 Linux，时到现在有空折腾了才开始做这件事情，但总算是开始做了。</p>
<p>折腾在虚拟机中安装 Ubuntu 操作系统花了我一天时间，写下这篇文章来记录这个过程，留作以后再学习排坑。</p>
</blockquote>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-04-25_15-04-07.png" alt></p>
<h2 id="1-安装前的准备和基本安装"><a href="#1-安装前的准备和基本安装" class="headerlink" title="1. 安装前的准备和基本安装"></a>1. 安装前的准备和基本安装</h2><h3 id="1-1-虚拟机-VMware-下载"><a href="#1-1-虚拟机-VMware-下载" class="headerlink" title="1.1 虚拟机 VMware 下载"></a>1.1 虚拟机 <strong>VMware</strong> 下载</h3><p>可以自行去官网下载然后找一下激活密钥，我这里存了一份找到了一个 <code>15.0.0</code> 版本可供 <i class="fa fa-download fa"></i> <a href="https://pan.baidu.com/s/1QbcYGlaX_bTLqQiYN571eQ" target="_blank" rel="noopener">百度网盘</a> 下载，提取码：<code>t7ys</code> 。</p>
<h3 id="1-2-操作系统-Ubuntu-下载"><a href="#1-2-操作系统-Ubuntu-下载" class="headerlink" title="1.2 操作系统 Ubuntu 下载"></a>1.2 操作系统 <strong>Ubuntu</strong> 下载</h3><p>可到 <a href="http://mirrors.ustc.edu.cn/" target="_blank" rel="noopener">中科大镜像源</a> 下载你需要的版本，如下图所示：</p>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-04-25_15-26-58.png" alt></p>
<p>我选择了最新的发行版本 <code>19.04</code> 的映像文件来安装，配合 VMware 15 没有出现兼容问题，之前电脑上装的 VMware 8 版本太低，安装过程中报错。</p>
<h3 id="1-3-电脑开启虚拟化技术"><a href="#1-3-电脑开启虚拟化技术" class="headerlink" title="1.3 电脑开启虚拟化技术"></a>1.3 电脑开启虚拟化技术</h3><p>各电脑厂商可能不太一样，但基本都是进入BIOS下开启虚拟化技术，可以自行 Google 操作。</p>
<h3 id="1-4-基本安装"><a href="#1-4-基本安装" class="headerlink" title="1.4 基本安装"></a>1.4 基本安装</h3><p>有了映像文件之后，只需要按照提示一步一步操作即可安装 Ubuntu，如果有什么问题可以在网上找一下别人的安装教材看看，我在 B 站看了一位大佬做了简单的安装过程视频，视频地址：<a href="https://www.bilibili.com/video/av24804060" target="_blank" rel="noopener">VMware 安装Ubuntu 18.04 LTS</a> 。</p>
<p>​         </p>
<h2 id="2-遇到的一些问题及解决方案"><a href="#2-遇到的一些问题及解决方案" class="headerlink" title="2. 遇到的一些问题及解决方案"></a>2. 遇到的一些问题及解决方案</h2><p>以下很多操作都可以用命令行来解决问题，也可以用图形界面来操作。</p>
<h3 id="2-1-显示屏幕太小解决办法"><a href="#2-1-显示屏幕太小解决办法" class="headerlink" title="2.1 显示屏幕太小解决办法"></a>2.1 显示屏幕太小解决办法</h3><p>使用 VMware 安装的 ubuntu 虚拟机的显示屏幕太小，可以通过在 VMware 里安装「VMware Tool」插件解决。 具体操作过程可以参考这篇文章 <a href="https://blog.csdn.net/dcrmg/article/details/74090307" target="_blank" rel="noopener">VMware虚拟机ubuntu显示屏幕太小解决办法</a> 。我安装是通过 VMware 15 虚拟机安装完成，所以步骤和文章中有一些不同，但是大致是一样的原理。</p>
<h3 id="2-2-设置语言环境"><a href="#2-2-设置语言环境" class="headerlink" title="2.2 设置语言环境"></a>2.2 设置语言环境</h3><p>参考文章：<a href="https://blog.csdn.net/qq_19339041/article/details/80058575" target="_blank" rel="noopener">更改系统语言为简体中文</a> </p>
<p>如果你在语言环境下载包的过程中非常慢，可以考虑先把下面的「设置服务器镜像源」先改了再说。</p>
<p>如果你发现你得 Ubuntu 似乎没有网络，那么请在 VMware 设置当前虚拟机的网络适配器，具体可以网上找一找原因。</p>
<p>安装完成后，建议保留旧的名称。在terminal中有中文，后期开发使用可能会有问题。</p>
<h3 id="2-3-设置服务器镜像源"><a href="#2-3-设置服务器镜像源" class="headerlink" title="2.3 设置服务器镜像源"></a>2.3 设置服务器镜像源</h3><p>Ubuntu 中大部分软件的安装/更新都是利用 <code>apt</code> 命令，从 Ubuntu 的服务器直接安装的，Ubuntu 官方服务器在国外，为了提高软件安装更新速度，Ubuntu 提供了选择最佳服务器的功能，可以帮助我们方便的找到一个速度最快的镜像服务器。</p>
<p>旧版本中在系统设置中可以找到 <code>软件和更新</code> 这个选项，但是我在 <code>19.0.4</code> 这个版本中并没有找到，所以直接找到文件位置 <code>etc/apt/sources.list</code>，打开文件后选择下载源为 <code>其他站点</code>，之后点击 <code>选择最佳服务器</code> ，退出来时弹框点击<code>重新载入</code>。</p>
<h3 id="2-4-修改时区和更新时间"><a href="#2-4-修改时区和更新时间" class="headerlink" title="2.4 修改时区和更新时间"></a>2.4 修改时区和更新时间</h3><p>参考文章：<a href="https://blog.csdn.net/zhengchaooo/article/details/79500032" target="_blank" rel="noopener">Ubuntu 修改时区和更新时间</a> </p>
<p>​            </p>
<h2 id="3-apt-终端命令"><a href="#3-apt-终端命令" class="headerlink" title="3. apt 终端命令"></a>3. apt 终端命令</h2><p><code>apt</code> 是 <code>Adavanced Packaging Tool</code>，是 Ubuntu 下的安装包管理工具。大部分软件的安装/更新都是利用 <code>apt</code> 命令，直接在终端中输入 <code>apt</code> 即可以查阅命令的帮助信息。</p>
<p>常用命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1. 安装软件</span><br><span class="line">$ sudo apt install 软件名</span><br><span class="line"></span><br><span class="line"># 2. 卸载软件</span><br><span class="line">$ sudo apt remove 软件名</span><br><span class="line"></span><br><span class="line"># 3. 更新可用软件包列表</span><br><span class="line">$ sudo apt update</span><br><span class="line"></span><br><span class="line"># 4. 更新已安装的包</span><br><span class="line">$ sudo apt upgrade</span><br></pre></td></tr></table></figure>
<p><code>apt</code> 安装命令并不需要记忆，如果在终端中输入的软件没有安装，系统会提示 apt 命令的使用格式。</p>
<p>例如 python 双版本的安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo apt install ipython</span><br><span class="line">$ sudo apt install ipython3</span><br><span class="line">$ sudo apt install python-pip</span><br><span class="line">$ sudo apt install python3-pip</span><br></pre></td></tr></table></figure>
<p>​            </p>
<h2 id="4-deb-安装格式"><a href="#4-deb-安装格式" class="headerlink" title="4. deb 安装格式"></a>4. deb 安装格式</h2><p><code>deb</code> 是 Debian Linux 的安装格式，在 ubuntu 中同样可以使用。要安装 deb 安装包，需要使用 <code>dpkg</code> 这个终端命令，格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i &lt;package.deb&gt;</span><br></pre></td></tr></table></figure>
<h3 id="4-1-谷歌浏览器"><a href="#4-1-谷歌浏览器" class="headerlink" title="4.1 谷歌浏览器"></a>4.1 谷歌浏览器</h3><p>从 chrome 官网下载到 .deb 安装文件，拷贝到 ubuntu 系统中，然后到该文件夹下执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo apt install libappindicator1 libindicator7</span><br><span class="line">$ sudo dpkg -i google-chrome-stable_current_amd64.deb</span><br><span class="line">$ sudo apt -f install</span><br></pre></td></tr></table></figure>
<h3 id="4-2-搜狗输入法"><a href="#4-2-搜狗输入法" class="headerlink" title="4.2 搜狗输入法"></a>4.2 搜狗输入法</h3><p><code>fcitx</code> 被称为小企鹅输入法，是一个以 GPL 方式发布的输入法平台，可以通过安装引擎支持多种输入法，首先安装 Fcitx 输入法框架：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo apt install fcitx</span><br></pre></td></tr></table></figure>
<p>之后到搜狗输入法官网下载 Linux 版本，拷贝到 ubuntu 系统中，在对应文件夹下执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo dpkg -i sogoupinyin_2.2.0.0108_amd64.deb</span><br><span class="line">$ sudo apt -f install</span><br></pre></td></tr></table></figure>
<p>其实前面忘了装 fcitx 这里命令行会提示里让你修复安装的。</p>
<p>安装过后，进入设置语言安装界面，设置键盘输入系统为 fcitx，重启虚拟机后右上角就有了键盘标志。更多细节可以参考：<a href="https://blog.csdn.net/lupengCSDN/article/details/80279177" target="_blank" rel="noopener">Ubuntu18.04下安装搜狗输入法</a> 。</p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>环境配置</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>《图解密码技术》学习笔记之密码(一)</title>
    <url>/posts/418f8d38.html</url>
    <content><![CDATA[<blockquote>
<p>本文整理「密码」这一部分的基础知识点。</p>
<p>内容概述：</p>
<ul>
<li>经典密码</li>
<li>对称密码</li>
<li>分组密码</li>
</ul>
</blockquote>
<a id="more"></a>
<h2 id="1-环游密码世界-概述"><a href="#1-环游密码世界-概述" class="headerlink" title="1. 环游密码世界(概述)"></a>1. 环游密码世界(概述)</h2><h3 id="1-1-基础概念"><a href="#1-1-基础概念" class="headerlink" title="1.1 基础概念"></a>1.1 基础概念</h3><ul>
<li>发送者、接收者和窃听者</li>
<li>加密与解密</li>
<li>破译</li>
<li>密码算法、密钥</li>
</ul>
<h3 id="1-2-密码学家的工具箱"><a href="#1-2-密码学家的工具箱" class="headerlink" title="1.2 密码学家的工具箱"></a>1.2 密码学家的工具箱</h3><ul>
<li>对称密码： 在加密和解密，使用同一个密钥的方式。</li>
<li>公钥密码/非对称密码: 是指在加密和解密时使用不同密钥的方式。</li>
<li>单向散列函数/哈希值/密码校验/消息摘要：所保证的并不是机密性，而是完整性。即可以检测出数据是否被篡改过。</li>
<li>消息认证码：不仅能够保证完整性，而且能够提供认证机制。即不但能确认消息是否被篡改过，而且能够确认消息是否来自所期待的通信对象。</li>
<li>数字签名：是一种能够保证完整性，提供认证，并防止否认的密码技术。</li>
<li>伪随机生成器：是一种能够模拟生产随机数列的算法，承担着密钥生成的重要职责。如果生成随机数的算法不好，窃听者就能推测出密钥，从而带来通信机密性下降的风险。</li>
</ul>
<p><img src="https://photo.hushhw.cn/images/cryptopraphy1.png" alt></p>
<h3 id="1-3-密码与信息安全常识"><a href="#1-3-密码与信息安全常识" class="headerlink" title="1.3 密码与信息安全常识"></a>1.3 密码与信息安全常识</h3><ul>
<li>不要使用保密的密码算法</li>
<li>使用低强度的密码比不进行任何加密更危险</li>
<li>任何密码总有一天都会被破解</li>
<li>密码只是信息安全的一部分</li>
</ul>
<p>​              </p>
<h2 id="2-经典密码"><a href="#2-经典密码" class="headerlink" title="2. 经典密码"></a>2. 经典密码</h2><h3 id="2-1-凯撒密码（Caesar-cipher）"><a href="#2-1-凯撒密码（Caesar-cipher）" class="headerlink" title="2.1 凯撒密码（Caesar cipher）"></a>2.1 凯撒密码（Caesar cipher）</h3><p><strong>凯撒密码</strong>是通过将明文中所使用的字母表按照一定的字数「平移」来进行加密。例如要保密的信息为 <code>yoshiko</code> ，按照平移 3 格加密后的数据为 <code>BRVKLNR</code> 。</p>
<p>解密的过程只需要反向平移相应位数就可以解密了。</p>
<p>破解凯撒密码的方法是<strong>暴力破解</strong>（穷举搜索），把所有可能的密钥全部尝试一遍。</p>
<h3 id="2-2-简单替换密码"><a href="#2-2-简单替换密码" class="headerlink" title="2.2 简单替换密码"></a>2.2 简单替换密码</h3><p><strong>简单替换密码</strong>是将明文中所使用的字母表替换为另一套字母表的密码。</p>
<p>解密的过程就是使用加密时所使用的替换表进行反向替换，所以发送者和接收者必须事先同时拥有该替换表，而这份替换表也就相当于简单替换密码的密钥。</p>
<p>破解简单替换密码很难通过暴力破解来破译，因为简单替换密码的<strong>密钥空间</strong>足够大，以 26 位字母为例，计算出来的密钥总数为 26 的阶乘，数据相当庞大，所以要采用<strong>频率分析</strong>的密码破译方法来破解简单替换密码。所谓了频率分析就是统计替换表中每个字母出现的频率，然后与英文中使用最高频的一些字母对应分析。</p>
<h3 id="2-3-Enigma密码机"><a href="#2-3-Enigma密码机" class="headerlink" title="2.3 Enigma密码机"></a>2.3 Enigma密码机</h3><p>Enigma 是一种有键盘、齿轮、电池和灯泡所组成的机器，通过这台机器可以完成加密和解密两种操作。</p>
<p>​              </p>
<h2 id="3-对称密码"><a href="#3-对称密码" class="headerlink" title="3. 对称密码"></a>3. 对称密码</h2><p>对称密码又称共享密钥密码，用相同的密钥进行加密和解密。</p>
<h3 id="3-1-一次性密码本"><a href="#3-1-一次性密码本" class="headerlink" title="3.1 一次性密码本"></a>3.1 一次性密码本</h3><p><strong>一次性密码本（One-time pad），又称维纳密码（Vernam cipher）</strong>：将明文与一串随机的比特序列进行异或（XOR）运算，解密就是加密的反向运算，即用密文和密钥进行异或运算得到明文。</p>
<p>一次性密码本是无条件安全的，在理论上是无法破译的，因为就算我们用暴力方式侥幸得到了密钥，我们也无法确定异或出来的结果是否就是正确的明文。</p>
<p>一次性密码本之所以没有被使用是因为发送方必须给接收方发送密文和密钥，既然有一种方法可以将密钥安全的发送出去，那岂不是也可以用同样的方法来安全的发送明文？</p>
<h3 id="3-2-DES"><a href="#3-2-DES" class="headerlink" title="3.2 DES"></a>3.2 DES</h3><p>DES (Data Encryption Standard) 即数据加密标准，是 1977 年美国联邦信息处理标准中所采用的一种对称密码。一直以来被美国以及其他国家的政府和银行等广泛使用，但是随着计算机的进步，现在的DES已经能够被暴力破解，强度大不如前了，现在我们<strong>不应该再使用 DES 了</strong>。</p>
<p>DES 是一种将 64 比特的明文加密成 64 比特的密文的对称密码算法，他的密钥长度是 56 比特（每隔 7 比特会设置一个用于错误检查的比特）。DES 以 64 比特的明文（比特序列）为一个单位进行加密，这个 64 比特的单位称为分组，<strong>DES 是分组密码的一种</strong>。DES 每次只能加密 64 比特的数据，如果要加密的明文比较长，就需要对 DES 加密进行迭代（反复），而迭代的具体方式称为<a href="#4-分组密码的模式">模式</a>（mode）。</p>
<p>DES 的基本结构是由 Horst Feistel 设计的，因此也成为 Feistel 网络、Feistel 结构或者 Feistel 密码。在Feistel 网络中，加密的各个步骤称为轮（round），整个加密过程就是进行若干次轮的循环。<strong>DES 是一种 16 轮循环的 Feistel 网络</strong>。</p>
<p>Feistel 网络一轮的具体计算步骤：</p>
<ul>
<li>将输入的数据等分为左右两部分。</li>
<li>将输入的右侧直接发送到输出的右侧。</li>
<li>将输入的右侧发送到轮函数。</li>
<li>轮函数根据右侧数据和子密钥，计算出一串看上去是随机的比特序列。</li>
<li>将上一步得到的比特序列与左侧数据进行 XOR 运算，并将结果作为加密后的左侧。</li>
</ul>
<p>这样一来「右侧」根本没有被加密，因此我们需要用不同的子密钥的一轮的处理重复若干次，并在每两轮处理之间将左侧和右侧的数据对调。</p>
<p><img src="https://photo.hushhw.cn/images/32421175-4b12736e-c25b-11e7-8c60-85242d72b9b3.png" alt></p>
<p>Feistel 网络的性质：</p>
<ul>
<li>Feistel 网络的论述可以任意增加。</li>
<li>加密时无论使用任何函数作为轮函数都可以正确解密。</li>
<li>加密和解密可以用完全相同的结构来实现。</li>
</ul>
<p>综上所述，无论是任何轮数、任何轮函数，Feistel 网络都可以用相同的结构实现加密和解密，且加密的结果必定能够正确解密。</p>
<h3 id="3-3-三重-DES"><a href="#3-3-三重-DES" class="headerlink" title="3.3 三重 DES"></a>3.3 三重 DES</h3><p>现在 DES 已经可以在现实的时间内被暴力破解，<strong>三重 DES</strong>（triple-DES）出于这个目的被开发出来的，但是处理速度不高，而且在安全性方面也逐渐显现出一些问题，也不推荐使用。</p>
<p>三重 DES 的加密机制如图：</p>
<p><img src="https://photo.hushhw.cn/images/wKiom1hStybR6nRgAABzM1_8bWA892.png" alt></p>
<p>明文经过三次 DES 处理才能变成最后的密文，由于 DES 密钥的长度实质上是 56 比特，因此三重 DES 的密钥长度就是 56*3=168 比特。</p>
<p>三重 DES 并不是进行三次加密，而是「加密—<strong>解密</strong>—加密」的过程，当三重 DES 中所有的密钥都是相同时，三重 DES 也就等同于普通的 DES 了。这是因为在前两步加密—解密之后，得到的就是最初的明文。因此，以前用 DES 加密的密文，就可以通过这种方式用三重 DES 来进行解密。也就是说，<strong>三重 DES 对 DES 具备向下兼容性</strong>。</p>
<p>三重 DES 的解密过程和加密正好相反，是以密钥 3、密钥 2、密钥 1 的顺序执行解密—加密—解密的操作：</p>
<p><img src="https://photo.hushhw.cn/images/wKioL1hSupqweE1JAACDK9OtHAc865.png" alt></p>
<h3 id="3-4-AES（Rijndael）"><a href="#3-4-AES（Rijndael）" class="headerlink" title="3.4 AES（Rijndael）"></a>3.4 AES（Rijndael）</h3><p>AES（Advanced Encryption Standard）是取代其前任标准（DES）而称为新标准的一种对称密码算法。在 2000 年从众多候选算法中选出了一种名为 <strong>Rijndael</strong> 的对称密码算法，并将其确定为 AES。Rijndael 是由比利时密码学家 Joan Daemen 和 Vincent Rijmen 设计的分组密码算法。</p>
<p>Rijndael 和 AES 并不是一点区别都没有，Rijndael 的分组长度和密钥长度可以分别以 32 比特为单位在 128 比特到 256 比特的范围内进行选择。不过在 AES 的规格中，分组长度固定为 128 比特，密钥长度只有 128、192 和 256 比特三种。</p>
<p>Rijndael 并不像 DES 使用 Feistel 网络作为基本结构，而是使用了 <strong>SPN结构</strong>。和 DES 一样的是 Rijndael 算法也是由多个轮构成的，其中每一轮分为 SubBytes、ShiftRows、MixColumns 和 AddRoundKey 共 4 个步骤。</p>
<p>Rijndael 的输入分组为 128 比特，也就是 16 字节，一次进行四个步骤的操作：</p>
<ul>
<li><strong>SubBytes</strong>：逐个字节地对 16 字节的输入数据进行处理，通过一个非线性的替换函数，用查找表的方式把每个字节替换成对应的字节。</li>
<li><strong>ShiftRows</strong>：将以 4 字节为单位的行按照一定的规则向左平移，且每一行平移的字节数是不同的。</li>
<li><strong>MixColumns</strong>：对一个 4 字节的值进行比特运算，将其变为另外一个 4 字节值。</li>
<li><strong>AddRoundKey</strong>：将 MixColumns 的输出与轮密钥进行 XOR。</li>
</ul>
<p>实际上，在 Rijndael 中需要重复进行 10-14 轮计算。</p>
<p><img src="https://photo.hushhw.cn/images/wKiom1hUEnfhQmtBAAGbstlZhT8469.png" alt></p>
<p>通过上面的结构我们可以发现输入的所有比特在议论中都会被加密。和每一轮都只加密一半输入的比特的 Feistel 网络相比，这种方式的优势在于加密所需要的轮数更少。此外，这种方式还有一个优势，即每轮步骤中可以分别以字节、行和列为单位进行并行计算。</p>
<p>下图为解密的过程，除了 AddRoundKey 是一样的，其余三个步骤都是逆运算。</p>
<p><img src="https://photo.hushhw.cn/images/wKioL1hUEqjAOdloAAGfTs-rFkY687.png" alt></p>
<h3 id="3-5-该选择哪种对称密码"><a href="#3-5-该选择哪种对称密码" class="headerlink" title="3.5 该选择哪种对称密码"></a>3.5 该选择哪种对称密码</h3><p>今后最好不要将 DES 用于新的较高的安全用途，因为随着计算机技术的进步，现在用暴力破解法已经能够在现实的时间内完成对 DES的 破译。但是，在某些情况下也需要保持与旧版本软件的兼容性，出于兼容性的因素三重 DES 在今后还会使用一段时间，但会逐步被 AES 所取代。今后大家应该使用的算法是 AES（Rijndael），因为它安全、快速，而且能够在各种平台上工作。</p>
<p>​           </p>
<h2 id="4-分组密码的模式"><a href="#4-分组密码的模式" class="headerlink" title="4. 分组密码的模式"></a>4. 分组密码的模式</h2><p>前面介绍的 DES 和 AES 都属于分组密码，分组密码算法只能加密固定长度的分组，但是我们需要加密的明文长度可能会超过分组密码的分组长度，这时就需要对分组密码算法进行迭代，以便将一段很长的明文全部加密。而迭代的方法就称为分组密码的<strong>模式</strong>。</p>
<ul>
<li><p>分组密码的主要模式有：</p>
</li>
<li><p>ECB 模式：Electronic CodeBook mode（电子密码本模式）</p>
</li>
<li>CBC 模式：Cipher Block Chaining mode（密码分组链接模式）</li>
<li>CFB 模式：Cipher FeedBack mode（密码反馈模式）</li>
<li>OFB 模式：Output FeedBack mode（输出反馈模式）</li>
<li>CTR 模式：CounTeR mode（计数器模式）</li>
</ul>
<h3 id="4-1-分组密码与流密码"><a href="#4-1-分组密码与流密码" class="headerlink" title="4.1 分组密码与流密码"></a>4.1 分组密码与流密码</h3><p>密码算法可以分为分组密码和流密码两种。</p>
<p><strong>分组密码</strong>（block cipher）是每次只能处理特定长度的一块数据的一类密码算法，这里的「一块」就称为<strong>分组</strong>（block）。此外，一个分组的比特数就称为<strong>分组长度</strong>（block length）。例如 DES 和 3DES 分组长度都是 64 比特，AES 的分组长度为 128 比特。</p>
<p><strong>流密码</strong>（stream cipher）是对数据流进行连续处理的一类密码算法。流密码中一般以 1 比特、8 比特或 32 比特等为单位进行加密和解密。</p>
<p>分组密码处理完一个分组就结束了，因此不需要通过内部状态来记录加密的进度；相对地，流密码是对一串数据流进行连续处理，因此需要保持内部状态。前面提到的一次性密码本属于流密码，而 DES、3DES、AES（Rijndael）等大多数对称密码算法都属于分组密码。</p>
<h3 id="4-2-明文分组与密文分组"><a href="#4-2-明文分组与密文分组" class="headerlink" title="4.2 明文分组与密文分组"></a>4.2 明文分组与密文分组</h3><p><strong>明文分组</strong>是指分组密码算法中作为加密对象的明文。明文分组的长度与分组密码算法的分组长度是相等的。</p>
<p><strong>密文分组</strong>是指使用分组密码算法将明文分组加密之后所生成的密文。</p>
<h3 id="4-3-ECB-模式"><a href="#4-3-ECB-模式" class="headerlink" title="4.3 ECB 模式"></a>4.3 ECB 模式</h3><p><strong>ECB 模式</strong>的全称是 Electronic CodeBook 模式。在 ECB 模式中，将明文分组加密之后的结果将直接成为密文分组。</p>
<p><img src="https://photo.hushhw.cn/images/wKiom1hWoxLzFmWBAAE0Ephoto09FU260.png" alt></p>
<p><img src="https://photo.hushhw.cn/images/wKiom1hWoxKAoMorAAGBgBrThDY944.png" alt></p>
<p>使用 ECB 模式加密时，相同的分组会被转换为相同的密文分组，也就是说，我们可以将其理解为是一个巨大的「明文分组-密文分组」的对应表，因此ECB模式也称为<strong>电子密码本模式</strong>。</p>
<p>ECB 模式是所有模式中最简单的一种，其明文分组和密文分组是一一对应的关系，因此，如果明文中存在多个相同的明文分组，则这些明文分组最终都会被转换为相同的密文分组。这样一来，只要观察一下密文，就可以知道明文中存在怎样的重复组合，并可以以此为线索来破译密码，因此 ECB 模式存在一定的风险。</p>
<p>由于 ECB 模式中每个明文分组都各自独立地进行加密和解密，攻击者只需要改变密文分组的顺序，就能操控明文。由于密文分组的顺序被改变了，因此响应的明文分组的顺序也会被改变。也就是说，<strong>攻击者无需破译密码就能够操作明文</strong>。</p>
<h3 id="4-4-CBC-模式"><a href="#4-4-CBC-模式" class="headerlink" title="4.4 CBC 模式"></a>4.4 CBC 模式</h3><p><strong>CBC 模式</strong>的全称是 Cipher Block Chaining 模式（密文分组链接模式）。在 CBC 模式中，首先将明文分组与前一个密文分组进行 XOR 运算，然后再进行加密。</p>
<p><img src="https://photo.hushhw.cn/images/wKioL1hWtIrS8N80AAFwPPExW0E664.png" alt></p>
<p><strong>初始化向量 IV</strong> 为事先准备的一个长度为一个分组的比特序列，用来代替不存在的「前一个密文分组」。每次加密都会随机产生一个不同的比特序列来作为初始化向量。</p>
<p>对比 CBC 和ECB 模式发现，ECB 模式只进行了加密，而 CBC 模式则在加密之前进行了一次 XOR。因此，即便明文分组 1 和明文分组 2 的值相等，密文分组 1 和 2 也不一定相等，这样 CBC 模式就解决了 ECB 模式存在的缺陷了。</p>
<p>在 CBC 模式加密过程中，我们无法单独对一个中间的明文分组进行加密。例如，如果要生成密文分组 3 ，就至少需要凑齐明文分组 1、2、3 才行。</p>
<p>在 CBC 模式解密过程中，如果某一个密文分组因硬盘故障等原因损坏了，在这种情况下，只要密文分组的长度没有发生变化，则解密时最多只会有 2 个分组收到数据损坏影响；如果是密文分组中有一些比特因通信错误导致没有收到某些比特等原因缺失，哪怕只是缺失 1 比特，导致了密文分组的长度发生变化，缺失比特的位置之后的密文分组也就全部无法解密了。</p>
<p>通过修改密文来操纵解密后的明文，攻击者可以对初始化向量中的任意比特进行反转，则明文分组中的相应比特也会反转；攻击者如果对密文分组进行同样的攻击就非常困难，如修改了密文分组 1 中的某个比特，则明文分组 2 相应比特会反转，而这 1 比特的变化会对解密后的明文分组 1 中的多个比特造成影响，也就是说，只让明文分组 1 中特定比特发生变化是很困难的。</p>
<h3 id="4-5-CFB-模式"><a href="#4-5-CFB-模式" class="headerlink" title="4.5 CFB 模式"></a>4.5 CFB 模式</h3><p><strong>CFB 模式</strong>的全称是 Cipher FeedBack 模式（密文反馈模式）。在 CFB 模式中，前一个密文分组会被送回到密码算法的输入端。所谓反馈，这里指的是返回输入端的意思。</p>
<p><img src="https://photo.hushhw.cn/images/wKiom1hX40zh5Y4OAADND_4IQ9c584.png" alt></p>
<p><img src="https://photo.hushhw.cn/images/wKioL1hX403CntLOAAD4l1Gk2iw770.png" alt></p>
<p>在 ECB 和 CBC 模式中，明文分组都是通过密码算法进行加密的，然而，在 CFB 模式中，明文分组并没有通过密码来进行直接加密。</p>
<p><img src="https://photo.hushhw.cn/images/wKioL1hX5YmAzmH1AACUL8pDza0478.png" alt></p>
<p>CFB 模式与一次性密码本（流密码）非常相似，一次性密码本是通过将明文与随机比特序列进行 XOR 运算来生成密文，而 CFB 模式则通过将明文分组与密码算法的输出进行 XOR 运算来生成密文分组。在 CFB 模式中，密码算法的输出相当于一次性密码本中的随机比特序列。由于密码算法的输出是通过计算得到的，并不是真正的随机数，因此 CFB 模式并不具备理论上不可破译的性质。</p>
<p>在 CFB模式中，明文数据可以被逐比特加密，因此我们可以将 CFB 模式看作是一种使用分组密码来实现流密码的方式。</p>
<p>对 CFB 模式可以实施<strong>重放攻击</strong>。</p>
<h3 id="4-6-OFB-模式"><a href="#4-6-OFB-模式" class="headerlink" title="4.6 OFB 模式"></a>4.6 OFB 模式</h3><p><strong>OFB 模式</strong>的全称是 Output-Feedback 模式（输出反馈模式）。在 OFB 模式中，密码算法的输出会反馈到密码算法的输入中。</p>
<p><img src="https://photo.hushhw.cn/images/wKioL1hX5pjBv-FQAAEV8EaziXw327.png" alt></p>
<p>OFB 模式和 CFB 模式的区别仅仅在于密码算法的输入。CFB 模式中密码算法的输入是前一个密文分组，也就是将密文分组反馈到密码算法中，相反地，在 OFB 模式中密码算法的输入则是密码算法的前一个输出，也就是将输出反馈到密码算法中。</p>
<p>由于 CFB 模式中要对密文分组进行反馈，因此必须从第一个明文分组开始按顺序进行加密，相反地，在 OFB 模式中，XOR 所需要的比特序列（密钥流）可以事先通过密码算法生成，和明文分组无关，只要提前准备好所需的密钥流，则在实际从明文生成密文的过程中，就完全不需要动用密码算法了，只要将明文与密钥流进行 XOR 即可。生成密钥流的操作和进行 XOR 运算的操作是可以并行的，可以快速完成加密。</p>
<h3 id="4-7-CTR-模式"><a href="#4-7-CTR-模式" class="headerlink" title="4.7 CTR 模式"></a>4.7 CTR 模式</h3><p><strong>CTR 模式</strong>全称是 CounTeR 模式（计数器模式）。CTR 模式是一种通将逐次累加的计数器进行加密来生成密钥流的流密码。</p>
<p>CTR 模式中，每个分组对应一个逐次累加的计数器，并通过对计数器进行加密来生成密钥流。也就是说，最终的密文是通过将计数器加密得到的比特序列，与明文分组进行 XOR 而得到的。</p>
<p><img src="https://photo.hushhw.cn/images/wKiom1hX53Hwe-G8AADtc_bAjrE686.png" alt></p>
<p><img src="https://photo.hushhw.cn/images/wKioL1hX53GzfsX1AAEeB2NJuuk558.png" alt></p>
<p>CTR 模式和 OFB 模式一样，都属于流密码。加密和解密使用了完全相同的结构，因此在程序实现上比较容易。CTR 模式中可以任意顺序对分组进行加密和解密，因此在加密和解密时需要用到的「计数器」的值可以直接计算出来，这一性质是 OFB 模式所不具备的。能够以任意顺序处理分组，就意味着能够实现并行计算，在支持并行计算的系统中，CTR 模式的速度是非常快的。</p>
<h3 id="4-8-该选者哪种模式"><a href="#4-8-该选者哪种模式" class="headerlink" title="4.8 该选者哪种模式"></a>4.8 该选者哪种模式</h3><p><img src="https://photo.hushhw.cn/images/wKioL1hX58zS9WOIAAHYrp0dqCI726.png" alt></p>
<p><img src="https://photo.hushhw.cn/images/wKiom1hX582S9fKIAAIT3re_2vo030.png" alt></p>
<p>​                </p>
]]></content>
      <categories>
        <category>笔记整理</category>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>《图解密码技术》学习笔记目录</title>
    <url>/posts/83650eb4.html</url>
    <content><![CDATA[<blockquote>
<p>入门学习「密码学」，在图书馆找了一圈，锁定了这本《图解密码技术》，非常适合入门来捋一遍密码技术中的各种名词，大体上有个概念。</p>
<p>本文用于学习过程中梳理脉络，整理后面相关学习笔记链接。</p>
</blockquote>
<p>『<a href="https://wiki.hushhw.cn/posts/418f8d38.html">《图解密码技术》学习笔记之密码</a>』</p>
<h2 id="脉络"><a href="#脉络" class="headerlink" title="脉络"></a>脉络</h2><ul>
<li>密码<ul>
<li>经典密码</li>
<li>对称密码</li>
<li>分组密码</li>
<li>公钥密码</li>
<li>混合密码系统</li>
</ul>
</li>
<li>认证<ul>
<li>单向散列函数</li>
<li>消息认证码</li>
<li>数字签名</li>
<li>证书</li>
</ul>
</li>
<li>密钥、随机数与应用技术<ul>
<li>密钥</li>
<li>随机数</li>
<li>PGP</li>
<li>SSL/TLS</li>
<li>密码技术与现实社会</li>
</ul>
</li>
</ul>
<blockquote>
<p>内容整理自：</p>
<p>[日]结城浩(著)、周自恒(译)<strong>《图解密码技术》</strong>(第三版)</p>
</blockquote>
]]></content>
      <categories>
        <category>笔记整理</category>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Three.js 入坑笔记</title>
    <url>/posts/ae8c05d6.html</url>
    <content><![CDATA[<blockquote>
<p>关于一些函数的参数用一次忘一次，参考系这些东西每次都到用的时候想半天，所以还是写一篇笔记来记录，方便查阅，不至于每次都去 Google 浪费时间。</p>
</blockquote>
<h2 id="1-坐标系"><a href="#1-坐标系" class="headerlink" title="1. 坐标系"></a>1. 坐标系</h2><p><code>three.js</code> 中使用的是右手坐标系，X 轴水平向右，Y 轴垂直向上，Z 轴的方向就是屏幕由里往外的方向：</p>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-04-03_15-37-08.png" alt></p>
<h2 id="2-照相机"><a href="#2-照相机" class="headerlink" title="2. 照相机"></a>2. 照相机</h2><h3 id="2-1-什么是照相机？"><a href="#2-1-什么是照相机？" class="headerlink" title="2.1 什么是照相机？"></a>2.1 什么是照相机？</h3><p>我们使用的 <code>Three.js</code> 创建的场景是三维的，而通常情况下显示器是二维的，那么三维的场景怎么在二维的显示器上显示呢？照相机就是一个抽象，它定义了三维空间到二维屏幕投影的方式，用「照相机」这样一个类比，可以使我们直观地理解这一投影方式。</p>
<p>而针对<code>投影方式</code>的不同，照相机又分为<code>正交投影照相机</code>与<code>透视投影照相机</code>。我们需要为自己的程序选择合适的照相机。</p>
<h3 id="2-2-正交投影和透视投影"><a href="#2-2-正交投影和透视投影" class="headerlink" title="2.2 正交投影和透视投影"></a>2.2 正交投影和透视投影</h3><p>举个简单的例子来说明正交投影与透视投影照相机的区别。使用<code>透视投影照相</code>机获得的结果是<code>类似人眼在真实世界中看到的有“近大远小”</code>的效果（如下图中的 (a)）；而使用<code>正交投影照相机</code>获得的结果就像我们在数学几何学课上老师教我们画的效果，对于<code>三维空间内平行的线</code>，投影到<code>二维空间中也一定是平行的</code>（如下图中的 (b)）。</p>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-04-03_15-23-54.png" alt="image"></p>
<p>一般说来，对于<code>制图、建模软</code>通常使<code>正交投影</code>，这样不会因为投影而改变物体比例；而<code>对于其他大多数应用</code>，通常使用<code>透视投影</code>，因为这更接近人眼的观察效果。当然，照相机的选择并没有对错之分，你可以更具应用的特性，选择一个效果更佳的照相机。</p>
<h3 id="2-3-正交投影照相机"><a href="#2-3-正交投影照相机" class="headerlink" title="2.3 正交投影照相机"></a>2.3 正交投影照相机</h3><h4 id="2-3-1-参数介绍"><a href="#2-3-1-参数介绍" class="headerlink" title="2.3.1 参数介绍"></a>2.3.1 参数介绍</h4><blockquote>
<p>正交投影照相机(<code>Orthographic Camera</code>)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">THREE.OrthographicCamera(left, right, top, bottom, near, far)</span><br></pre></td></tr></table></figure>
<p>这六个参数分别代表正交投影照相机拍摄到的空间的六个面的位置，这六个面围成一个长方体，我们称其<code>视景体(Frustum)</code>。只有在视景体内部（下图中的灰色部分）的物体才可能显示在屏幕上，而视景体外的物体会在显示之前被裁减掉。</p>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-04-03_15-25-27.png" alt="image"></p>
<p>为了保持照相机的横竖比例，需要保证<code>(right - left)与(top - bottom)</code>的比例与<code>Canvas宽度与高度的比例(800/600)</code>一致。</p>
<p><code>near与far</code>都是指到照相机位置在深度平面的位置，而照相机不应该拍摄到其后方的物体，因此这两个值应该均为<code>正值</code>。为了保证场景中的物体不会因为太近或太远而被照相机忽略，一般<code>near的值设置得较小</code>，<code>far的值设置得较大</code>，具体值视场景中物体的位置等决定。</p>
<h4 id="2-3-2-示例代码"><a href="#2-3-2-示例代码" class="headerlink" title="2.3.2 示例代码"></a>2.3.2 示例代码</h4><p>下面我们通过一个具体的例子来了解正交投影照相机的设置</p>
<p><strong>基本设置</strong></p>
<p>设置照相机：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> camera = <span class="keyword">new</span> THREE.OrthographicCamera(<span class="number">-2</span>, <span class="number">2</span>, <span class="number">1.5</span>, <span class="number">-1.5</span>, <span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">camera.poaition.set(<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line">scene.add(camera);</span><br></pre></td></tr></table></figure>
<p>在原点处创建一个边长为1的正方体，为了和透视效果做对比，这里我们使用<code>wireframe</code>而不是实心的材质，以便看到正方体后方的边：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cube = <span class="keyword">new</span> THREE.Mesh(<span class="keyword">new</span> THREE.CubeGeometry(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), </span><br><span class="line">    <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123;</span><br><span class="line">        color: <span class="number">0xff0000</span>,</span><br><span class="line">        wireframe: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">);</span><br><span class="line">scene.add(cube);</span><br></pre></td></tr></table></figure>
<ul>
<li>效果图：</li>
</ul>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-04-03_15-29-55.png" alt></p>
<p>我们看到正交投影的结果是一个正方形，后面的边与前面完全重合了，这也就是正交投影与透视投影的区别所在。</p>
<p><strong>长宽比例</strong></p>
<p>这里，我们的Canvas宽度是 800px，高度是 600px，照相机水平方向距离 4，垂直方向距离 3，因此长宽比例保持不变。为了试验长宽比例变化时的效果，我们将照相机水平方向的距离减小为 2 (right-left = 2)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var camera = new THREE.OrthographicCamera(-1, 1, 1.5, -1.5, 1, 10);</span><br></pre></td></tr></table></figure>
<p>效果图(此时水平方向的距离就被拉长了)：</p>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-04-03_15-31-42.png" alt></p>
<h3 id="2-4-透视投影照相机"><a href="#2-4-透视投影照相机" class="headerlink" title="2.4 透视投影照相机"></a>2.4 透视投影照相机</h3><h4 id="2-4-1-参数介绍"><a href="#2-4-1-参数介绍" class="headerlink" title="2.4.1 参数介绍"></a>2.4.1 参数介绍</h4><blockquote>
<p>透视投影照相机(<code>Perspective Camera</code>)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">THREE.PerspectiveCamera(fov, aspect, near, far)</span><br></pre></td></tr></table></figure>
<p>让我们通过一张透视照相机投影的图来了解这些参数。</p>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-04-03_15-39-39.png" alt></p>
<ul>
<li><p>透视图中，灰色的部分是<code>视景体</code>，是可能被渲染的物体所在的区域。<code>fov</code>是视景体竖直方向上的<code>张角</code>（是角度制而非弧度制），如侧视图所示。</p>
</li>
<li><p><code>aspect</code>等于<code>width / height</code>，是照相机水平方向和竖直方向长度的比值，通常设为Canvas的<code>横纵比例</code>。</p>
</li>
<li><p><code>near</code>和<code>far</code>分别是照相机到视景体 最近、最远的距离，均为正值，且far应大于near。</p>
</li>
</ul>
<h4 id="2-4-2-示例代码"><a href="#2-4-2-示例代码" class="headerlink" title="2.4.2 示例代码"></a>2.4.2 示例代码</h4><p>下面我们通过一个例子来学习透视投影照相机</p>
<p><strong>基本设置</strong></p>
<p>设置透视投影照相机，这里Canvas长<code>800px</code>，宽<code>600px</code>，所以<code>aspect</code>设为<code>800 / 600</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> camera = <span class="keyword">new</span> THREE.PerspectiveCamera(<span class="number">45</span>, <span class="number">800</span> / <span class="number">600</span>, <span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">camera.position.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">scene.add(camera);</span><br></pre></td></tr></table></figure>
<p>设置一个在原点处的边长为1的正方体：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cube = <span class="keyword">new</span> THREE.Mesh(<span class="keyword">new</span> THREE.CubeGeometry(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123;</span><br><span class="line">            color: <span class="number">0xff0000</span>,</span><br><span class="line">            wireframe: <span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">);</span><br><span class="line">scene.add(cube);</span><br></pre></td></tr></table></figure>
<p>效果图：</p>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-04-03_15-41-29.png" alt></p>
<p>对比正交透视照相机下正方形的效果，透视投影可以看到<code>全部的12条边</code>，而且有<code>近大远小</code>的效果，这也就是与正交投影的区别。</p>
<p><strong>竖直张角</strong></p>
<ul>
<li>接下来，我们来看下<code>fov</code>的改变对渲染效果的影响。我们将原来的<code>45改为60</code>：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> camera = <span class="keyword">new</span> THREE.PerspectiveCamera(<span class="number">60</span>, <span class="number">800</span> / <span class="number">600</span>, <span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">camera.position.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">scene.add(camera);</span><br></pre></td></tr></table></figure>
<ul>
<li>效果图：</li>
</ul>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-04-03_15-42-39.png" alt></p>
<p>为什么正方体显得更小了呢？我们从下面的侧视图来看，虽然正方体的实际大小并未改变，但是将照相机的<code>竖直张角</code>设置得<code>更大</code>时，<code>视景体变大了</code>，因而<code>正方体</code>相对于<code>整个视景体</code>的大小就<code>变小</code>了，看起来正方形就显得变小了。</p>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-04-03_15-43-15.png" alt></p>
<p>注意，<code>改变fov</code>并<code>不会</code>引<code>起画面横竖比例</code>的变化，而<code>改变aspect</code>则<code>会</code>改变横竖比例。</p>
<h2 id="参考文档整理"><a href="#参考文档整理" class="headerlink" title="参考文档整理"></a>参考文档整理</h2><ul>
<li><p><a href="https://techbrood.com/threejs/docs/" target="_blank" rel="noopener">TechbrooD 对 Three.js 在线文档的汉化</a> </p>
</li>
<li><p><a href="http://test.domojyun.net/MEMO/3D/threejs.html" target="_blank" rel="noopener">3D 網站開發入門筆記＿Three.js 入門</a> </p>
</li>
</ul>
<blockquote>
<p>本文整理自</p>
<p>开源书籍：《Three.js 入门指南》</p>
</blockquote>
]]></content>
      <categories>
        <category>笔记整理</category>
        <category>WebGL</category>
      </categories>
      <tags>
        <tag>ThreeJS</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树遍历题型汇总</title>
    <url>/posts/4884afb4.html</url>
    <content><![CDATA[<blockquote>
<p>总结二叉树遍历相关题目，对这些基础题型总结经验。</p>
</blockquote>
<p>​       </p>
<h3 id="1020-Tree-Traversals"><a href="#1020-Tree-Traversals" class="headerlink" title="1020 Tree Traversals"></a>1020 Tree Traversals</h3><p>题目链接：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805485033603072" target="_blank" rel="noopener">1020 Tree Traversals （25 分)</a></p>
<p>给定一棵二叉树的后序遍历和中序遍历，请你输出其层序遍历的序列。这里假设键值都是互不相等的正整数。</p>
<blockquote>
<p>Sample Input:<br>7<br>2 3 1 5 7 6 4<br>1 2 3 4 5 6 7<br>Sample Output:<br>4 1 6 3 5 7 2</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> index, value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.index &lt; b.index;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; post, in;</span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt; ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i = start;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; end &amp;&amp; in[i] != post[root]) i++;</span><br><span class="line">    ans.push_back(&#123;index, post[root]&#125;);</span><br><span class="line">    pre(root - <span class="number">1</span> - end + i, start, i - <span class="number">1</span>, <span class="number">2</span> * index + <span class="number">1</span>);</span><br><span class="line">    pre(root - <span class="number">1</span>, i + <span class="number">1</span>, end, <span class="number">2</span> * index + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    post.resize(n);</span><br><span class="line">    in.resize(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;post[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;in[i]);</span><br><span class="line">    pre(n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    sort(ans.begin(), ans.end(), cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans[i].value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​              </p>
<h3 id="1138-Postorder-Traversal"><a href="#1138-Postorder-Traversal" class="headerlink" title="1138 Postorder Traversal"></a>1138 Postorder Traversal</h3><p>题目链接：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805345078067200" target="_blank" rel="noopener">1138 Postorder Traversal</a></p>
<p>给定先序和中序，求后序第一个数字</p>
<blockquote>
<p>Sample Input:<br>7<br>1 2 3 4 5 6 7<br>2 3 1 5 4 7 6<br>Sample Output:<br>3</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(i, m, n) for (int i = m; i &lt; n; i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre, in;</span><br><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt; end || flag) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i = start;</span><br><span class="line">    <span class="keyword">while</span>(in[i]!=pre[root]) i++;</span><br><span class="line">    post(root+<span class="number">1</span>, start, i - <span class="number">1</span>);</span><br><span class="line">    post(root+i-start+<span class="number">1</span>, i + <span class="number">1</span>, end);</span><br><span class="line">    <span class="comment">//printf("%d ", in[i]);</span></span><br><span class="line">    <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, in[i]);</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)&#123;</span><br><span class="line">        flag = <span class="literal">false</span>; <span class="comment">//用于判断是否已经找到第一个数字</span></span><br><span class="line">        pre.resize(n);</span><br><span class="line">        in.resize(n);</span><br><span class="line">        For(i, <span class="number">0</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;pre[i]);</span><br><span class="line">        For(i, <span class="number">0</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;in[i]);</span><br><span class="line">        post(<span class="number">0</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​                </p>
<h3 id="1119-Pre-and-Post-order-Traversals"><a href="#1119-Pre-and-Post-order-Traversals" class="headerlink" title="1119 Pre- and Post-order Traversals"></a>1119 Pre- and Post-order Traversals</h3><p>题目链接：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805353470869504" target="_blank" rel="noopener">1119 Pre- and Post-order Traversals （30 分)</a> </p>
<p>给出一棵树的结点个数 n，以及它的前序遍历和后序遍历，输出它的中序遍历，如果中序遍历不唯一就输出No，且输出其中一个中序即可，如果中序遍历唯一就输出Yes，并输出它的中序。</p>
<blockquote>
<p>Sample Input 1:<br>7<br>1 2 3 4 6 7 5<br>2 6 7 4 5 3 1<br>Sample Output 1:<br>Yes<br>2 1 6 4 7 3 5<br>Sample Input 2:<br>4<br>1 2 3 4<br>2 4 3 1<br>Sample Output 2:<br>No<br>2 1 3 4</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; in, pre, post;</span><br><span class="line"><span class="keyword">bool</span> uniq = <span class="literal">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getIn</span><span class="params">(<span class="keyword">int</span> preLeft, <span class="keyword">int</span> preRight, <span class="keyword">int</span> postLeft, <span class="keyword">int</span> postRight)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(preLeft == preRight) &#123;</span><br><span class="line">        in.push_back(pre[preLeft]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pre[preLeft] == post[postRight]) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = preLeft + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= preRight &amp;&amp; pre[i] != post[postRight<span class="number">-1</span>]) i++;</span><br><span class="line">        <span class="keyword">if</span> (i - preLeft &gt; <span class="number">1</span>)</span><br><span class="line">            getIn(preLeft + <span class="number">1</span>, i - <span class="number">1</span>, postLeft, postLeft + (i - preLeft - <span class="number">1</span>) - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            uniq = <span class="literal">false</span>;</span><br><span class="line">        in.push_back(post[postRight]);</span><br><span class="line">        getIn(i, preRight, postLeft + (i - preLeft - <span class="number">1</span>), postRight - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    pre.resize(n), post.resize(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;pre[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;post[i]);</span><br><span class="line">    getIn(<span class="number">0</span>, n<span class="number">-1</span>, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n%d"</span>, uniq == <span class="literal">true</span> ? <span class="string">"Yes"</span> : <span class="string">"No"</span>, in[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; in.size(); i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %d"</span>, in[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>OJ刷题</category>
      </categories>
      <tags>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>北邮网研院复试笔试整理——人工智能</title>
    <url>/posts/5fe5cd41.html</url>
    <content><![CDATA[<blockquote>
<p>基于《人工智能及其应用》一书，自己刷题加看书整理的，不保证正确性，仅供参考。</p>
</blockquote>
<ul>
<li><p>人工智能的研究与应用领域：</p>
<ul>
<li><p>机器学习：研究计算机如何自动获取知识和技能，实现自我完善。机器学习是使计算机具有智能的<strong>根本途径</strong>。</p>
</li>
<li><p>人工神经网络（ANN）用于模拟人脑神经系统的结构和功能。</p>
<ul>
<li>人工神经网络特点和优越性表现在：自主学习能力、高速寻找优化解的能力和联想存储功能。</li>
</ul>
</li>
<li><p>专家系统：是一个具有智能特点的计算机程序，它的智能化主要表现为能够在特定的领域内模仿人类专家思维来求解复杂问题。因此，专家系统必须包含领域专家的大量知识，拥有类似人类专家思维的推理能力，并能用这些知识来解决实际问题。</p>
<ul>
<li><p>人类专家知识通常包括书本知识和经验知识两大类。</p>
</li>
<li><p>进行专家系统的开发通常采用的方法是原型法。</p>
</li>
<li><p>在专家系统的开发过程中使用的专家系统工具一般分为专家系统的外壳和通用专家系统工具两类。</p>
</li>
<li><p>专家系统通常由<strong>人机交互界面</strong>、<strong>知识库</strong>、<strong>推理机</strong>、<strong>解释器</strong>、<strong>综合数据库</strong>、<strong>知识获取</strong>等6个部分构成。</p>
</li>
<li><p>知识库用来存放专家提供的知识。专家系统中运用得较为普遍的知识是产生式规则。</p>
</li>
<li><p>推理机针对当前问题的条件或已知信息，反复匹配知识库中的规则，获得新的结论，以得到问题求解结果。在这里，推理方式可以有<strong>正向和反向推理</strong>两种。正向推理是从前件匹配到结论，反向推理则先假设一个结论成立，看它的条件有没有得到满足。</p>
<p>由此可见，推理机就如同专家解决问题的思维方式，知识库就是通过推理机来实现其价值的。专家系统是以<strong>知识</strong>为基础，以<strong>推理</strong>为核心的系统。</p>
</li>
</ul>
</li>
<li><p>自然语言理解：语言的生成和理解是一个极为复杂的编码和解码问题。一个能理解自然语言信息的计算机系统看起来就像一个人一样需要有上下文知识以及根据这些上下文知识和信息用信息发生器进行推理的过程。理解口头的和书写语言的计算机系统所取得的某些进展，其基础就是有关表示上下文知识结构的某些人工智能思想以及根据这些知识进行推理的某些技术。</p>
</li>
<li><p>模式识别：计算机代替人类或帮助人类感知模式，是对人类感知外界功能的模拟，研究的是计算机模式识别系统，也就是使一个计算机具有模拟人类通过感官接受外界信息、识别和理解周围环境的感知能力。</p>
</li>
<li><p>机器人学等</p>
</li>
</ul>
</li>
<li><p>知识表示法：</p>
<p>常用的知识格式化表示法有：框架表示法、状态空间表示法、语义网络表示法。</p>
<ul>
<li>状态图示法：状态空间法来求解问题所进行的搜索称为状态空间搜索。<ul>
<li>状态空间可记为三元状态（S，F，G），其中 S 代表初始状态集合，F 代表操作符集合，G 代表目标状态集合。</li>
<li>构成空间状态的 4 个要素：初始状态、中间状态、目标状态和操作。</li>
</ul>
</li>
<li>问题归约法</li>
<li>谓词逻辑法</li>
<li>语义网络法：<ul>
<li>语义网络表示由四个相关部分组成，分别是词法部分、结构部分、过程部分、语义部分。</li>
<li>语义网络中共有三种继承过程，分别为值继承、“如果需要”继承、“缺省”继承。</li>
</ul>
</li>
<li>框架表示：框架通常由描述事物的各个方面的槽组成，每个槽可以拥有若干个侧面，每个侧面又可以拥有若干个值。<ul>
<li>框架表示法由马文•明斯基首创。</li>
</ul>
</li>
<li>剧本表示</li>
<li>过程表示</li>
</ul>
</li>
<li><p>根据搜索过程是否具有启发式信息，搜索可以分为盲目搜索和启发式搜索。其中，启发式搜索通常用启发函数来表示启发式信息。</p>
</li>
<li><p>按知识的作用范围分，知识可分为常识性知识和理论性知识。</p>
</li>
<li><p>知识的特征：进化性、相对性、复杂性、客观性、依附性、可重用性、共享性。</p>
</li>
<li><p>归结原理又称为消解原理，是Robinson提出的证明子句集不可满足性，从而实现了定理证明的一种理论和方法。子句集中各子句间的关系是合取关系，因此，只要有一个子句是不可满足的，则子句集就是不可满足的。另外，在前面已经指出，空子句是不可满足的，所以只要子句集中包含一个空子句，则此子句集就一定是不可满足的。</p>
</li>
<li><p><img src="https://photo.hushhw.cn/images/Snipaste_2019-03-22_09-24-45.png" alt><br><img src="https://photo.hushhw.cn/images/Snipaste_2019-03-22_09-29-12.png" alt></p>
</li>
<li><p>人工智能之父：图灵</p>
</li>
<li><p>机器人之父：英格伯格和德沃尔</p>
</li>
<li><p>第一台工业机器人诞生在 1959 年</p>
</li>
<li><p>人工智能诞生在 1956 年</p>
</li>
<li><p>思维理论认为，智能的核心是<strong>思维</strong>，人的一切智能都来自大脑的思维活动，人类的一切知识都是人类思维的产物，因而通过对思维规律与方法的研究渴望揭示智能的本质。</p>
</li>
<li><p>人工智能是计算机科学中与智能行为的自动化有关的一个分支。</p>
</li>
<li><p>我国学者吴文俊院士在人工智能的<strong>机器证明</strong>领域做出了贡献。</p>
</li>
<li><p>人工智能语言：Prolog</p>
</li>
<li><p>人工智能各学派：</p>
<ul>
<li>符号主义：又称逻辑主义、心理学派或计算机学派，其原理主要为物理符号系统（即符号操作系统）假设和有限合理性原理。</li>
<li>连接主义：又称仿生学派或生理学派，其原理主要为神经网络及神经网络间的连接机制与学习算法。</li>
<li>行为主义：又称进化主义或控制论学派，其原理为控制论及感知 - 动作型控制系统。</li>
</ul>
</li>
<li><p>产生式系统的推理包括正向推理、反向推理、双向推理</p>
</li>
<li><p>不确定性类型按性质分：随机性、模糊性、不一致性和不确定性。</p>
</li>
<li><p>人工智能的特性表现在4个方面：能感知客观世界的信息、能对通过思维对获取的知识进行加工处理、能通过学习积累知识增长才干和适应环境变化、能对外界的刺激作出反应传递信息。</p>
</li>
<li><p>“与/或”图就是用“与”节点和“或”节点组合起来的树形图，用来描述某类问题的求解过程。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记整理</category>
        <category>考研复试</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>《数据库系统概论》学习笔记之关系数据库</title>
    <url>/posts/ac7121e8.html</url>
    <content><![CDATA[<blockquote>
<p>整理《数据库系统概论》学习笔记，方便日后回顾整理。</p>
</blockquote>
<h2 id="2-1-关系数据结构及形式化定义"><a href="#2-1-关系数据结构及形式化定义" class="headerlink" title="2.1 关系数据结构及形式化定义"></a>2.1 关系数据结构及形式化定义</h2><h3 id="2-1-1-关系"><a href="#2-1-1-关系" class="headerlink" title="2.1.1 关系"></a>2.1.1 关系</h3><p>域 (Domain)：域是一组具有相同数据类型的值的集合。</p>
<p>笛卡尔积 (Cartiesian Product)：给定一组域 $D_1$，$D_2$，……，$D_n$，这些域中可以有相同的。这组域的笛卡儿积为：</p>
<script type="math/tex; mode=display">
D_1\times D_2 \times ... \times D_n = \{ (d_1, d_2, ..., d_n) | d_i \in D_i, i=1, 2, ..., n\}</script><p>假设集合 A={a, b}，集合 B={0, 1, 2}，则两个集合的笛卡尔积为 {(a, 0), (a, 1), (a, 2), (b, 0), (b, 1), (b, 2)}。</p>
<p>关系：是笛卡儿积的有限子集，表示为 $R(D_1, D_2, …, D_n)$，其中 R 为关系名，n 为关系的目或度。</p>
<ul>
<li><p>元组：关系的每个元素是关系中的元组，通常用 t 表示。</p>
</li>
<li><p>属性：关系中不同列可以对应相同的域，为了加以区分，必须对每列取一个名字称为属性，n 目关系必有 n 个属性。</p>
</li>
<li><p>码</p>
<ul>
<li>候选码：若关系中的某一属性组的值能唯一地标识一个元组，则称该属性组为候选码。</li>
<li>全码：在最极端的情况下，关系模式的所有属性是这个关系模式的候选码，称为全码。</li>
<li>主码：若一个关系有多个候选码，则选定其中一个为主码。</li>
<li>主属性：候选码的诸属性称为主属性。</li>
<li>非主属性：不包含在任何候选码中的属性称为非主属性或非码属性。</li>
</ul>
</li>
<li><p>关系可以有三种类型：基本关系（基本表或基表）、查询表和视图表。</p>
<ul>
<li>基本表是实际存在的表，它是实际存储数据的逻辑表示；</li>
<li>查询表示查询结果对应的表；</li>
<li>视图表是由基本表或其他视图表导出的表，是虚表，不对应实际存储的数据。</li>
</ul>
</li>
<li><p>在对关系进行限定和扩充下（为了适应数据库要求），关系需要具有以下几个性质：</p>
<ul>
<li><p>列是同质的</p>
</li>
<li><p>不同的列可出自同一个域</p>
</li>
<li><p>列的顺序无所谓，列的次序可以任意交换</p>
</li>
<li><p>任意两个元组的候选码不能取相同的值</p>
</li>
<li><p>行的顺序无所谓，行的次序可以任意交换</p>
</li>
<li><p>分量必须取原子值，这是规范条件中最基本的一条</p>
<p>必须保证表中不能再有表</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-1-2-关系模式"><a href="#2-1-2-关系模式" class="headerlink" title="2.1.2 关系模式"></a>2.1.2 关系模式</h3><p>关系的描述称为关系模式（型），关系是关系模式在某一时刻的状态或内容（值）。关系模式是静态的、稳定的，而关系是动态的、随时间不断变化的。</p>
<h3 id="2-1-3-关系数据库"><a href="#2-1-3-关系数据库" class="headerlink" title="2.1.3 关系数据库"></a>2.1.3 关系数据库</h3><p>关系数据库的型也称为关系数据库模式，是对关系数据库的描述。关系数据库的值是这些关系模式在某一时刻对应的关系的集合，通常就称为关系数据库。</p>
<h2 id="2-2-关系操作"><a href="#2-2-关系操作" class="headerlink" title="2.2 关系操作"></a>2.2 关系操作</h2><p>关系操作的对象和结果都是集合。基本操作：选择、投影、并、差、笛卡尔积。分类：关系代数、关系演算、介于两者之间（SQL）。</p>
<h2 id="2-3-关系代数"><a href="#2-3-关系代数" class="headerlink" title="2.3 关系代数"></a>2.3 关系代数</h2><blockquote>
<p>这部分内容请参考书本</p>
</blockquote>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-03-21_13-53-06.png" alt></p>
<h3 id="2-3-1-传统的集合运算"><a href="#2-3-1-传统的集合运算" class="headerlink" title="2.3.1 传统的集合运算"></a>2.3.1 传统的集合运算</h3><p>并（Union）：</p>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-03-21_14-02-31.png" alt></p>
<p>差：</p>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-03-21_14-03-25.png" alt></p>
<p>交：</p>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-03-21_14-04-13.png" alt></p>
<p>笛卡尔积：</p>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-03-21_14-04-50.png" alt></p>
<h3 id="2-3-2-专门的关系运算"><a href="#2-3-2-专门的关系运算" class="headerlink" title="2.3.2 专门的关系运算"></a>2.3.2 专门的关系运算</h3><p>选择运算：</p>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-03-21_14-11-38.png" alt></p>
<p>投影运算：要去掉相同的行</p>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-03-21_14-12-42.png" alt></p>
<p>连接运算：</p>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-03-21_14-13-25.png" alt></p>
<ul>
<li>等值连接</li>
<li>自然连接</li>
</ul>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-03-21_14-16-11.png" alt></p>
<ul>
<li>外连接</li>
<li>左外连接</li>
<li>右外连接</li>
</ul>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-03-21_14-18-22.png" alt></p>
<p>除运算：</p>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-03-21_14-23-36.png" alt></p>
<h2 id="2-4-关系的完整性"><a href="#2-4-关系的完整性" class="headerlink" title="2.4 关系的完整性"></a>2.4 关系的完整性</h2><ol>
<li>实体完整性：若属性（指一个或一组属性）A 是基本关系 R 的主属性，则 A 不能取空值。</li>
<li>参照完整性：设F是基本关系R的一个或一组属性，但不是关系R的码，Ks是基本关系S的主码。如果F与Ks相对应，则称F是R的外码，并称基本关系R为参照关系，基本关系S为被参照关系或目标关系。参照完整性规则：若属性（或属性组）F是基本关系R的外码，它与基本关系S的主码Ks相对应，则对于R中每个元组在F上的值必须：或者取空值，或者等于S中某个元组的主码值。</li>
<li>用户定义的完整性：就是针对某一具体关系数据库的约束条件，它反映某一具体应用所涉及的数据必须满足的语义要求。</li>
</ol>
<p>其中，1，2是关系模型必须满足的完整性约束，被称作关系的两个不变性，应用由关系系统自动支持。</p>
]]></content>
      <categories>
        <category>笔记整理</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>复习笔记</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>《数据库系统概论》学习笔记之绪论</title>
    <url>/posts/b8222433.html</url>
    <content><![CDATA[<blockquote>
<p>整理《数据库系统概论》学习笔记，方便日后回顾整理。</p>
</blockquote>
<h2 id="1-1-数据库系统概述"><a href="#1-1-数据库系统概述" class="headerlink" title="1.1 数据库系统概述"></a>1.1 数据库系统概述</h2><h3 id="1-1-1-数据库-4个基本概念"><a href="#1-1-1-数据库-4个基本概念" class="headerlink" title="1.1.1 数据库 4个基本概念"></a>1.1.1 数据库 4个基本概念</h3><ol>
<li>数据 (Data)：数据是数据库中存储的基本对象，也定义为描述事物的符号记录。此外，数据的含义称为数据的语义，数据与其语义是不可分的。</li>
<li>数据库 (DB)：数据库是长期储存在计算机内、有组织的、可共享的大量数据的集合。数据库中的数据按一定的数据模型组织、描述和储存，具有较小的冗余度、较高的数据独立性和易扩展性，并可为各种用户共享。 数据库数据具有永久存储、有组织和可共享三个基本特点。</li>
<li>数据库管理系统 (DBMS)：位于用户与操作系统之间的一层数据管理软件，用于管理数据库，主要功能：数据定义功能、数据组织、存储和管理、数据操纵、数据库的事务管理和运行管理、数据库的建立和维护功能等等。</li>
<li>数据库系统 (DBS)：数据库系统是由数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员组成的存储、管理、处理和维护数据的系统。</li>
</ol>
<h3 id="1-1-2-数据库管理技术的产生和发展"><a href="#1-1-2-数据库管理技术的产生和发展" class="headerlink" title="1.1.2 数据库管理技术的产生和发展"></a>1.1.2 数据库管理技术的产生和发展</h3><ol>
<li>人工管理阶段</li>
<li>文件系统阶段 </li>
<li>数据库系统阶段</li>
</ol>
<h3 id="1-1-3-数据库系统的特点"><a href="#1-1-3-数据库系统的特点" class="headerlink" title="1.1.3 数据库系统的特点"></a>1.1.3 数据库系统的特点</h3><ol>
<li>数据结构化：这事数据库的主要特征之一，也是数据库系统和文件系统的本质区别；</li>
<li>数据的共享性高、冗余度低且易扩充；</li>
<li>数据独立性高：包括「物理独立性」和「逻辑独立性」，物理独立性是指用户的应用程序和数据库中数据的物理存储是相互独立的。逻辑独立性是指用户的应用程序和数据库的逻辑结构是相互独立的；</li>
<li>数据由数据库管理系统 (DBMS) 统一管理和控制，这能解决共享导致的安全隐患，它能提供数据的安全性（Security）保护，数据的完整性（Integrity）检查，并发（Concurrency）控制，数据库恢复（Recovery）。</li>
</ol>
<p>综上，数据库是长期存储在计算机内有组织、大量、共享的数据集合。它可以供各种用户共享，具有最小冗余度和较高的数据独立性。数据库管理系统在数据库建立、运用和维护时对数据库进行统一控制，以保证数据的完整性和安全性，并在多用户同时使用数据库时进行兵法控制，在发生故障后对数据库进行恢复。</p>
<h2 id="1-2-数据模型"><a href="#1-2-数据模型" class="headerlink" title="1.2 数据模型"></a>1.2 数据模型</h2><p>在数据库中用数据模型来抽象、表示和处理现实世界中的事物，用来描述数据、组织数据和对数据进行操作的。数据模型是数据库系统的核心和基础。</p>
<h3 id="1-2-1-两大类数据模型"><a href="#1-2-1-两大类数据模型" class="headerlink" title="1.2.1 两大类数据模型"></a>1.2.1 两大类数据模型</h3><ol>
<li>概念模型：又称信息模型，它按用户的观点来对数据和信息建模，主要用于数据库（DB）设计。</li>
<li>逻辑模型和物理模型：按照计算机系统的观点对数据建模，用于数据库管理系统（DBMS）的实现。逻辑模型主要包括层次模型、网状模型、关系模型、面向对象数据模型和对象关系数据模型、半结构化模型等。物理模型是对数据最底层的抽象，描述数据在系统内部的表示方式和存取方法，在磁盘或磁带上的存储方式和存取方式。</li>
</ol>
<h3 id="1-2-2-数据模型的组成要素"><a href="#1-2-2-数据模型的组成要素" class="headerlink" title="1.2.2 数据模型的组成要素"></a>1.2.2 数据模型的组成要素</h3><p>数据模型一般由数据结构、数据操作和数据完整性约束条件三部分组成。</p>
<ol>
<li>数据结构：描述数据库的组成对象，以及对象之间的联系。数据结构是对系统静态特性的描述。</li>
<li>数据操作：对数据库中各种对象（型）的实例（值）允许执行的操作及有关的操作规则。如查询、更新（包括插入、删除、修改）。数据操作是对系统动态特性的描述。</li>
<li>完整性约束条件：一组完整性规则的集合。完整性规则为给定的数据模型中数据及其联系所具有的制约和储存规则，用以限定符号数据模型的数据库状态以及状态的变化，以保证数据的正确、有效、相容。</li>
</ol>
<h3 id="1-2-3-概念模型"><a href="#1-2-3-概念模型" class="headerlink" title="1.2.3 概念模型"></a>1.2.3 概念模型</h3><p>概念模型用于信息世界的建模，是现实世界到机器世界的一个中间层次，是数据库设计的有力工具，数据库设计人员和用户之间进行交流的语言。于是，要求概念模型有较强的语义表达能力，能够方便、直接地表达应用中的各种语义知识，简单、清晰、易于用户理解。</p>
<p>信息世界中的基本概念：</p>
<ol>
<li>实体 (Entity)：客观存在并可互相区别的事物称为实体。（具体的一个事物，例如一个学生）</li>
<li>属性 (Attribute)：实体所具有的某一特性称为属性。（一个实体可以由若干个属性来刻画，例如学生实体可以由学号、性别、姓名等来刻画）</li>
<li>码 (Key)：唯一标识实体的属性集称为码。（学号可以作为学生实体的码，来唯一区分）</li>
<li>域 (Domain)：属性的取值范围称为该属性的域。</li>
<li>实体型 (Entity Type)：用实体名及其属性名集合来抽象和刻画同类实体，称为实体型。例如（学生（学号，姓名，性别，出生年月）就是一个实体型）</li>
<li>实体集 (Entity Set)：同一类型实体的集合称为实体集（例如全体学生就是一个实体集）</li>
<li>联系 (Relationship)：实体之间的联系通常指不同实体集之间的联系，实体之间的联系有一对一、一对多和多对多等多种类型</li>
</ol>
<p>概念模型一般采用实体-联系方法，也就是E-R图来描述</p>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-03-21_11-14-34.png" alt></p>
<h3 id="1-2-4-最常用的数据模型"><a href="#1-2-4-最常用的数据模型" class="headerlink" title="1.2.4 最常用的数据模型"></a>1.2.4 最常用的数据模型</h3><ol>
<li><p>格式化模型</p>
<ol>
<li><a href="#1-2-5-层次模型">层次模型（Hierarchical Model）</a></li>
<li><a href="#1-2-6-网状模型">网状模型（Network Model）</a></li>
</ol>
<p>格式化模型的共同缺点：记录之间的联系是通过存取路径实现的，应用程序在访问数据时必须选择适当的存取路径，用户必须了解系统结构的细节，加重了编写应用程序的负担。不支持集合处理，即未提供一个处理多个记录的功能。</p>
</li>
<li><a href="#1-2-7-关系模型">关系模型（Relational Model）</a></li>
<li>面向对象模型（Object Oriented Model）</li>
<li>对象关系模型（Object Relational Model）</li>
</ol>
<h3 id="1-2-5-层次模型"><a href="#1-2-5-层次模型" class="headerlink" title="1.2.5 层次模型"></a>1.2.5 层次模型</h3><p>层次模型是数据库系统中最早出现的数据模型，层次数据库系统的典型代表是 IBM 公司的 IMS 数据库管理系统。</p>
<p>层次模型用树形结构来表示各类实体以及实体间的联系，这棵树需要满足以下两个条件：</p>
<ol>
<li><p>有且只有一个结点没有双亲结点，这个节点称为根结点；</p>
</li>
<li><p>根以外的其他结点有且只有一个双亲结点。</p>
</li>
</ol>
<p>优点：数据结构比较简单清晰；查询效率高，性能优于关系模型，不低于网状模型；提供了良好的完整性支持。</p>
<p>缺点：多对多联系表示不自然；对插入和删除操作的限制多，应用程序的编写比较复杂；查询子女结点必须通过双亲结点；由于结构严密，层次命令趋于程序化。</p>
<h3 id="1-2-6-网状模型"><a href="#1-2-6-网状模型" class="headerlink" title="1.2.6 网状模型"></a>1.2.6 网状模型</h3><p>网状数据库系统采用网状模型作为数据的组织方式，典型代表：DBTG系统，亦称为CODASYL系统。<br>满足下列两个条件的基本层次联系的集合：</p>
<ol>
<li>允许一个以上的结点无双亲；</li>
<li>一个结点可以有多于一个的双亲。</li>
</ol>
<p>层次模型比较：网状模型具有更宽松的规则，更具有普遍性，实际上层次模型是网状模型的一个特例。<br>优点：能够更为直接描述现实世界；良好的性能，存取效率较高。<br>缺点：结构复杂，而且随着应用环境的扩大，数据库的结构就变得越复杂，不利于最终用户掌握；网状模型的 DDL、DML 语言复杂，用户不易使用；记录类型联系变动后涉及链接指针的调整，扩充和维护都比较复杂。</p>
<h3 id="1-2-7-关系模型"><a href="#1-2-7-关系模型" class="headerlink" title="1.2.7 关系模型"></a>1.2.7 关系模型</h3><p>关系数据库采用关系模型作为数据的组织方式，关系模型建立在严格的数学概念的基础上，在用户观点下，关系模型中的数据的逻辑结构是一张二维表，它由行和列组成。</p>
<ol>
<li>关系：一个关系对应通常说的一张表；</li>
<li>元组：表中的一行即为一个组元组；</li>
<li>属性：表中的一列即为一个属性，给每个属性取一个名称即为属性名；</li>
<li>主码：表中的某个属性组，它可以唯一确定一个元组。</li>
<li>域：属性的取值范围。</li>
<li>分量：元组中的一个属性值。</li>
<li>关系模式：对关系的描述，一般表示为 关系名（属性1，属性2，……，属性n）</li>
</ol>
<p>关系模型要求关系必须是规范化的，关系的每一个分量必须是一个不可分的数据项。</p>
<p>优点：建立在严格的数学概念上；可以描述一对一、一对多和多对多的联系；概念单一；存取路径对用户透明，数据结构简单、清晰，用户易懂易用，开发方便。</p>
<p>缺点：存取路径对用户透明导致查询效率往往不如非关系数据模型；为了提高性能，必须对用户的查询请求进行优化增加了开发 DBMS 的难度。</p>
<h2 id="1-3-数据库系统结构"><a href="#1-3-数据库系统结构" class="headerlink" title="1.3 数据库系统结构"></a>1.3 数据库系统结构</h2><p>从数据库最终用户角度看（数据库系统外部的体系结构） ，数据库系统的结构分为:</p>
<ul>
<li><p>单用户结构</p>
</li>
<li><p>主从式结构</p>
</li>
<li><p>分布式结构</p>
</li>
<li><p>客户／服务器</p>
</li>
<li><p>浏览器／应用服务器／数据库服务器多层结构等</p>
</li>
</ul>
<p>从数据库管理系统角度看，数据库系统通常采用三级模式结构，是数据库系统内部的系统结构。</p>
<h3 id="1-3-1-数据库系统模式的概念"><a href="#1-3-1-数据库系统模式的概念" class="headerlink" title="1.3.1 数据库系统模式的概念"></a>1.3.1 数据库系统模式的概念</h3><ol>
<li>“型”和“值”的概念：型（Type）是指对某一类数据的结构和属性的说明，值（Value）是型的一个具体赋值。例如一个学生记录型为（学号，姓名，性别，系别，年龄，籍贯），而一个记录值为（900201，李明，男，计算机，22，江苏）。</li>
<li>模式：数据库中全体数据的逻辑结构和特征描述，是型的描述，反映的是数据的结构及其联系，模式是相对稳定的。</li>
<li>实例：模式的一个具体值称为模式的一个实例，反映数据库某一时刻的状态，同一个模式可以有很多实例，实例是相对变动的。</li>
</ol>
<h3 id="1-3-2-数据库系统的三级模式结构"><a href="#1-3-2-数据库系统的三级模式结构" class="headerlink" title="1.3.2 数据库系统的三级模式结构"></a>1.3.2 数据库系统的三级模式结构</h3><p>数据库系统的三级模式结构：外模式、模式和内模式三级构成。</p>
<ul>
<li>模式：也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图，综合了所有用户的需求。模式是数据库系统模式结构的中间层。</li>
<li>外模式：也称子模式或用户模式，它是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。外模式介于模式与应用之间。</li>
<li>内模式：也称存储模式，一个数据库只有一个内模式。它是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式。</li>
</ul>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-03-21_12-47-19.png" alt></p>
<h3 id="1-3-3-数据库的二级映像功能与数据独立性"><a href="#1-3-3-数据库的二级映像功能与数据独立性" class="headerlink" title="1.3.3 数据库的二级映像功能与数据独立性"></a>1.3.3 数据库的二级映像功能与数据独立性</h3><p>三级模式是对数据的三个抽象级别，二级映像在 DBMS 内部实现这三个抽象层次的联系和转换。数据库的二级映象功能：</p>
<ul>
<li>外模式／模式映象：当模式改变时，由数据库管理员对各个外模式／模式的映象作相应改变，可以使外模式保持不变。应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的「逻辑独立性」。</li>
<li>模式／内模式映象：当数据库的存储结构改变时，由数据库管理员对模式／内模式映象作相应改变，可以使模式保持不变，从而应用程序也不必改变，保证了数据与程序的物理独立性，简称数据的「物理独立性」。  </li>
</ul>
]]></content>
      <categories>
        <category>笔记整理</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>复习笔记</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>全排列算法总结</title>
    <url>/posts/83505976.html</url>
    <content><![CDATA[<h2 id="全排列递归算法"><a href="#全排列递归算法" class="headerlink" title="全排列递归算法"></a>全排列递归算法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>求 n 位的字符串的全排列，先确定第 0 位，然后对后面 n-1 位进行全排列，在对 n-1 为进行全排列时，先确定第 1 位，然后对后面的 n-2 位进行全排列…由此得到递归函数和递归的结束条件。全排列也就是交换位置，到 n-2 位时，就是将 n-2 和 n-1 交换位置。</p>
<p>例如输入字符串<code>abc</code>，则打印出 a、b、c 所能排列出来的所有字符串 <code>abc</code>、<code>acb</code>、<code>bac</code>、<code>bca</code>、<code>cab</code> 和 <code>cba</code> 。具体过程如下：</p>
<ul>
<li>第一位是 a 固定，对后面的 bc 交换位置得 abc，acb；</li>
<li>当 a 和 b 交换位置之后，得到 bac，对 ac 进行全排列 bac，bca；</li>
<li>当 a 和 c 交换位置之后，得到 cba，对 ba 进行全排列得cba，cab。</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>于是我们根据这种思想写出第一个版本的算法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perm</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">list</span>, <span class="keyword">int</span> i, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j, temp;</span><br><span class="line">	<span class="keyword">if</span> (i == n) &#123;<span class="comment">//n表示字符串最后一位的下标</span></span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="built_in">list</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="keyword">for</span> (j = i; j &lt;= n; j++)&#123;</span><br><span class="line">        	swap(<span class="built_in">list</span>[i], <span class="built_in">list</span>[j], temp);</span><br><span class="line">        	<span class="comment">//交换位置后，输出以list[j]不变，后面的字母改变的所有排列</span></span><br><span class="line">        	perm(<span class="built_in">list</span>, i + <span class="number">1</span>, n);</span><br><span class="line">        	swap(<span class="built_in">list</span>[i], <span class="built_in">list</span>[j], temp);</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们实现基本的全排列的功能，但是这样我们并不能解决一种情况，即类似于<code>abb</code>去重的问题，<code>abb</code>这种交换后一样的情况在输出时会输出两个，于是我们需要对我们的算法进行改进，得到第二版的算法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSwap</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">list</span>, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt; end; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>[i] == <span class="built_in">list</span>[end])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perm</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">list</span>, <span class="keyword">int</span> i, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j, temp;</span><br><span class="line">    <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\t%s\n"</span>, <span class="built_in">list</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (isSwap(<span class="built_in">list</span>, i, j)) &#123;</span><br><span class="line">                swap(<span class="built_in">list</span>[i], <span class="built_in">list</span>[j], temp);</span><br><span class="line">                <span class="comment">//交互位置后，输出以list[j]不变，后面的字母改变的所有排列</span></span><br><span class="line">                perm(<span class="built_in">list</span>, i + <span class="number">1</span>, n);</span><br><span class="line">                swap(<span class="built_in">list</span>[i], <span class="built_in">list</span>[j], temp);</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在进行交换前进行判断，当第 i 个字符和第 j 个字符交换位置时，判断范围是 [i, j) 是否有和 j 重复的数，如果重复我们跳过这种情况。</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><blockquote>
<p>题目内容：对字符串（数字，字母，符号）进行全排列，并统计全排列的种树</p>
<p>输入描述：输入一个字符串</p>
<p>输出描述：输出字符串的全排列，每种情况占一行，最后一行输出全排列的个数</p>
<p>输入样例</p>
<p>123</p>
<p>输出样例</p>
<p>123<br>132<br>213<br>231<br>312<br>321<br>6</p>
</blockquote>
<p>这题目的坑在于对输出的全排列需要排序，ac代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;  </span><br><span class="line"><span class="built_in">string</span> s[<span class="number">105</span>];</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span>  </span>&#123;  </span><br><span class="line">    <span class="keyword">char</span> temp;</span><br><span class="line">	temp = str[a];</span><br><span class="line">	str[a] = str[b];</span><br><span class="line">	str[b] = temp;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSwap</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> m)</span>  </span>&#123;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;m;i++)  </span><br><span class="line">    <span class="keyword">if</span>(str[m]==str[i])  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Perm</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> m)</span>  </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(k==m)&#123;  </span><br><span class="line">       <span class="comment">// cout&lt;&lt;s&lt;&lt;endl;  </span></span><br><span class="line">        s[sum++] = str;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;=m;i++)&#123;  </span><br><span class="line">            <span class="keyword">if</span>(isSwap(k,i))&#123;  </span><br><span class="line">                swap(k,i);  </span><br><span class="line">                Perm(k+<span class="number">1</span>,m);  </span><br><span class="line">                swap(k,i);  </span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;   </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;str)&#123;  </span><br><span class="line">        sum=<span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">int</span> len=str.length();  </span><br><span class="line">        Perm(<span class="number">0</span>,len<span class="number">-1</span>); </span><br><span class="line">        sort(s,s+sum);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sum;i++)</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;s[i]&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;      </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用next-permutation（排列组合）函数"><a href="#使用next-permutation（排列组合）函数" class="headerlink" title="使用next_permutation（排列组合）函数"></a>使用next_permutation（排列组合）函数</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>对于next_permutation函数，其函数原型为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">next_permutation</span><span class="params">(iterator start,iterator end)</span></span></span><br></pre></td></tr></table></figure>
<p>当当前序列不存在下一个排列时，函数返回 false，否则返回 true。</p>
<p>例如这个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> num[<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;  </span><br><span class="line">    <span class="keyword">do</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;num[<span class="number">0</span>]&lt;&lt;<span class="string">" "</span>&lt;&lt;num[<span class="number">1</span>]&lt;&lt;<span class="string">" "</span>&lt;&lt;num[<span class="number">2</span>]&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    &#125;<span class="keyword">while</span>(next_permutation(num,num+<span class="number">3</span>));  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出的结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">1 3 2</span><br><span class="line">2 1 3</span><br><span class="line">2 3 1</span><br><span class="line">3 1 2</span><br><span class="line">3 2 1</span><br></pre></td></tr></table></figure>
<p>当把 while(next_permutation(num,num+3)) 中的 3 改为 2 时，输出就变为了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">2 1 3</span><br></pre></td></tr></table></figure>
<p>由此可以看出，next_permutation(num,num+n) 函数是对数组 num 中的前 n 个元素进行全排列，同时并改变num数组的值。</p>
<p>另外，需要强调的是，next_permutation() 在使用前需要对欲排列数组按升序排序，否则只能找出该序列之后的全排列数。比如，如果数组 num 初始化为 2，3，1，那么输出就变为了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 3 1</span><br><span class="line">3 1 2</span><br><span class="line">3 2 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>next_permutation() 函数功能是输出所有比当前排列大的排列，顺序是从小到大。</p>
<p>prev_permutation() 函数功能是输出所有比当前排列小的排列，顺序是从大到小。</p>
</blockquote>
<p>此外，next_permutation(node, node+n, cmp) 可以对结构体 num 按照自定义的排序方式 cmp 进行排序。</p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>经典的<code>24点</code>问题就可以用全排列来暴力解决，北邮复试机考就考到了这个题。</p>
<blockquote>
<p>本文参考自：</p>
<p><a href="https://blog.csdn.net/ac_gibson/article/details/45308645" target="_blank" rel="noopener">C++STL中全排列函数next_permutation的使用</a> </p>
</blockquote>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>算法笔记</tag>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title>计算几何简单总结</title>
    <url>/posts/689f6bc0.html</url>
    <content><![CDATA[<blockquote>
<p>最近要整理板子，所以都要涉及一点，计算几何这块从来没有总结过，简单的整理一下，后面有时间慢慢补充起来。</p>
</blockquote>
<h3 id="三角形的面积"><a href="#三角形的面积" class="headerlink" title="三角形的面积"></a>三角形的面积</h3><p>这里介绍的是用<code>叉乘</code>求三角形面积的方法，两个响亮的向量集（叉乘）的模可以解释为以 a 和 b 为邻边的平行四边形的面积，故求三角形的面积为：$S = |\overrightarrow{AB} \times \overrightarrow{AC} | /2$ 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getS</span><span class="params">(Point a,Point b,Point c)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> ((b.x - a.x) * (c.y - a.y) - (b.y - a.y)*(c.x - a.x))/<span class="number">2</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多边形的面积"><a href="#多边形的面积" class="headerlink" title="多边形的面积"></a>多边形的面积</h3><p>求多边形面积最基础的方法就是用剖分法来做的，就是把多边形分成若干个三角形，然后对每个三角形求面积，求面积，在有精度要求的情况下，不要用海伦-秦九昭公式，海伦公式可能在精度损失方面会比较严重，而且计算量很大。</p>
<h3 id="多边形的重心"><a href="#多边形的重心" class="headerlink" title="多边形的重心"></a>多边形的重心</h3><p>重心的横坐标 = 多边形每一个三角形的重心的横坐标 * 该三角形的权值（面积）/ 多边形总面积。<br>重心的纵坐标 = 多边形每一个三角形的重心的纵坐标 * 该三角形的权值（面积）/ 多边形总面积。</p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>「<a href="http://nyoj.top/problem/3" target="_blank" rel="noopener">nyoj 3-多边形重心问题</a>」</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(i,m,n)  for(int i=m;i&lt; n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FFor(i,m,n) for(int i=m;i&lt;=n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bug(x) cout&lt;&lt;#x&lt;&lt;<span class="meta-string">"="</span>&lt;&lt;x&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Pi acos(-1.0) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Pow(a,b) pow(a,b)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getS</span><span class="params">(Point a,Point b,Point c)</span>    <span class="comment">//返回三角形面积 </span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> ((b.x - a.x) * (c.y - a.y) - (b.y - a.y)*(c.x - a.x))/<span class="number">2</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getPS</span><span class="params">(Point p[],<span class="keyword">int</span> n)</span>    <span class="comment">//返回多边形面积。必须确保 n&gt;=3，且多边形是凸多边形 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> sumS=<span class="number">0</span>;</span><br><span class="line">    FFor(i,<span class="number">2</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        sumS+=getS(p[<span class="number">1</span>],p[i],p[i+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sumS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">getPZ</span><span class="params">(Point p[],<span class="keyword">int</span> n)</span>    <span class="comment">//返回多边形重心</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Point z;</span><br><span class="line">    <span class="keyword">double</span> sumx = <span class="number">0</span>,sumy = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> sumS = <span class="number">0</span>;</span><br><span class="line">    FFor(i,<span class="number">2</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">double</span> S = getS(p[<span class="number">1</span>],p[i],p[i+<span class="number">1</span>]);</span><br><span class="line">        sumS += S;</span><br><span class="line">        sumx += (p[<span class="number">1</span>].x+p[i].x+p[i+<span class="number">1</span>].x)*S;</span><br><span class="line">        sumy += (p[<span class="number">1</span>].y+p[i].y+p[i+<span class="number">1</span>].y)*S;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sumS==<span class="number">0</span>)&#123;</span><br><span class="line">        z.x = <span class="number">0</span>,z.y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> z;</span><br><span class="line">    &#125;</span><br><span class="line">    z.x = sumx / (sumS );</span><br><span class="line">    z.y = sumy / (sumS );</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point p[<span class="number">10005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        FFor(i,<span class="number">1</span>,n)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>,&amp;p[i].x,&amp;p[i].y);</span><br><span class="line">        Point z = getPZ(p,n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.3lf %.3lf\n"</span>,<span class="built_in">fabs</span>(getPS(p,n)),(z.x+z.y)/<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>算法笔记</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>欧几里得算法与拓展欧几里得算法</title>
    <url>/posts/cd2c8225.html</url>
    <content><![CDATA[<h2 id="欧几里得算法-gcd"><a href="#欧几里得算法-gcd" class="headerlink" title="欧几里得算法 (gcd)"></a>欧几里得算法 (gcd)</h2><blockquote>
<p>正整数 a 与 b 的最大公约数指的是 a 与 b 的所有公约数中最大的那个公约数，如 4 和 6 的最大公约数是 2。</p>
<p>一般用 <code>gcd(a,b)</code> 来表示 a 和 b 的最大公约数，而求解最大公约数常用的<strong>欧几里得算法</strong>（即辗转相除法）。</p>
</blockquote>
<p>欧几里得算法基于定理：<strong>设 a、b 均为正整数，则 gcd(a, b) = gcd(b, a%b)。</strong></p>
<ul>
<li><p>如果 a&lt;b，那么定理的结构就是将 a 和 b 交换；</p>
</li>
<li><p>如果 a&gt;b，那么通过这个定理总可以将数据规模变小，并且减小的非常快。</p>
</li>
</ul>
<p>这样似乎可以很快就得到结果，只要还需要一个东西：<strong>递归边界</strong>，即数据规模减小到什么程度使得可以算出结果来。我们知道 0 和任意一个整数 a 的最大公约数都是 a（注意：不是 0），这个结论就可以当作递归的边界。</p>
<p>由此很容易想到将其写为递归的形式，因为递归的两个关键已经得到：</p>
<p><strong>1.递归式：gcd(a, b) = gcd(b, a%b).</strong></p>
<p><strong>2.递归边界：gcd(a, 0) = a.</strong></p>
<p>于是可以得到下面的求解最大公约数的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> gcd(b, a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更简洁的写法是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !b ? a : gcd(b, a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​            </p>
<h2 id="拓展欧几里得算法-extend-gcd"><a href="#拓展欧几里得算法-extend-gcd" class="headerlink" title="拓展欧几里得算法 (extend_gcd)"></a>拓展欧几里得算法 (extend_gcd)</h2><blockquote>
<p>欧几里得算法是为了解决这样一个问题：给定两个非零的整数 a 和 b，求一组正整数 (x, y)，使得 ax+ by = gcd(a, b) 成立，其中 gcd(a, b) 表示 a 和 b 的最大公约数。</p>
</blockquote>
<p>由前面用到的欧几里得算法求最大公约数的方法可知，它总是把 gcd(a, b) 转化为求解 gcd(b, a%b)，当 b 变为 0 的时候返回 a，此时 a 就等于gcd。</p>
<p>也就是说欧几里得算法结束的时候变量 a 中存放的是 gcd，变量 b 中存放的是 0，因此此时显然有 <code>a*1 + b*0 = gcd(a, b)</code> 成立，此时有 x = 1, y = 0 成立。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> gcd(b, a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，不妨我们用上面的欧几里得算法的过程来计算 x 和 y。</p>
<p>当计算 gcd(a, b) 时，有 $ax_1 + by_1 = gcd​$ 成立；</p>
<p>而在下一步计算 gcd(b, a%b) 时，又有 $bx_2 + (a\%b)y_2 = gcd​$ 成立。</p>
<p>由此 $ax_1 + by_1 = bx_2 + (a\%b)y_2$ 成立。</p>
<p>又考虑到有关系 $a\%b = a - (a/b)* b$ 成立，</p>
<p>因此 $ax_1 + by_1 = bx_2 + (a - (a/b)*b)y_2$ 成立。</p>
<p>整理式子之后得到 $ax_1 + by_1 = ay_2 + b(x_2 - (a/b)y_2)​$。</p>
<p>因此，对比等号左右两边可以马上得到下面的推到公式：</p>
<p>$x1 = y2​$</p>
<p>$y_1 = x_2 - (a /b)y_2​$</p>
<p>由此便可以通过 $x_2$ 和 ​$y_2$ 来反推 $x_1$ 和 $y_1$ 了。于是只需要到达递归边界、不断退出的过程中根据上面的公式计算 x 和 y，就可以得到一组解。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exGcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(b == <span class="number">0</span>)&#123; x = <span class="number">1</span>; y = <span class="number">0</span>; <span class="keyword">return</span> a;&#125;</span><br><span class="line">  <span class="keyword">int</span> g = exGcd(b, a%b, x, y);  <span class="comment">//递归计算exGcd(b,a%b)</span></span><br><span class="line">  <span class="keyword">int</span> temp = x;  <span class="comment">//存放x的数值</span></span><br><span class="line">  x = y;</span><br><span class="line">  y = temp - (a/b)*y;</span><br><span class="line">  <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>首发在：</p>
<p><a href="https://blog.csdn.net/hushhw/article/details/76165522" target="_blank" rel="noopener">https://blog.csdn.net/hushhw/article/details/76165522</a></p>
<p><a href="https://blog.csdn.net/hushhw/article/details/76216286" target="_blank" rel="noopener">https://blog.csdn.net/hushhw/article/details/76216286</a></p>
</blockquote>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>算法笔记</tag>
        <tag>gcd</tag>
      </tags>
  </entry>
  <entry>
    <title>编程的一些小知识点总结</title>
    <url>/posts/bcc9f05e.html</url>
    <content><![CDATA[<blockquote>
<p>一些零碎的知识点不好整理，就用一篇文章记下来，每次刷题的时候总是在这些小的知识点上卡壳，多是一些基础没有打扎实导致的一些简单函数不会用。</p>
</blockquote>
<h3 id="fill函数，fill与memset函数的区别1"><a href="#fill函数，fill与memset函数的区别1" class="headerlink" title="fill函数，fill与memset函数的区别1"></a>fill函数，fill与memset函数的区别<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></h3><ul>
<li><p><code>memset</code> 函数按照字节填充某字符，在头文件<code>&lt;cstring&gt;</code>里面。</p>
</li>
<li><p><code>fill</code> 函数按照单元赋值，将一个区间的元素都赋同一个值，在头文件<code>&lt;algorithm&gt;</code>里面。</p>
</li>
</ul>
<p>因为<code>memset</code>函数按照字节填充，所以一般 memset 只能用来填充char型数组（因为只有char型占一个字节），如果填充 int 型数组，除了<code>0</code>和<code>-1</code>之外其他的不能。因为只有 00000000 = 0，-1 同理，如果我们把每一位都填充「1」，会导致变成填充入「11111111」。赋值方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而<code>fill</code>函数可以赋任何值，而且使用方法特别简便，例如</p>
<ul>
<li><p><code>int</code>数组：<code>fill(arr, arr + n, 要填入的内容);</code></p>
</li>
<li><p><code>vector</code>也可以：<code>fill(v.begin(), v.end(), 要填入的内容);</code></p>
</li>
</ul>
<p>​         </p>
<h3 id="C-几种类型相互转换2"><a href="#C-几种类型相互转换2" class="headerlink" title="C++几种类型相互转换2"></a>C++几种类型相互转换<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></h3><p>将 string 转化 int 的方法：</p>
<ul>
<li><code>stoi</code> 是 string 库中的函数，他的参数是 string</li>
<li><code>atoi</code> 是 c 里面的函数，参数是 char* 型，因此在用 string时，必须调 c_str() 方法将其转为char*的字符串。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s=“<span class="number">123</span>”;</span><br><span class="line"><span class="keyword">int</span> v=atoi(s.c_str());</span><br><span class="line"><span class="keyword">int</span> u=stoi(s);</span><br></pre></td></tr></table></figure>
<p>​         </p>
<h3 id="ascii码"><a href="#ascii码" class="headerlink" title="ascii码"></a>ascii码</h3><p>a 的 ASCII 码 97，记二进制：0110 0001<br>A 的 ASCII 码 65，记二进制：0100 0001<br>刚好差了 32</p>
<p>​         </p>
<h3 id="String常用函数"><a href="#String常用函数" class="headerlink" title="String常用函数"></a>String常用函数</h3><p><a href="https://wiki.hushhw.cn/posts/f58b376e.html">https://wiki.hushhw.cn/posts/f58b376e.html</a></p>
<p>​           </p>
<h3 id="字符串切割-strtok"><a href="#字符串切割-strtok" class="headerlink" title="字符串切割 strtok()"></a>字符串切割 strtok()</h3><p>C 库函数 <strong>char *strtok(char *str, const char *delim)</strong> 分解字符串 <strong>str</strong> 为一组字符串，<strong>delim</strong> 为分隔符。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">char</span> str[<span class="number">80</span>] = <span class="string">"This is - hushhw.cn - website"</span>;</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> s[<span class="number">2</span>] = <span class="string">"-"</span>;</span><br><span class="line">   <span class="keyword">char</span> *token;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 获取第一个子字符串 */</span></span><br><span class="line">   token = strtok(str, s);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 继续获取其他的子字符串 */</span></span><br><span class="line">   <span class="keyword">while</span>( token != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">      <span class="built_in">printf</span>( <span class="string">"%s\n"</span>, token );</span><br><span class="line">    </span><br><span class="line">      token = strtok(<span class="literal">NULL</span>, s);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">This is </span></span><br><span class="line"><span class="comment">hushhw.cn </span></span><br><span class="line"><span class="comment">website</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>​          </p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="https://blog.csdn.net/liuchuo/article/details/52296646" target="_blank" rel="noopener">【C++】fill函数，fill与memset函数的区别</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;"><a href="https://wiki.hushhw.cn/posts/48867be4.html">C++几种类型相互转换</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>日常技巧</category>
      </categories>
      <tags>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>北邮复试机考模板</title>
    <url>/posts/3824aca0.html</url>
    <content><![CDATA[<blockquote>
<p>北邮机考可以带纸质材料，所以整理这篇「板子」以备不时之需。</p>
<p>Update: 今年政策，不允许带纸质材料，以后有需要再更新。</p>
</blockquote>
<h2 id="头文件模板"><a href="#头文件模板" class="headerlink" title="头文件模板"></a>头文件模板</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(i,m,n)  for(int i=m;i&lt; n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FFor(i,m,n) for(int i=m;i&lt;=n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bug(x) cout&lt;&lt;#x&lt;&lt;<span class="meta-string">"="</span>&lt;&lt;x&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Pi acos(-1.0) </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br></pre></td></tr></table></figure>
<h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><h3 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h3><h4 id="埃氏筛法"><a href="#埃氏筛法" class="headerlink" title="埃氏筛法"></a>埃氏筛法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">1e7</span>;</span><br><span class="line"><span class="keyword">int</span> prime[SIZE];		<span class="comment">//第i个素数</span></span><br><span class="line"><span class="keyword">bool</span> is_prime[SIZE];	<span class="comment">//true表示i是素数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++)</span><br><span class="line">		is_prime[i] = <span class="literal">true</span>;		<span class="comment">//初始化</span></span><br><span class="line">	is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="literal">false</span>;	<span class="comment">//0,1不是素数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(is_prime[i])&#123;</span><br><span class="line">			prime[p++] = i;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>*i; j&lt;=n; j+=i)  <span class="comment">//将i的倍数全部设为false</span></span><br><span class="line">				is_prime[j] = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;  </span><br><span class="line"><span class="function">ll <span class="title">mod_pow</span><span class="params">(ll x, ll n, ll mod)</span></span>&#123;  </span><br><span class="line">	ll res = <span class="number">1</span>;  </span><br><span class="line">	<span class="keyword">while</span>( n &gt; <span class="number">0</span> )&#123;   </span><br><span class="line">		<span class="keyword">if</span>( n &amp; <span class="number">1</span> ) res = res * x % mod;    <span class="comment">//n&amp;1 即 n%2  </span></span><br><span class="line">		x = x * x % mod;  </span><br><span class="line">		n &gt;&gt;= <span class="number">1</span>;                 <span class="comment">//n &gt;&gt;= 1 即 n/=2  </span></span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">return</span> res;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mat[MAXN][MAXN]; <span class="comment">//矩阵</span></span><br><span class="line">    <span class="keyword">int</span> row, col;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123; <span class="comment">//初始化為單位矩陣</span></span><br><span class="line">        <span class="built_in">memset</span>(mat, <span class="number">0</span>, <span class="keyword">sizeof</span>(mat));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">                mat[i][j] = (i==j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node <span class="title">mod_mul</span><span class="params">(node a, node b, <span class="keyword">int</span> p)</span> <span class="comment">//矩阵乘法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node ans;</span><br><span class="line">    ans.row = a.row;</span><br><span class="line">    ans.col = b.col;</span><br><span class="line">    <span class="built_in">memset</span>(ans.mat, <span class="number">0</span>, <span class="keyword">sizeof</span>(ans.mat));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.row; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ans.col; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; a.col; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                ans.mat[i][j] += a.mat[i][k] * b.mat[k][j];</span><br><span class="line">                ans.mat[i][j] %= p;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node <span class="title">mod_pow</span><span class="params">(node a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span> <span class="comment">//矩陣快速冪</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node ans;</span><br><span class="line">    ans.row = a.row;</span><br><span class="line">    ans.col = a.col;</span><br><span class="line">    ans.init();</span><br><span class="line">    <span class="keyword">while</span> (k)&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) ans = mod_mul(ans, a, p);</span><br><span class="line">        a = mod_mul(a, a, p);</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><h3 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h3><h4 id="floyd"><a href="#floyd" class="headerlink" title="floyd"></a>floyd</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i,j,k;</span><br><span class="line">  FFor(k,<span class="number">1</span>,n)</span><br><span class="line">	FFor(i,<span class="number">1</span>,n)</span><br><span class="line">	  FFor(j,<span class="number">1</span>,n)</span><br><span class="line">		<span class="keyword">if</span>(dis[i][j]&gt;dis[i][k]+dis[k][j])</span><br><span class="line">		  dis[i][j] = dis[i][k]+dis[k][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><ol>
<li><p>初始化pre[]数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> pre[<span class="number">1000</span>];</span><br><span class="line"><span class="comment">//初始化pre数组，让他们的前导点都记录为自己，即自己为根节点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123; </span><br><span class="line">	pre[i]=i; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>find()函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> r=x;</span><br><span class="line">  <span class="keyword">while</span>(pre[r]!=r)<span class="comment">//如果r的上级不是自己</span></span><br><span class="line">	r=pre[r];<span class="comment">//那么r等于它的前导点，继续寻找，直到找到根节点</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//下面这段起到路径压缩的作用</span></span><br><span class="line">  <span class="keyword">int</span> i=x; <span class="keyword">int</span> j;</span><br><span class="line">  <span class="keyword">while</span>(i!=r)&#123;<span class="comment">//如果当前查找的不是根结点（pre指向自己）</span></span><br><span class="line">	j=pre[i];<span class="comment">//在改变上级之前用临时变量j记录下他的值</span></span><br><span class="line">	pre[i]=r;<span class="comment">//更新前导点直接指向根节点</span></span><br><span class="line">	i=j;<span class="comment">//让i指向其前导点，在下一次循环里面就会更新其前导点指向根节点</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>join()函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> p1,<span class="keyword">int</span> p2)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> f1,f2;</span><br><span class="line">  f1 = find(p1);</span><br><span class="line">  f2 = find(p2); <span class="comment">//分别查找根节点</span></span><br><span class="line">  <span class="comment">//如果是不连通的，那么把这两个分支连起来</span></span><br><span class="line">  <span class="keyword">if</span>(f1!=f2)&#123;</span><br><span class="line">  	pre[f1]=f2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="计算几何"><a href="#计算几何" class="headerlink" title="计算几何"></a>计算几何</h2><h3 id="二维几何"><a href="#二维几何" class="headerlink" title="二维几何"></a>二维几何</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getS</span><span class="params">(Point a,Point b,Point c)</span></span>&#123;    <span class="comment">//返回三角形面积 </span></span><br><span class="line">    <span class="keyword">return</span> ((b.x - a.x) * (c.y - a.y) - (b.y - a.y)*(c.x - a.x))/<span class="number">2</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getPS</span><span class="params">(Point p[],<span class="keyword">int</span> n)</span></span>&#123;    <span class="comment">//返回多边形面积。必须确保 n&gt;=3，且多边形是凸多边形 </span></span><br><span class="line">    <span class="keyword">double</span> sumS=<span class="number">0</span>;</span><br><span class="line">    FFor(i,<span class="number">2</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        sumS+=getS(p[<span class="number">1</span>],p[i],p[i+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sumS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">getPZ</span><span class="params">(Point p[],<span class="keyword">int</span> n)</span></span>&#123;    <span class="comment">//返回多边形重心</span></span><br><span class="line">    Point z;</span><br><span class="line">    <span class="keyword">double</span> sumx = <span class="number">0</span>,sumy = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> sumS = <span class="number">0</span>;</span><br><span class="line">    FFor(i,<span class="number">2</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">double</span> S = getS(p[<span class="number">1</span>],p[i],p[i+<span class="number">1</span>]);</span><br><span class="line">        sumS += S;</span><br><span class="line">        sumx += (p[<span class="number">1</span>].x+p[i].x+p[i+<span class="number">1</span>].x)*S;</span><br><span class="line">        sumy += (p[<span class="number">1</span>].y+p[i].y+p[i+<span class="number">1</span>].y)*S;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sumS==<span class="number">0</span>)&#123;</span><br><span class="line">        z.x = <span class="number">0</span>,z.y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> z;</span><br><span class="line">    &#125;</span><br><span class="line">    z.x = sumx / (sumS );</span><br><span class="line">    z.y = sumy / (sumS );</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = atoi(str.c_str()); </span><br><span class="line"><span class="keyword">char</span> x[<span class="number">5</span>]; <span class="built_in">strcpy</span>(x, str.c_str());</span><br><span class="line"><span class="built_in">string</span> str = to_string(<span class="number">50</span>);</span><br></pre></td></tr></table></figure>
<h3 id="字符串切割-strtok"><a href="#字符串切割-strtok" class="headerlink" title="字符串切割 strtok()"></a>字符串切割 strtok()</h3><p>C 库函数 <strong>char *strtok(char *str, const char *delim)</strong> 分解字符串 <strong>str</strong> 为一组字符串，<strong>delim</strong> 为分隔符。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">char</span> str[<span class="number">80</span>] = <span class="string">"This is - hushhw.cn - website"</span>;</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> s[<span class="number">2</span>] = <span class="string">"-"</span>;</span><br><span class="line">   <span class="keyword">char</span> *token; </span><br><span class="line">   <span class="comment">/* 获取第一个子字符串 */</span></span><br><span class="line">   token = strtok(str, s); </span><br><span class="line">   <span class="comment">/* 继续获取其他的子字符串 */</span></span><br><span class="line">   <span class="keyword">while</span>( token != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">      <span class="built_in">printf</span>( <span class="string">"%s\n"</span>, token );</span><br><span class="line">      token = strtok(<span class="literal">NULL</span>, s);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">This is </span></span><br><span class="line"><span class="comment">hushhw.cn </span></span><br><span class="line"><span class="comment">website</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>​          </p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span>&gt;&gt;str; <span class="comment">//读入有效字符直到遇到空格</span></span><br><span class="line">getline(<span class="built_in">cin</span>, str); <span class="comment">//读取字符直到遇到换行</span></span><br><span class="line">getline(<span class="built_in">cin</span>, str, <span class="string">'a'</span>); <span class="comment">//直到遇到'a'结束，其中任何字符包括'\n'都可以读入</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">s += str;</span><br><span class="line">s.append(sh);</span><br><span class="line">s.append(str, <span class="number">5</span>, <span class="number">4</span>);</span><br><span class="line">s.append(<span class="string">"hello STL"</span>, <span class="number">5</span>, <span class="number">4</span>);</span><br><span class="line">s.append(<span class="number">5</span>, <span class="string">'x'</span>);</span><br><span class="line">s.push_back(<span class="string">'a'</span>);</span><br><span class="line"></span><br><span class="line">s.insert(<span class="number">0</span>, <span class="string">"hello"</span>);</span><br><span class="line">s.insert(<span class="number">0</span>, str, <span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line">s.insert(<span class="number">0</span>, <span class="string">"that is cool"</span>,<span class="number">8</span>);</span><br><span class="line">s.insert(<span class="number">7</span>, <span class="number">1</span>, <span class="string">':'</span>);</span><br><span class="line"></span><br><span class="line">s.erase(<span class="number">9</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">s.replace(<span class="number">15</span>, <span class="number">3</span>, str, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">s.replace(<span class="number">25</span>, <span class="number">3</span>, <span class="string">"C++ Primer Plus"</span>, <span class="number">4</span>, <span class="number">11</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> hello = s.substr(<span class="number">9</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(s.find(hello) != <span class="built_in">string</span>::npos)&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"'hello' found at:"</span>&lt;&lt;s.find(hello)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​           </p>
<h3 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h3><h4 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">10</span>)</span></span>;	<span class="comment">//该容器暂有10个int元素，每个元素被赋初始值为0</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">5</span>,<span class="number">99</span>)</span></span>;<span class="comment">//该容器有5个int元素，每个元素被赋值99</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v4</span><span class="params">(v2)</span></span>;	<span class="comment">//该容器拷贝v2，该容器具有10个值为0的元素。</span></span><br><span class="line"></span><br><span class="line">v.push_back(<span class="number">10</span>); <span class="comment">//在v的尾部插入元素10</span></span><br><span class="line">v.pop_back();<span class="comment">//尾部删除元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"在0位置的元素值为："</span>&lt;&lt;v.at(<span class="number">0</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"在1位置的元素值为："</span>&lt;&lt;v[<span class="number">1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"尾部数据的值为："</span> &lt;&lt; v.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"头部数据的值为："</span> &lt;&lt; v.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"vector中的元素个数为："</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"vector是否为空："</span> &lt;&lt; v.empty() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">swap(v[<span class="number">0</span>],v[<span class="number">1</span>]);</span><br><span class="line">sort(v.begin(), v.end());</span><br><span class="line">reverse(v.begin(), v.end());</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator vItera = v.begin();</span><br><span class="line">vItera = vItera + <span class="number">2</span>;</span><br><span class="line">v.erase(vItera);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator vInsert = v.begin();</span><br><span class="line">vInsert = vInsert + <span class="number">2</span>;</span><br><span class="line">v.insert(vInsert, <span class="number">777</span>);</span><br><span class="line"></span><br><span class="line">v.clear();</span><br></pre></td></tr></table></figure>
<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; Smap;</span><br><span class="line">Smap.insert(pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;(<span class="string">"r000"</span>, <span class="string">"student_zero"</span>));</span><br><span class="line">Smap.insert(<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::value_type(<span class="string">"r001"</span>, <span class="string">"student_one"</span>));</span><br><span class="line">Smap [ <span class="string">"r123"</span> ] =  <span class="string">"student_first"</span> ;</span><br><span class="line"><span class="keyword">int</span> nsize = Smap.size();</span><br><span class="line"><span class="keyword">for</span>(iter = Smap.begin(); iter != Smap.end(); iter++)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">" "</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">iter = Smap.find(<span class="string">"r123"</span>);</span><br><span class="line"><span class="keyword">if</span>(iter != Smap.end())</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"Find, the value is "</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"Do not Find"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> n = Smap.erase(<span class="string">"r123"</span>);<span class="comment">//如果删除了會返回1，否則返回0</span></span><br></pre></td></tr></table></figure>
<h4 id="set-和-multiset"><a href="#set-和-multiset" class="headerlink" title="set 和 multiset"></a>set 和 multiset</h4><p>set 和 multiset 的用法一样，就是 multiset 允许重复元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">classcomp</span>&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Node &amp;a, <span class="keyword">const</span> Node &amp;b)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x != b.x) <span class="keyword">return</span> a.x&lt;b.x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.y&gt;b.y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;Node, classcomp&gt; st;</span><br><span class="line"><span class="built_in">set</span>&lt;Node, classcomp&gt;::iterator sit;</span><br><span class="line"><span class="built_in">multiset</span>&lt;Node, classcomp&gt; mt;</span><br><span class="line"><span class="built_in">multiset</span>&lt;Node, classcomp&gt; mit;</span><br></pre></td></tr></table></figure>
<p>上面这段按照 x 从小到大排序，x 相同则按照 y 从大到小排序。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; v;		<span class="comment">//创建一个int类型的set容器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[<span class="number">10</span>]=&#123;<span class="number">9</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    v.insert(A[i]);</span><br><span class="line">&#125;</span><br><span class="line">it=v.find(<span class="number">9</span>);	</span><br><span class="line"><span class="keyword">if</span>(v.find(c)!=v.end())&#123; <span class="comment">//输出yes</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">v.erase (it); <span class="comment">//输出 0 1 2 3 4 5 6 7 8</span></span><br><span class="line">v.erase (v.find(<span class="number">0</span>));<span class="comment">//输出1 2 3 4 5 6 7 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//lower_bound 返回指向首个不小于给定键的元素的迭代器</span></span><br><span class="line"><span class="comment">//upper_bound 返回指向首个大于给定键的元素的迭代器</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator itlower, itupper;</span><br><span class="line">itlower = v.lower_bound(<span class="number">3</span>); </span><br><span class="line">itupper = v.upper_bound(<span class="number">6</span>); </span><br><span class="line">v.erase(itlower, itupper);<span class="comment">//输出为 1 2 7 8，删除了3——6</span></span><br><span class="line"></span><br><span class="line">v.count(i);<span class="comment">//返回元素个数，0或1，可用来判断一个元素是否存在</span></span><br></pre></td></tr></table></figure>
<h4 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">q.size();<span class="comment">//返回q里元素个数</span></span><br><span class="line">q.empty();<span class="comment">//返回q是否为空，空则返回1，否则返回0</span></span><br><span class="line">q.push(k);<span class="comment">//在q的末尾插入k</span></span><br><span class="line">q.pop();<span class="comment">//删掉q的第一个元素</span></span><br><span class="line">q.top();<span class="comment">//返回q的第一个元素</span></span><br></pre></td></tr></table></figure>
<p>在默认的优先队列中，优先级高的先出队；在默认的 int 型中先出队的为较大的数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; q1; <span class="comment">//大的先出队</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; q2;<span class="comment">//小的先出队</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y; <span class="comment">//x小的优先级高</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, cmp&gt; q;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> x,y;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (node a, node b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x &gt; b.x; <span class="comment">//结构体中，x 小的优先级高</span></span><br><span class="line">    <span class="comment">//return a.x &gt; b.x; //结构体中，x 大的优先级高</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;node&gt; q;<span class="comment">//定义方法</span></span><br><span class="line"><span class="comment">//在该结构中，y 为值，x 为优先级。</span></span><br><span class="line"><span class="comment">//通过自定义 operator&lt; 操作符来比较元素中的优先级。</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>考研</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 基础知识总结——const、static、inline</title>
    <url>/posts/39a780a.html</url>
    <content><![CDATA[<blockquote>
<p>本科主要学习的语言就是 C 和 C++，这篇文章把之前对 C/C++ 的基础总结整理出来，应对之后会遇到的很多次面试。</p>
<p>内容可能不太有逻辑性，内容来自之前自己的总结以及 <code>huihut</code> 总结的『[<a href="https://www.yuque.com/huihut/interview/readme" target="_blank" rel="noopener">C/C++ 面试基础知识总结</a>』，建议有需求的读者直接移步这位大佬的总结，非常全而且清晰。</p>
</blockquote>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>对于一般的变量来说，需要区分下面这几种写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const int *p;</span><br><span class="line">int const *q;</span><br></pre></td></tr></table></figure>
<p>上面两种写法都是指向<code>const int</code>类型的指针，指针指向的内存不能被修改，但是可以指向另一个内存，如下面这段代码表明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> b=<span class="number">4</span>;</span><br><span class="line">   <span class="keyword">int</span> c=<span class="number">5</span>;</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">int</span> *a= &amp;b;<span class="comment">//const 在左边，指针指向的内容为常量 即a的内容为常量 </span></span><br><span class="line">   <span class="keyword">int</span> <span class="keyword">const</span> *a=&amp;b;<span class="comment">//效果如上相同</span></span><br><span class="line">   a=&amp;c;<span class="comment">//可以改变a的指向 </span></span><br><span class="line">  <span class="comment">// *a=9;//错误：但是不能改变a的内容 </span></span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;*a; </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而下面这种写法表示<code>int</code>类型的<code>const</code>指针，指针所指向的内存可以被修改，但指针不能指向另一个内存。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int * const r= &amp;n;</span><br></pre></td></tr></table></figure>
<p>声明一个指向<code>const int</code>类型的<code>const</code>指针：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const int * const p=&amp;n;</span><br></pre></td></tr></table></figure>
<p>对于在函数声明中，有如下三种情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const int&amp; SetPoint(const int&amp; param) const</span><br></pre></td></tr></table></figure>
<p>第一个<code>const</code>指函数的返回值限定为 const，即返回值不能被修改。<br>第二个<code>const</code>指函数的形参为 const 类型，函数体内不能被修改。<br>第三个<code>const</code>指这个函数不会对这个类对象的数据成员作任何改变。<br>​          </p>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><h4 id="修饰普通变量"><a href="#修饰普通变量" class="headerlink" title="修饰普通变量"></a>修饰普通变量</h4><p>修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值 0 （在静态数据区，内存中所有的字节默认值都是0x00）初始化它。</p>
<p>把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期；把全局变量改变为静态变量后是改变了它的作用域， 限制了它的使用范围。static 这个说明符在不同的地方所起的作用是不同的。</p>
<p>例如下面这段代码，定义一个局部的静态变量，尽管多次调用函数，但是静态变量被初始化为 10 后，后面不会再不被初始化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">10</span>;</span><br><span class="line">	i=i+j;</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m=test(<span class="number">12</span>);</span><br><span class="line">	<span class="keyword">int</span> n=test(<span class="number">4</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; m &lt;&lt;<span class="built_in">endl</span>; <span class="comment">//输出 22</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; n &lt;&lt;<span class="built_in">endl</span>; <span class="comment">//输出 26</span></span><br><span class="line">  	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="修饰普通函数"><a href="#修饰普通函数" class="headerlink" title="修饰普通函数"></a>修饰普通函数</h4><p>表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命令函数重名，可以将函数定位为 static。</p>
<h4 id="修饰成员变量"><a href="#修饰成员变量" class="headerlink" title="修饰成员变量"></a>修饰成员变量</h4><p><strong>1) </strong>如果只声明了类而未定义对象，则类的一般数据成员是不占内存空间的，只有在定义对象时，才为对象的数据成员分配空间。但是静态数据成员不属于某一个对象，在为对象所分配的空间中不包括静态数据成员所占的空间。静态数据成员是在所有对象之外单独开辟空间。只要在类中定义了静态数据成员，即使不定义对象，也为静态数据成员分配空间，它可以被引用。</p>
<p><strong>2) </strong>对于静态变量，如果在一个函数中定义了静态变量，在函数结束时该静态变量并不释放，仍然存在并保留其值。静态数据成员也类似，它不随对象的建立而分配空间，也不随对象的撤销而释放（一般数据成员是在对象建立时分配空间，在对象撤销时释放）。静态数据成员是在程序编译时被分配空间的，到程序结束时才释放空间。<br><strong>3) </strong>静态数据成员至少需要在类外声明（要不在被引用时会报错），声明同时可以初始化，但只能在类体外进行初始化。</p>
<p><strong>4)</strong> 静态成员变量可以通过类和成员函数两种方式进行访问。</p>
<p><strong>5) </strong>有了静态数据成员，各对象之间的数据有了沟通的渠道，实现数据共享，因此可以不使用全局变量。全局变量破坏了封装的原则，不符合面向对象程序的要求。但是也要注意公用静态数据成员与全局变量的不同，静态数据成员的作用域只限于定义该类的作用域内（如果是在一个函数中定义类，那么其中静态数据成员的作用域就是此函数内）。在此作用域内，可以通过类名和域运算符“::”引用静态数据成员，而不论类对象是否存在。</p>
<h4 id="修饰成员函数"><a href="#修饰成员函数" class="headerlink" title="修饰成员函数"></a>修饰成员函数</h4><p>当调用一个对象的成员函数（非静态成员函数）时，系统会把该对象的起始地址赋给成员函数的this指针，而静态成员函数并不属于某一对象，它与任何对象都无关，因此静态成员函数没有this指针，既然它没有指向某一对象，就无法对一个对象中的非静态成员进行默认访问（即在引用数据成员时不指定对象名）。</p>
<p>静态成员函数可以直接引用本类中的静态数据成员，因为静态成员同样是属于类的，可以直接引用，静态成员函数中不能有普通成员变量。</p>
<p>在类外调用静态成员函数用 “<strong>类名</strong> <strong>::</strong> ”作限定词，或通过对象调用。<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> </p>
<p>​        </p>
<h3 id="inline-内联函数"><a href="#inline-内联函数" class="headerlink" title="inline 内联函数"></a>inline 内联函数</h3><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul>
<li>相当于把内联函数里面的内容写在调用内联函数处；</li>
</ul>
<ul>
<li>相当于不用执行进入函数的步骤，直接执行函数体；</li>
</ul>
<ul>
<li>相当于宏，却比宏多了类型检查，真正具有函数特性；</li>
</ul>
<ul>
<li>不能包含循环、递归、switch 等复杂操作；</li>
</ul>
<ul>
<li>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。</li>
</ul>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明1（加 inline，建议使用）</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">functionName</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> secend,...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明2（不加 inline）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">functionName</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> secend,...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">functionName</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> secend,...)</span> </span>&#123;<span class="comment">/****/</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类内定义，隐式内联</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doA</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;         <span class="comment">// 隐式内联</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外定义，需要显式内联</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">A::doA</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;   <span class="comment">// 需要显式内联</span></span><br></pre></td></tr></table></figure>
<h4 id="编译器对-inline-函数的处理步骤"><a href="#编译器对-inline-函数的处理步骤" class="headerlink" title="编译器对 inline 函数的处理步骤"></a>编译器对 inline 函数的处理步骤</h4><ol>
<li>将 inline 函数体复制到 inline 函数调用点处；</li>
</ol>
<ol>
<li>为所用 inline 函数中的局部变量分配内存空间；</li>
</ol>
<ol>
<li>将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；</li>
</ol>
<ol>
<li>如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。</li>
</ol>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点</p>
<ul>
<li>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</li>
<li>内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。</li>
<li>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。</li>
<li>内联函数在运行时可调试，而宏定义不可以。</li>
</ul>
<p>缺点</p>
<ul>
<li>代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li>
<li>inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。</li>
<li>是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></li>
</ul>
<p>​         </p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="http://www.cnblogs.com/xiehongfeng100/p/4591800.html" target="_blank" rel="noopener">C/C++中关键字static的用法及作用</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;"><a href="https://www.yuque.com/huihut/interview/readme#3xoclb" target="_blank" rel="noopener">C/C++ 面试基础知识总结——inline 内联函数</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>编程开发</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>面试总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Express 学习笔记</title>
    <url>/posts/1f901b6d.html</url>
    <content><![CDATA[<blockquote>
<p>本着所学必有所记的原则，学习一样新东西之后必须要做好笔记，即使现在时间似乎有点赶，但还是记录下来我的学习笔记，不然过不了多久就忘了。</p>
<p>Express 是这次我毕设要用到的后台，第一次用到 Express，所以笔记内容可能有些许纰漏，或不完整的地方，网上相关资料很多，官网也有非常清晰的文档，可以参看更加有价值的资料。</p>
</blockquote>
<h2 id="Express-简介"><a href="#Express-简介" class="headerlink" title="Express 简介"></a>Express 简介</h2><p>Express 是基于 Node.js 平台，快速、开放、极简的 web 开发框架，它提供一系列强大的特性，帮助你创建各种 Web 和移动设备应用。</p>
<p>Express 不对 Node.js 已有的特性进行二次抽象，我们只是在它之上扩展了 Web 应用所需的基本功能。</p>
<p><strong>Express 是一个自身功能极简，完全是由路由和中间件构成一个的 web 开发框架：从本质上来说，一个 Express 应用就是在调用各种中间件。</strong></p>
<p>​        </p>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="安装及-Hello-World"><a href="#安装及-Hello-World" class="headerlink" title="安装及 Hello World"></a>安装及 Hello World</h3><p>假设你已经装好了 <code>Node.js</code>，你就可以开始下面这些操作了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 工作目录</span><br><span class="line">$ mkdir myapp</span><br><span class="line">$ cd myapp</span><br><span class="line"></span><br><span class="line"># 通过 npm init 命令为你的应用创建一个 package.json 文件</span><br><span class="line">$ npm init</span><br></pre></td></tr></table></figure>
<p>执行 <code>npm init</code> 后会有很多信息需要填写，一般都是默认回车即可（默认启动文件为<code>index.js</code>），但是想要一步完成可以执行 <code>npm init -y</code> 。</p>
<p>这时候你得文件夹中创建好了一个 <code>package.json</code> 文件，定义了这个项目所需要的各种模块，以及项目的配置信息（比如名称、版本、许可证等元数据）。</p>
<p>需要注意的点：如果 npm 使用起来非常慢，建议使用<code>cnpm</code>，可以自行百度安装。</p>
<p>现在在<code>myapp</code>目录中安装Express并将其保存在依赖项列表中，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install express --save</span><br></pre></td></tr></table></figure>
<p><code>--save</code>：安装模块时，如果指定了 —save 参数，那么此模块将被添加到 package.json 文件中 dependencies 依赖列表中。 然后通过 npm install 命令即可自动安装依赖列表中所列出的所有模块。如果只是临时安装，不想将它添加到依赖列表中，只需略去 —save 参数即可。</p>
<p>再文件夹中新建 <code>app.js</code> 作为入口，故前面默认执行 npm init 后启动文件 <code>index.js</code> 需要我们修改一下，打开 package.json 文件，修改 <code>main: app.js</code>。</p>
<p>在 <code>app.js</code>中写入：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">req,res</span>) </span>&#123;</span><br><span class="line">    res.send(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> server = app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> host = server.address().address;</span><br><span class="line">    <span class="keyword">let</span> port = server.address().port;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`app listening at port: <span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>应用程序启动服务器并监听端口<code>3000</code>上的连接，对于根URL（<code>/</code>）或<strong>路由</strong>的请求，应用程序以<strong>“Hello World!”</strong>响应，对于其他所有路径，它将以 <strong>404 Not Found</strong> 响应，使用 <code>127.0.0.1:3000</code> 即可访问。</p>
<blockquote>
<p>还可以使用『Express应用生成器』来创建，但是对于初学者我来说有种一步登天的感觉，我入门是跟着视频教程『<a href="https://www.bilibili.com/video/av9570082/" target="_blank" rel="noopener">Node js Web Apps with Express</a>』走的，所以还是一步一步往上爬的好。</p>
</blockquote>
<p>​        </p>
<h3 id="基本路由"><a href="#基本路由" class="headerlink" title="基本路由"></a>基本路由</h3><p>路由是指如何定义应用的端点（URIs）以及如何响应客户端的请求。</p>
<p>路由（Routing）是由一个 URI（路径）和一个特定的 HTTP 方法（get、post、put、delete 等）组成的，涉及到应用如何响应客户端对某个网站节点的访问。</p>
<p>路由定义采用以下结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.METHOD(PATH, HANDLER)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>app</code>是express的一个实例。</li>
<li><code>METHOD</code>是某个的HTTP请求方法，Express 定义了很多 HTTP 请求对应的路由方法，如 get, post, put等。</li>
<li><code>PATH</code>是服务器上的路径。</li>
<li><code>HANDLER</code>是匹配到路由时执行的函数。</li>
</ul>
<p>以下示例说明了定义简单路由。</p>
<p>在主页上响应<strong>Hello World!</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.get(&apos;/&apos;, function (req, res) &#123;</span><br><span class="line">  res.send(&apos;Hello World!&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>响应应用程序主页的根路由（<code>/</code>）上的<code>POST</code>请求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.post(&apos;/&apos;, function (req, res) &#123;</span><br><span class="line">  res.send(&apos;Got a POST request&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>响应对<code>/user</code>路由的<code>PUT</code>请求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.put(&apos;/user&apos;, function (req, res) &#123;</span><br><span class="line">  res.send(&apos;Got a PUT request at /user&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>响应对<code>/user</code>路由的<code>DELETE</code>请求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.delete(&apos;/user&apos;, function (req, res) &#123;</span><br><span class="line">  res.send(&apos;Got a DELETE request at /user&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>​         </p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Web</category>
        <category>Express</category>
      </categories>
      <tags>
        <tag>express</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>vs code 使用记录</title>
    <url>/posts/5181edb9.html</url>
    <content><![CDATA[<blockquote>
<p>使用 <code>vs code</code> 将近一年时间了，开始搭本地 C++ 环境真的是折磨，不过弄好之后就真香了，写这篇文章主要是记录以下几点：</p>
<ul>
<li>vs code 常用快捷键（windows）</li>
<li>常用的插件</li>
<li>使用心得</li>
</ul>
</blockquote>
<p>​          </p>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul>
<li>格式化代码<ul>
<li>windows ：<code>Shift + Alt + F</code></li>
</ul>
</li>
</ul>
<p>​           </p>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><ul>
<li><strong>翻译(translate to chinese)</strong>：使用百度翻译API把其他语言翻译成中文，快捷键是 <code>ctrl+shift.t</code>。</li>
</ul>
<p>​          </p>
]]></content>
      <categories>
        <category>日常技巧</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>vs code</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5音频API Web Audio - 分析音频资源</title>
    <url>/posts/26f946b3.html</url>
    <content><![CDATA[<p>前面有认真介绍 <a href="https://wiki.hushhw.cn/posts/908137cb.html">Web Audio Api</a> 的相关知识，本文得先回顾前面的脉络结构后再往后走。</p>
<p>开局一张图，再次祭出老师的 PPT：</p>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-03-06_20-33-24.png" alt="imooc"></p>
<p>在 <strong>AudioContext</strong> 音频上下文中，把音频文件转成 <strong>buffer</strong> 格式存为 <strong>AudioBufferSourceNode</strong> ，前面是直接链接给 <strong>GainNode</strong> 控制音量，现在我们要分析音乐的一些特性，所以要改成先链接给 <strong>AnalyserNode</strong> ，最后到达 <strong>destination</strong> 输出音乐。这里形成了一个音频通道，每个模块通过 <strong>connect</strong> 方法链接并传送音频。</p>
<p>本文就从 <strong>AnalyserNode</strong> 开始介绍。</p>
<p>​              </p>
<h2 id="AnalyserNode"><a href="#AnalyserNode" class="headerlink" title="AnalyserNode"></a>AnalyserNode</h2><p><strong>AnalyserNode</strong> 赋予了节点可以提供实时频率及时间域分析的信息，它使一个 <strong>AudioNode</strong> 通过音频流不做修改的从输入到输出，但允许你获取生成的数据，处理它并创建音频可视化。</p>
<p><strong>AnalyzerNode</strong> 只有一个输入和输出，即使未连接输出它也会工作。</p>
<p><img src="https://photo.hushhw.cn/images/WebAudioFFT.png" alt></p>
<p>首先创建方法见上一篇中 <strong>AudioContext</strong> 中的方法来创建：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> analyser = ac.createAnalyser();</span><br></pre></td></tr></table></figure>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ol>
<li><strong>AnalyserNode.fftSize</strong> ：设置 FFT（FFT 是离散傅里叶变换的快速算法，用于将一个信号变换到频域）值的大小，用于分析得到频域，必须是从 32 ~ 32768 范围内的 2 的非零幂，默认为2048。</li>
<li><strong>AnalyserNode.frequencyBinCount</strong> ：值固定为 <strong>fftSize</strong> 值的一半，该属性通常用于可视化的数据值的数量。</li>
<li><strong>AnalyserNode.smoothingTimeConstant</strong> ：是一个双精度浮点型(double)的值，表示最后一个分析帧的平均常数。它基本上是当前缓冲区和 AnalyserNode 处理的最后一个缓冲区之间的平均值，并导致在值变化时随着时间推移得到一个更平滑的集合。默认值为 0.8，值的范围必须在  0 ~ 1 之间。</li>
</ol>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><strong>AnalyserNode.getByteFrequencyData()</strong> ：将当前频率数据（数量是 <strong>frequencyBinCount</strong>）复制到 Uint8Array（无符号字节数组）中。</p>
<p>​               </p>
<p>具体实现代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> analyser = ac.createAnalyser();</span><br><span class="line">analyser.fftSize = <span class="number">512</span>;</span><br><span class="line">analyser.connect(gainNode);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">visualizer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(analyser.frequencyBinCount);</span><br><span class="line">    analyser.getByteFrequencyData(arr);</span><br><span class="line">    <span class="built_in">console</span>.log(arr); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以打印出分析到的音频开始播放的第一时刻的数据，要想实时的打印出数据，需要用到 <strong>requestAnimationFrame</strong> 去反复收集当前音频的频率数据，具体可以参看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame" target="_blank" rel="noopener">MDN</a> 官网对该方法的介绍。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">visualizer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(analyser.frequencyBinCount);</span><br><span class="line">    requestAnimationFrame = <span class="built_in">window</span>.requestAnimationFrame ||</span><br><span class="line">                            <span class="built_in">window</span>.webkitRequestAnimationFrame ||</span><br><span class="line">                            <span class="built_in">window</span>.mozRequestAnimationFrame;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">v</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        analyser.getByteFrequencyData(arr);</span><br><span class="line">        <span class="built_in">console</span>.log(arr);</span><br><span class="line">        requestAnimationFrame(v);</span><br><span class="line">    &#125;</span><br><span class="line">    requestAnimationFrame(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就拿到了实时音频的频率数据，下面我们就利用这些数据来实现音乐的可视化。</p>
<p>​            </p>
<blockquote>
<p>参考：</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API" target="_blank" rel="noopener">Web API 接口参考</a></p>
<p><a href="https://www.imooc.com/learn/299" target="_blank" rel="noopener">HTML5音乐可视化视频课程</a></p>
</blockquote>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Web</category>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
        <tag>音乐可视化</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5音频API Web Audio</title>
    <url>/posts/908137cb.html</url>
    <content><![CDATA[<p>因为毕业设计要做音乐可视化的相关项目，所以必须要弄清楚 HTML 5 的音频 API —— Web Audio。</p>
<p>初看官方文档时发现音频处理模块太多了，只能一边用一边学，所以先去跟着慕课网上的课程『<a href="https://www.imooc.com/video/5972" target="_blank" rel="noopener">HTML5音乐可视化</a> 』走，慢慢研究这里面的架构。</p>
<p>下图是老师画的『Web Audio API 关系图』：</p>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-03-06_20-33-24.png" alt="imooc"></p>
<p>本篇文章就基于这张图来了解 Web Audio API。</p>
<p>​           </p>
<h2 id="ajax-请求获取音频资源数据"><a href="#ajax-请求获取音频资源数据" class="headerlink" title="ajax 请求获取音频资源数据"></a>ajax 请求获取音频资源数据</h2><p>使用 <strong>ajax</strong> 请求获取音频资源数据时使用 <strong>XMLHttpRequest</strong> (XHR) 对象可以与服务器交互。使用前先调用其构造函数来初始化一个 <strong>XMLHttpRequest</strong> 对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br></pre></td></tr></table></figure>
<p>这里再介绍几个用到的<code>属性</code>和<code>方法</code>：</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p><strong>XMLHttpRequest.responseType</strong> ：是一个枚举类型的属性，返回响应数据的类型。它允许我们手动的设置返回数据的类型。如果我们将它设置为一个空字符串，它将使用默认的”text”类型。这里我们返回的类型为 <code>arraybuffer</code> ，是一个包含二进制数据的 JavaScript <strong>ArrayBuffer</strong>（ ArrayBuffer 对象用来表示通用的、固定长度的原始二进制数据缓冲区）。</p>
<p><strong>XMLHttpRequest.response</strong> ：返回 ArrayBuffer、Blob、Document、DOMString，具体是哪种类型取决于<strong>XMLHttpRequest.responseType</strong> 值。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><strong>XMLHttpRequest.abort()</strong> ：如果请求已经被发送,则立刻中止请求。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">    xhr.abort();</span><br><span class="line">    xhr.open(<span class="string">"GET"</span>, url); </span><br><span class="line">    xhr.responseType = <span class="string">"arraybuffer"</span>;</span><br><span class="line">    xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(xhr.response);</span><br><span class="line">        &#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​           </p>
<h2 id="AudioContext"><a href="#AudioContext" class="headerlink" title="AudioContext"></a>AudioContext</h2><p><strong>AudioContext</strong> 是一个音频上下文，所有的音频在这个音频上下文中处理。就好像 webGL 中最开始要定义一个『绘图上下文』，然后使用绘图上下文调用相应的绘图函数。</p>
<p>简单声明：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> audioCtx = <span class="keyword">new</span> AudioContext;</span><br></pre></td></tr></table></figure>
<p>跨浏览器的方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> audioCtx = <span class="keyword">new</span>(<span class="built_in">window</span>.AudioContext || <span class="built_in">window</span>.webkitAudioContext)();</span><br></pre></td></tr></table></figure>
<p><strong>AudioContext</strong> 音频上下文提供了很多属性和方法，用于创建各种音频源和音频处理模块等，这里只介绍一部分用到的。</p>
<h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><p><strong>AudioContext.destination</strong> ：返回 <strong><a href="#AudioDestinationNode">AudioDestinationNode</a></strong> 对象，表示当前 <strong>AudioContext</strong> 中所有节点的最终节点，一般表示音频渲染设备。</p>
<p><strong>AudioContext.currentTime</strong> ：以双精度浮点型数字返回硬件调用的秒数，<strong>AudioContext</strong> 一创建就从0开始走，无法停掉、暂停或者重置。</p>
<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><ol>
<li><strong>AudioContext.createBufferSource()</strong> ：创建一个 <strong><a href="#AudioBufferSourceNode">AudioBufferSourceNode</a></strong> 对象，他可以通过 <strong>AudioBuffer</strong> 对象来播放和处理包含在内的音频数据。</li>
</ol>
<ol>
<li><strong>AudioContext.createGain()</strong> ：创建一个 <strong><a href="#GainNode">GainNode</a></strong>,它可以控制音频的总音量。</li>
</ol>
<ol>
<li><strong>AudioContext.createAnalyser()</strong> ：创建一个 <strong>AnalyserNode</strong>，它可以用来显示音频时间和频率的数据。</li>
</ol>
<ol>
<li><strong>AudioContext.decodeAudioData(audioData, function(decodedData)</strong> ：异步解码音频文件中的 <strong>ArrayBuffer</strong>，这里的 <strong>ArrayBuffer</strong> 通过前面的 <strong>XMLHttpRequest</strong> 获得。</li>
</ol>
<p>​           </p>
<h2 id="AudioBufferSourceNode"><a href="#AudioBufferSourceNode" class="headerlink" title="AudioBufferSourceNode"></a>AudioBufferSourceNode</h2><p>表示内存中的一段音频资源，其音频数据存在于 <strong>AudioBuffer</strong> 对象中。可以通过上面提到的 <strong>AudioContext.createBufferSource()</strong> 来创建：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bufferSource = ac.createBufferSource();</span><br></pre></td></tr></table></figure>
<h3 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h3><ol>
<li><strong>AudioBufferSourceNode.buffer</strong> ：是一个 <strong>AudioBuffer</strong> 对象，表示要播放的音频资源数据，前面通过 <strong>decodeAudioData()</strong> 方法将 <strong>ArrayBuffer</strong> 进行异步解码，当成功解码PCM Data后通过回调返回，将返回的结果即赋值给这里的 <strong>buffer</strong> 。<ol>
<li>子属性 <strong>duration</strong> 表示该音频资源的时长（秒）</li>
</ol>
</li>
<li><strong>AudioBufferSourceNode.loop</strong> ：是否循环播放，默认 false</li>
</ol>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p><strong>AudioBufferSourceNode.onended</strong> ：可绑定音频播放完毕时调用的事件处理程序</p>
<h3 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h3><ol>
<li><strong>start/noteOn([when], [offset], [duration])</strong> ：开始播放音频。<ol>
<li>when = ac.currentTime ，表示何时开始播放；</li>
<li>offset = 0 ，表示从音频的第几秒开始播放；</li>
<li>duration = buffer.duration-offset ，表示播放几秒。</li>
</ol>
</li>
<li><strong>stop/noteOff([when])</strong> ：结束播放音频<ol>
<li>when = ac.currentTime ，表示何时结束播放。</li>
</ol>
</li>
</ol>
<p>前面代码汇总：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="keyword">var</span> ac = <span class="keyword">new</span> (<span class="built_in">window</span>.AudioContext||<span class="built_in">window</span>.webitAudioContext)(); </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">    xhr.open(<span class="string">"GET"</span>, url); </span><br><span class="line">    xhr.responseType = <span class="string">"arraybuffer"</span>; </span><br><span class="line">    xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        ac.decodeAudioData(xhr.response, <span class="function"><span class="keyword">function</span>(<span class="params">buffer</span>)</span>&#123; </span><br><span class="line">            <span class="keyword">if</span>(n != count) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">var</span> bufferSource = ac.createBufferSource(); </span><br><span class="line">            bufferSource.buffer = buffer; </span><br><span class="line">            bufferSource[bufferSource.start?<span class="string">"start"</span>:<span class="string">"noteOn"</span>](<span class="number">0</span>);</span><br><span class="line">        &#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​           </p>
<h2 id="GainNode"><a href="#GainNode" class="headerlink" title="GainNode"></a>GainNode</h2><p><strong>GainNode</strong> 接口表示音量变更，通过前面提到的 <strong>AudioContext.createGain()</strong> 进行创建：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gainNode = ac[ac.createGain?<span class="string">"createGain"</span>:<span class="string">"createGainNode"</span>]();</span><br></pre></td></tr></table></figure>
<p>根据前面的关系图，需要把 <strong>AudioBufferSourceNode</strong> 连接到 <strong>GainNode</strong> ：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">bufferSource.connect(gainNode);</span><br></pre></td></tr></table></figure>
<p>下面是控制音量的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeVolume</span>(<span class="params">percent</span>)</span>&#123;</span><br><span class="line">    gainNode.gain.value = percent * percent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$(<span class="string">"#volume"</span>)[<span class="number">0</span>].onchange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    changeVolume(<span class="keyword">this</span>.value/<span class="keyword">this</span>.max);</span><br><span class="line">&#125;</span><br><span class="line">$(<span class="string">"#volume"</span>)[<span class="number">0</span>].onchange();</span><br></pre></td></tr></table></figure>
<p>​           </p>
<h2 id="AudioDestinationNode"><a href="#AudioDestinationNode" class="headerlink" title="AudioDestinationNode"></a>AudioDestinationNode</h2><p>前面提到的 <strong>AudioContext.destination</strong> ，返回 <strong>AudioDestinationNode</strong> 对象，表示当前 audio context 中所有节点的最终节点，一般表示音频渲染设备。</p>
<p>根据关系图，最终要连接给 <strong>destination</strong> 才可以实现音乐的播放。</p>
<p>​          </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，思路就很清晰了，按照关系图一步一步走下来，在 <strong>AudioContext</strong> 音频上下文中，把音频文件转成 <strong>buffer</strong> 格式存为 <strong>AudioBufferSourceNode</strong> ，链接给 <strong>GainNode</strong> 控制音量，最后到达 <strong>destination</strong> 输出音乐。这里形成了一个音频通道，每个模块通过 <strong>connect</strong> 方法链接并传送音频。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="keyword">var</span> ac = <span class="keyword">new</span> (<span class="built_in">window</span>.AudioContext||<span class="built_in">window</span>.webitAudioContext)(); </span><br><span class="line"><span class="keyword">var</span> gainNode = ac[ac.createGain?<span class="string">"createGain"</span>:<span class="string">"createGainNode"</span>]();</span><br><span class="line">gainNode.connect(ac.destination);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> source = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = ++count;</span><br><span class="line">    source &amp;&amp; source[source.stop ? <span class="string">"stop"</span> : <span class="string">"noteOff"</span>]();</span><br><span class="line">    xhr.abort(); </span><br><span class="line">    xhr.open(<span class="string">"GET"</span>, url); </span><br><span class="line">    xhr.responseType = <span class="string">"arraybuffer"</span>; </span><br><span class="line">    xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n != count) <span class="keyword">return</span>;</span><br><span class="line">        ac.decodeAudioData(xhr.response, <span class="function"><span class="keyword">function</span>(<span class="params">buffer</span>)</span>&#123; </span><br><span class="line">            <span class="keyword">if</span>(n != count) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">var</span> bufferSource = ac.createBufferSource(); </span><br><span class="line">            bufferSource.buffer = buffer; </span><br><span class="line">            bufferSource.connect(gainNode);</span><br><span class="line">            bufferSource[bufferSource.start?<span class="string">"start"</span>:<span class="string">"noteOn"</span>](<span class="number">0</span>);</span><br><span class="line">            </span><br><span class="line">            source = bufferSource;</span><br><span class="line">        &#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.send();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeVolume</span>(<span class="params">percent</span>)</span>&#123;</span><br><span class="line">    gainNode.gain.value = percent * percent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$(<span class="string">"#volume"</span>)[<span class="number">0</span>].onchange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    changeVolume(<span class="keyword">this</span>.value/<span class="keyword">this</span>.max);</span><br><span class="line">&#125;</span><br><span class="line">$(<span class="string">"#volume"</span>)[<span class="number">0</span>].onchange();</span><br></pre></td></tr></table></figure>
<p>中间省略了 <strong>analyserNode</strong> 留在后面写可视化的时候再展开。</p>
<p>​       </p>
<blockquote>
<p>参考：</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API" target="_blank" rel="noopener">Web API 接口参考</a></p>
<p><a href="https://www.imooc.com/learn/299" target="_blank" rel="noopener">HTML5音乐可视化视频课程</a></p>
</blockquote>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Web</category>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
        <tag>音乐可视化</tag>
      </tags>
  </entry>
  <entry>
    <title>maupassant主题创建Tags页面</title>
    <url>/posts/5e14d0e.html</url>
    <content><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>日常折腾博客的我又上线了，这次改造的是『Tags页面』，之前使用<code>next</code>主题时默认是有<code>tags</code>页面的，但是现在用的主题没有，前段时间做右侧<code>about</code>模块时要点击标签跳转到<code>/tags</code>页面就做了个很简陋的<code>tagcloud</code>，今天花时间优化一下。</p>
<p>​      </p>
<h3 id="开始操作"><a href="#开始操作" class="headerlink" title="开始操作"></a>开始操作</h3><h4 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h4><p>在本地<code>source</code>下创建<code>tags</code>文件夹，继续创建<code>index.md</code>文件，填写<code>front-matter</code>如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">layout: tagcloud</span><br><span class="line">title: 标签</span><br><span class="line">date: 2018-02-05 00:43:22</span><br><span class="line">type: tags</span><br><span class="line">comments: true</span><br></pre></td></tr></table></figure>
<ul>
<li><code>layout</code> 对应待会创建的页面模板名，如果取了其他名字后面跟着一起修改。</li>
</ul>
<p>​          </p>
<h4 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h4><p>找到主题目录下的<code>layout</code>文件夹后，在里面创建文件<code>tagcloud.pug</code>，最重要的内容就是这里的代码啦，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extends base</span><br><span class="line">block title</span><br><span class="line">  title= page.title + &apos; | &apos; + config.title</span><br><span class="line">block content</span><br><span class="line">  .post</span><br><span class="line">    .post-content</span><br><span class="line">      .tagcloud</span><br><span class="line">        for tag in site.tags.toArray()</span><br><span class="line">          a( href=&apos;/tags/#&apos; + tag.name title=tag.name rel= tag.length ) #&#123;tag.name&#125;</span><br><span class="line"></span><br><span class="line">      for tag in site.tags.toArray()</span><br><span class="line">        .one-tag-list</span><br><span class="line">          span(class=&apos;fa fa-tag tag-name&apos; id=tag.name) </span><br><span class="line">            span(class=&quot;tag-text&quot;) #&#123;tag.name&#125;</span><br><span class="line">          for post in tag.posts.toArray()</span><br><span class="line">            .post-preview</span><br><span class="line">              a( href=config.root + post.path title=post.title ) #&#123;post.title&#125;</span><br><span class="line"></span><br><span class="line">  if page.donate</span><br><span class="line">      iframe(src=&apos;/donate/?AliPayQR=&apos; + theme.donate.alipay_qr + &apos;&amp;WeChatQR=&apos; + theme.donate.wechat_qr + &apos;&amp;GitHub=&apos; + theme.donate.github + &apos;&amp;BTCQR=&apos; + theme.donate.btc_qr + &apos;&amp;BTCKEY=&apos;+ theme.donate.btc_key + &apos;&amp;PayPal=&apos; + theme.donate.paypal_url, style=&apos;overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;&apos;, frameborder=&apos;0&apos;, scrolling=&apos;no&apos;)</span><br><span class="line">  if page.comments</span><br><span class="line">    include _partial/comments.pug</span><br></pre></td></tr></table></figure>
<p>喜欢折腾的同学可以研究一下这段代码，很好理解，有什么问题可以在评论区告诉我。</p>
<p>​          </p>
<h4 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h4><p>继续编写样式，在<code>style.scss</code>中，定位到<code>.post-content</code>的括号内写入：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.tagcloud</span> &#123;</span><br><span class="line">	<span class="attribute">margin</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">30px</span> <span class="number">0</span>;</span><br><span class="line">	<span class="selector-tag">a</span> &#123;</span><br><span class="line">		<span class="attribute">padding</span>:<span class="number">0px</span> <span class="number">5px</span>;</span><br><span class="line">		<span class="attribute">margin</span>:<span class="number">3px</span>;</span><br><span class="line">		<span class="attribute">display</span>: inline-block;</span><br><span class="line">		<span class="attribute">border</span>: <span class="number">1px</span> solid rgba(<span class="number">99</span>, <span class="number">96</span>, <span class="number">96</span>, <span class="number">0.8</span>);</span><br><span class="line">         <span class="attribute">border-radius</span>: <span class="number">999em</span>;</span><br><span class="line">         <span class="attribute">color</span>: <span class="number">#aaa</span>;</span><br><span class="line">         &amp;<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">			<span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">             <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#1a8d76</span>;</span><br><span class="line">             <span class="attribute">background</span>: <span class="number">#1a8a76</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.one-tag-list</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">30px</span> <span class="number">0</span>;</span><br><span class="line">    <span class="selector-class">.tag-name</span> &#123;</span><br><span class="line">		<span class="selector-class">.tag-text</span>&#123;</span><br><span class="line">			<span class="attribute">margin-left</span>: <span class="number">5px</span>;</span><br><span class="line">             <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">             <span class="attribute">font-weight</span>: bold;</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h4><p>验收成果：</p>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-03-05_15-10-51.png" alt></p>
<p>​       </p>
<h3 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h3><p>前面提到在<code>front-matter</code>中给<code>layout</code>取名可以自定义，后面对应的文件也取相应的名字即可，但是不要取名为<code>tags</code>，这样会和主题冲突，导致所有的<code>tag</code>点击后都被改成现在的样式，而不是<code>archive.pug</code>中的样式。</p>
<p>​          </p>
]]></content>
      <categories>
        <category>建站笔记</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>《编译程序设计原理与技术》笔记之自动机与正规表达式</title>
    <url>/posts/d6cbf625.html</url>
    <content><![CDATA[<blockquote>
<p>本笔记基于北京邮电大学出版的李文生编著的《编译程序设计原理与技术》整理</p>
</blockquote>
<p>​           </p>
<p>有限自动机是具有离散输入与输出的系统的一种数学模型，系统可以处于有限个内部状态的任何一个之中，系统的当前状态概括了有关过去输入的信息，这些信息对于确定系统在以后的输入上的行为是必需的。</p>
<p>有限自动机有『确定的』和『非确定的』两种，所谓『确定的有限自动机』是指在当前状态下，输入一个符合，有限自动机转换到唯一的下一个状态，称为后继状态；而『非确定的有限自动机』是指在当前状态下输入一个符号，可能有两种以上可选择的后继状态，并且非确定的有限自动机所对应的状态转换图可以有标记为 $\epsilon$ 的边。</p>
<p>​         </p>
<p>正则文法可以用状态转换图非形式的进行表示，这就表明正则文法所对应的语言（正则语言）可以用状态转换图来接受（识别）。有限自动机正是对状态转换图进一步形式化的结果。</p>
<h3 id="1-状态转换图"><a href="#1-状态转换图" class="headerlink" title="1. 状态转换图"></a>1. 状态转换图</h3><p>状态转换图是一张有限的方向图，其中：</p>
<ul>
<li>结点代表状态用圆圈表示；</li>
<li>状态之间用有向边连接；</li>
<li>边上的标记表示在射出结点状态下可能出现的输入符号。</li>
</ul>
<p>一张状态转换图只含有有限个状态（即有限个结点），其中有一个称为初始状态，而可以有若干个（可以为0个）终结状态，终态用双圆圈表示。</p>
<p>​          </p>
<h3 id="2-确定的有限自动机（DFA）"><a href="#2-确定的有限自动机（DFA）" class="headerlink" title="2. 确定的有限自动机（DFA）"></a>2. 确定的有限自动机（DFA）</h3><p><strong>定义1.1</strong> 一个确定的有限自动机 <strong>M</strong> （记作：<strong>DFA M</strong>）是一个五元组：</p>
<script type="math/tex; mode=display">
M = ( \sum , Q , q_0 , F, \delta )</script><ul>
<li>$\sum$ ：是一个字母表，他的每个元素称为一个输入符号</li>
<li>$Q$ ：是一个有限的状态集合，每个元素称为一个状态</li>
<li>$q_0 \in Q$ ：$q_0$ 称为初始状态</li>
<li>$F \subseteq Q$ ： $F$ 称为终结状态集合</li>
<li>$\delta$ ：是转换函数，是一个从 $Q \times \sum$ 到 $Q$ 的单值映射</li>
</ul>
<p>转换函数 $\delta(q, a) = q^, （其中 q, q^, \in Q ， a \in \sum）$ 表示当前状态为 $q$，输入符号为 $a$ 时，自动机将转换到下一个状态 $q^,$ ，$q^,$ 称为 $q$ 的一个后继。</p>
<p>若 $Q = { q<em>1, q_2, \cdots , q_n }， \sum = { a_1, a_2, \cdots, a_n }$ ，则 $Q \times \sum = (\delta(q_i, q_j)</em>{n \times m})$ 是一个 n 行 m 列的矩阵，它被称为 DFA M 的状态转换矩阵，也称为转换表。</p>
<p>对 $\sum$ 上的任何符号串 $\omega \in \sum^*$ ，若存在一条从初态结点到终态结点的路径，该路径上每条边的标记连接成的符号串恰好是 $\omega$ ，则称 $\omega$ 为 DFA M 所识别。DFA M 所能识别的符号串的全体记为 $L(M)$ ，称为 DFA M 所识别的语言。</p>
<p>​           </p>
<h3 id="3-非确定的有限自动机（NFA）"><a href="#3-非确定的有限自动机（NFA）" class="headerlink" title="3. 非确定的有限自动机（NFA）"></a>3. 非确定的有限自动机（NFA）</h3><p><strong>定义1.2</strong> 一个非确定的有限自动机 <strong>M</strong> （记作：<strong>NFA M</strong>）是一个五元组：</p>
<script type="math/tex; mode=display">
M = ( \sum , Q , q_0 , F, \delta )</script><ul>
<li>$\sum$ ：是一个字母表，他的每个元素称为一个输入符号</li>
<li>$Q$ ：是一个有限的状态集合，每个元素称为一个状态</li>
<li>$q_0 \in Q$ ：$q_0$ 称为初始状态</li>
<li>$F \subseteq Q$ ： $F$ 称为终结状态集合</li>
<li>$\delta$ ：是一个从 $Q \times \sum$ 到 $Q$ 的子集的映射，即 $\delta \times Q \rightarrow 2^Q$ ，其中 $2^Q$ 是 Q 的幂集，也就是 Q 的所有子集组成的集合。</li>
</ul>
<p>对 $\sum$ 上的任何符号串 $\omega \in \sum^*$ ，若存在一条从初态结点到终态结点的路径，该路径上每条边的标记连接成的符号串恰好是 $\omega$ ，则称 $\omega$ 为 NFA M 所识别。NFA M 所能识别的符号串的全体记为 $L(M)$ ，称为 NFA M 所识别的语言。</p>
<p><img src="https://photo.hushhw.cn/images/IMG_20190306_105132.jpg" alt></p>
<p>​         </p>
<h3 id="4-具有-epsilon-转移的非确定的有限自动机"><a href="#4-具有-epsilon-转移的非确定的有限自动机" class="headerlink" title="4. 具有 $\epsilon$ - 转移的非确定的有限自动机"></a>4. 具有 $\epsilon$ - 转移的非确定的有限自动机</h3><p>如果状态转换图中有标记为 $\epsilon$ 的边，则无法用前面的定义描述因而需要扩充 NFA 的概念。</p>
<p><strong>定义1.3</strong> 一个具有 $\epsilon$ - 转移的非确定的有限自动机 <strong>M</strong> （记作：<strong>NFA M</strong>）是一个五元组：</p>
<script type="math/tex; mode=display">
M = ( \sum , Q , q_0 , F, \delta )</script><ul>
<li>$\sum$ ：是一个字母表，他的每个元素称为一个输入符号</li>
<li>$Q$ ：是一个有限的状态集合，每个元素称为一个状态</li>
<li>$q_0 \in Q$ ：$q_0$ 称为初始状态</li>
<li>$F \subseteq Q$ ： $F$ 称为终结状态集合</li>
<li>$\delta$ ：是一个从 $Q \times (\sum \cup { \epsilon } )$ 到 $Q$ 的子集的映射，即 $\delta : Q( \sum\cup { \epsilon } ) \rightarrow 2^Q$ ，其中 $2^Q$ 是 Q 的幂集，也就是 Q 的所有子集组成的集合。</li>
</ul>
<p>对 $\sum$ 上的任何符号串 $\omega \in \sum^*$ ，若存在一条从初态结点到终态结点的路径，该路径上每条边的标记连接成的符号串恰好是 $\omega$ ，则称 $\omega$ 为 NFA M 所识别。NFA M 所能识别的符号串的全体记为 $L(M)$ ，称为 NFA M 所识别的语言。</p>
<p><img src="https://photo.hushhw.cn/images/IMG_20190306_131438.jpg" alt></p>
<p>​        </p>
<h3 id="5-非确定的有限自动机的确定化"><a href="#5-非确定的有限自动机的确定化" class="headerlink" title="5. 非确定的有限自动机的确定化"></a>5. 非确定的有限自动机的确定化</h3><p><strong>定理 1.1</strong> 对任意一个 NFA M，都存在一个与之等价的 DFA D，即 L(M) = L(D)。</p>
<p><strong>定理 1.2</strong> 对任何一个具有 $\epsilon$ - 转移的 NFA M，都存在一个等价的不具有 $\epsilon - $ 转移的 NFA N。</p>
<p><strong>推论 1</strong> 对任何一个具有 $\epsilon$ - 转移的 NFA M，都存在一个与之等价的 DFA D。</p>
<p>下面研究『非确定的有限自动机的确定化』，由 NFA 构造等价的 DFA 。</p>
<p>因为 DFA D 的每一个状态对应于 NFA M 的一个状态子集，所以构造状态转换表 DTT 时，对给定的输入符号串，使 D 『并行地』模拟 M 所能产生的所有可能的转换，令 q 为 NFA M 的状态，T 为 NFA M 的状态子集，引入以下操作：</p>
<ul>
<li>ε-闭包：<ul>
<li>ϵ_closure(q) 表示从 q 出发，经过 $\epsilon$ - 道路可以到达状态 $q^,$  。</li>
<li>ϵ_closure(T) = $\stackrel{n}{\underset{i = i}\cup}$ ϵ_closure$(q_i)$ 其中 $q_i \in T$ ，表示 T 中任一状态出发，经过 $\epsilon$ - 道路后可以到达的状态集合。 </li>
</ul>
</li>
<li>求 T 的 a 弧转换：<ul>
<li>$move(T, a)$ 表示从某个状态 $q_i \in T$ 出发，经过输入符号 a 之后可到达的状态的集合。</li>
</ul>
</li>
</ul>
<p>​          </p>
<p>例如下图这个 NFA N：</p>
<p><img src="https://photo.hushhw.cn/images/nfa.jpg" alt></p>
<p>它是一个具有 $\epsilon$ - 转移的非确定的有限自动机 N ，是一个五元组：$ N= ( \sum , Q , q_0 , F, \delta )$ ，即为<code>(弧集合，状态集合，初始状态，终结状态集合，转换函数)</code>，所以由图可知：<code>NFA N = ({a,b}, {0,1,2,3,4,5,6,7,8,9,10}, {0}, {10}, δ)</code>。</p>
<p>假定 DFA D 的初态为 A，则 A = ϵ_closure(0) = { 0, 1, 2, 4, 7}。</p>
<p>从初态 A 出发，构造 DFA D 的其余状态如下：</p>
<p>DTT[A, a] = ϵ_closure(move(A, a)) = ϵ_closure({3, 8}) = {1, 2, 3, 4, 6, 7, 8} = B</p>
<p>DTT[A, b] = ϵ_closure(move(A, b)) = ϵ_closure(5) = {1, 2, 4, 5, 6, 7} = C</p>
<p>DTT[B, a] = ϵ_closure(move(B, a)) = ϵ_closure({3, 8}) = B</p>
<p>DTT[B, b] = ϵ_closure(move(B, b)) = ϵ_closure({5, 9}) = {1, 2, 4, 5, 6, 7, 9} = D</p>
<p>DTT[C, a] = ϵ_closure(move(C, a)) = ϵ_closure({3, 8}) = B</p>
<p>DTT[C, b] = ϵ_closure(move(C, b)) = ϵ_closure(5) = C</p>
<p>DTT[D, a] = ϵ_closure(move(D, a)) = ϵ_closure({3, 8}) = B</p>
<p>DTT[D, b] = ϵ_closure(move(D, b)) = ϵ_closure({5, 10} = {1, 2, 4, 5, 6, 7, 10} = E</p>
<p>DTT[E, a] = ϵ_closure(move(D, a)) = ϵ_closure({3, 8}) = B</p>
<p>DTT[E, b] = ϵ_closure(move(E, b)) = ϵ_closure(5) = C</p>
<p>至此，不再有新的状态出现，构造过程结束。</p>
<p>共构造了 5 个状态，即 A、B、C、D、E，其中 A 为初态，E 为终态，因为 E 的状态集合中包括原 NFA N 的终态 10。</p>
<p>可以借助表格来观察整个求解过程，每次求解后如果产生新集合，就会记录下来继续算，直到没有新集合为止。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">ε_closure(move(T,a))</th>
<th style="text-align:center">ε_closure(move(T,b))</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">B</td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">B</td>
<td style="text-align:center">B</td>
<td style="text-align:center">D</td>
</tr>
<tr>
<td style="text-align:center">C</td>
<td style="text-align:center">B</td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">D</td>
<td style="text-align:center">B</td>
<td style="text-align:center">E</td>
</tr>
<tr>
<td style="text-align:center">E</td>
<td style="text-align:center">B</td>
<td style="text-align:center">C</td>
</tr>
</tbody>
</table>
</div>
<p>最终状态转换图如下：</p>
<p><img src="https://photo.hushhw.cn/images/nfa_dfa_4.png" alt></p>
<p>此 DFA D 识别的语言同样为 $L(D) = { (a|b)^*abb}$ ，由此可知构造出来的 DFA D 与 NFA N 是等价的。</p>
<p>​            </p>
<h3 id="6-DFA-的化简"><a href="#6-DFA-的化简" class="headerlink" title="6. DFA 的化简"></a>6. DFA 的化简</h3><p><strong>无关状态</strong>：</p>
<ul>
<li><strong>多余状态</strong>：从初态出发到达不了的状态。</li>
<li><strong>死状态</strong>：从该状态无法到达终态</li>
</ul>
<p>去掉这些无关状态之后得到的等价的状态转换图，它们的 $L(S_i) = L(S_j)$，称它们为<strong>等价状态</strong>，否则称它们为<strong>可区分状态</strong>。</p>
<p>DFA的化简步骤举一个『栗子』来学习一下：</p>
<p>我们把前面确定化的 DFA N 在进行一次化简：</p>
<p><img src="https://photo.hushhw.cn/images/nfa_dfa_4.png" alt></p>
<p>第一步：把 DFA N 的状态集合划分为子集，使每个子集中的状态相互等价，不同子集中的状态相互等价，不同子集中的状态可区分。</p>
<ul>
<li><p>首先，把 DFA N 的状态集合划分为两个子集：终态子集 {4} 和非终态子集 {0, 1, 2, 3}。由于终态子集只含有一个状态 4，固不可再分。</p>
</li>
<li><p>然后考察非终态子集 {0, 1, 2, 3}。</p>
<ul>
<li>对于输入符号 a，状态 0 ~ 3 都转换到状态 1，所以对于输入符号 a 而言，该子集不能再划分。</li>
<li>对于输入符号 b，状态 0，1，2都转换到子集 {0, 1, 2, 3} 中的一个状态，而状态 3 则转换到状态子集 {4} 中的状态。所以应该把子集 {0, 1, 2, 3} 划分为两个新的子集 {0, 1, 2} 和 {3}。</li>
</ul>
<p>这时，DFA N 的状态集合被划分为三个子集，即 {0, 1, 2} 、{3}、{4}。</p>
</li>
<li><p>其次，考察子集 {0, 1, 2}。</p>
<ul>
<li>对于输入符号 a，状态 0 ~ 2 都转换到状态 1，所以对于输入符号 a 而言，该子集不能再划分。</li>
<li>对于输入符号 b，状态 0，2 都转换状态 2，而状态 1 则转换到状态 3。由于 1 和 3 分属于不同的状态子集，所以应该把子集 {0, 1, 2} 划分为两个新的子集 {0, 2} 和 {1}。</li>
</ul>
<p>这时，DFA N 的状态集合被划分为四个子集，即 {0, 2} 、{1}、{3}、{4}。</p>
</li>
<li><p>最后，考察子集 {0, 2}。</p>
<ul>
<li>对于输入符号 a，状态 0 和 2 都转换到状态 1，所以对于输入符号 a 而言，该子集不能再划分。</li>
<li>对于输入符号 b，状态 0 和 2 都转换到状态 2，所以对于输入符号 b 而言，该子集不能再划分。</li>
</ul>
<p>于是，DFA N 的状态集合最终被划分为四个子集，即 {0, 2} 、{1}、{3}、{4}。</p>
</li>
</ul>
<p>第二步：为每个子集选择一个代表状态。选择 0 为子集 {0, 2} 的代表状态，由于其余子集都只有一个状态，故状态 1，2，3 为它们的代表状态。</p>
<p>至此，画出 DFA N’ 状态转换表和状态转换图。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">状态</th>
<th style="text-align:center">a</th>
<th style="text-align:center">b</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0(初态)</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">3（终态）</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://photo.hushhw.cn/images/dfa.png" alt></p>
<p>​           </p>
<h3 id="7-正规表达式"><a href="#7-正规表达式" class="headerlink" title="7. 正规表达式"></a>7. 正规表达式</h3><p>用正规表达式可以精确的定义集合，定义 Pascal 语言标识符的正规表达式：$letter(letter|digit)^*$</p>
<p>对于字符表 $\sum$ 上对正规表达式有如下定义：</p>
<ul>
<li>$\epsilon$ 是正规表达式，它表示的语言是 ${\epsilon}$</li>
<li>如果 $a\in\sum$ ，则 a 是正规表达式，它表示的语言是 {a}</li>
<li>如果 r 和 s 都是正规表达式，它标识的语言是 L(r) 和 L(s)，则：<ul>
<li>$(r)|(s)$ 是正规表达式，表示的语言是 $L(r)\cup L(s)$</li>
<li>$(r)(s)$ 是正规表达式，表示的语言是 $L(r)L(s)$</li>
<li>$(r)^+$ 是正规表达式，表示的语言是 $(L(r))^+$</li>
<li>$(r)$ 是正规表达式，表示的语言是 $L(r)$</li>
</ul>
</li>
</ul>
<p>正规表达式表示的语言叫做<strong>正规集</strong>。</p>
<p>正规表达式的书写约定：</p>
<ul>
<li>一元闭包 * 具有最高优先级，并且遵从左结合</li>
<li>连接运算的优先级次之，遵从左结合</li>
<li>并运算 | 的优先级最低，遵从左结合</li>
</ul>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-03-12_19-45-08.png" alt></p>
<p>正规表达式遵从的代数定律：</p>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-03-12_19-47-07.png" alt></p>
<p>​        </p>
<h3 id="8-正规表达式与有限自动机的等价性"><a href="#8-正规表达式与有限自动机的等价性" class="headerlink" title="8. 正规表达式与有限自动机的等价性"></a>8. 正规表达式与有限自动机的等价性</h3><p>对任何一个正规表达式 r，都存在一个 FA M，使 L(r) = L(M)，反之亦然。</p>
<h4 id="8-1-正则表达式转-NFA"><a href="#8-1-正则表达式转-NFA" class="headerlink" title="8.1. 正则表达式转 NFA"></a>8.1. 正则表达式转 NFA</h4><p>转换规则如图，对正规表达式 r 进行分裂、加入新的结点，知道每条边的标记都为基本符号为止。</p>
<p><img src="https://photo.hushhw.cn/images/IMG_20190310_105743.jpg" alt></p>
<p>举个『栗子』：有正规表达式 $(a|b)^*abb$ ，为之构造等价的 NFA。</p>
<p>首先为该正则表达式构造拓广转换图，然后根据该正则表达式的构成依据上图的转换规则，对表达式进行分裂，知道每条边的标记都是 $\sum$ 上的符号或 $\epsilon$ 为止，即得到与该正规表达式等价的 NFA。</p>
<p><img src="https://photo.hushhw.cn/images/IMG_20190310_105750.jpg" alt></p>
<h4 id="8-2-NFA-转正则表达式"><a href="#8-2-NFA-转正则表达式" class="headerlink" title="8.2. NFA 转正则表达式"></a>8.2. NFA 转正则表达式</h4><p>转换规则如图，逐步消去 N 中的中间结点，直到只剩下结点 i 和 f 为止。在消去结点的过程中，逐步用较复杂的正规表达式来标记有向边。</p>
<p><img src="https://photo.hushhw.cn/images/IMG_20190310_105808.jpg" alt></p>
<p>举个『栗子』：有如下的 NFA M，试构造与之等价的正规表达式 r。</p>
<p><img src="https://photo.hushhw.cn/images/IMG_20190310_105825.jpg" alt></p>
<p>由于该 NFA M 仅有一个初态和一个终态，故不用增加新的结点，可直接从 NFA M 出发，反复利用替换规则，逐步消去中间结点，直到只剩下初态 0 和终态 7 为止，则从 0 到 7 的有向边的标记即所求正则表达式，过程如图：</p>
<p><img src="https://photo.hushhw.cn/images/IMG_20190310_105832.jpg" alt></p>
]]></content>
      <categories>
        <category>笔记整理</category>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
        <tag>复习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>《编译程序设计原理与技术》笔记之形式语言和文法</title>
    <url>/posts/8d77b2e4.html</url>
    <content><![CDATA[<blockquote>
<p>本笔记基于北京邮电大学出版的李文生编著的《编译程序设计原理与技术》整理</p>
</blockquote>
<p>​         </p>
<h3 id="1-字母表和符号串"><a href="#1-字母表和符号串" class="headerlink" title="1. 字母表和符号串"></a>1. 字母表和符号串</h3><p><strong>字母表</strong>：符号的非空有限集合。如集合 <code>{0, 1}</code> 是二进制数的字母表、ASCII 字符集和 EBCDIC 字符集等。</p>
<p><strong>符号串</strong>：字母表中的符号组成的有限符号序列。在语言理论中，“句子”和“字”常常作为“符号串”的同义词。</p>
<ul>
<li>空符号串：不含任何符号的符号串，用 $\epsilon$ 表示。</li>
<li>符号串的一些相关概念：长度、前缀、后缀、子串、真前缀、真后缀、真子串</li>
<li>符号串的一些运算：<ul>
<li>符号串的连接：符号串 x 和 y 的连接，是将符号串 y 连接在符号串 x 后面而组成的新符号串，用 xy 表示。</li>
<li>符号串的幂运算：$x^0 = ε$ , $x^1 = x$ , $x^2 = xx$ , $\dots$ , $x^n = x \dots x(n个)$ </li>
</ul>
</li>
</ul>
<p><strong>术语语言</strong>：在某一确定字母表上的符号串的集合。</p>
<ul>
<li>语言的乘积运算：符号串集合 $A =  { aa, bb } ，B = {cc, dd }$ ，则 $AB =  { aacc, aadd, bbcc, bbdd }$。</li>
<li>语言的幂运算：$A^0 =  {ε}，A^1 = A, \dots , A^n = AA \dots\ A(n个) = AA^{n-1}$ </li>
<li>语言的闭包：<ul>
<li>A 的正闭包（ 1 次或若干次连接）： $A^+ = A^1 \cup\ A^2 \cup\ \dots $ </li>
<li>A 的 Kleene 闭包（ 0 次或若干次连接）：$A^* = A^0 \cup\ A^1 \cup\ A^2 \cup\ \dots $ </li>
</ul>
</li>
</ul>
<p>​         </p>
<p>​            </p>
<h3 id="2-文法"><a href="#2-文法" class="headerlink" title="2. 文法"></a>2. 文法</h3><p><strong>文法（Grammar）</strong>：描述语言结构的形式规则。</p>
<h4 id="2-1-文法的形式定义"><a href="#2-1-文法的形式定义" class="headerlink" title="2.1. 文法的形式定义"></a>2.1. 文法的形式定义</h4><p>任何一个文法都可以表示为一个四元组 $G=(V_T, V_N, S, φ)$ ，其中：</p>
<ul>
<li>$V_T$ 是一个非空的有限集合，它的每个元素称为<code>终结符号</code>。</li>
<li>$ V_N$ 是一个非空的有限集合，它的每个元素称为<code>非终结符号</code>。<ul>
<li>$V_T∩V_N = \phi$ ，即 $Y_T$ 与 $V_T$ 的交集为空。</li>
</ul>
</li>
<li>$S$ 是一个特殊的非终结符号，称为文法的<code>开始符号</code>。</li>
<li>$φ$ 是一个非空的有限集合，它的每个元素称为<code>产生式</code>。</li>
<li>产生式（或规则）的形式为：$\alpha \rightarrow \beta$ <ul>
<li>$\alpha$ 称为产生式的左部符号</li>
<li>$\beta$ 称为产生式的右部符号</li>
<li>其中 $\rightarrow$ 表示『定义为』或『由……组成』，$\alpha 、\beta \in ( V_T \cup V_N)^*，\alpha \neq \epsilon$ ，即 $\alpha 、\beta$ 是由终结符号和非终结符号组成的字符串。</li>
</ul>
</li>
<li>开始符号 $S$ 至少必须在某个产生式的左部出现一次。</li>
<li>文法也可只用产生式集合表示。</li>
</ul>
<p>​           </p>
<h4 id="2-2-文法的分类"><a href="#2-2-文法的分类" class="headerlink" title="2.2. 文法的分类"></a>2.2. 文法的分类</h4><p>根据对产生式施加的限制不同，定义了四类文法和相应的四种形式语言类：<br><img src="https://photo.hushhw.cn/images/Snipaste_2019-03-03_17-04-18.png" alt><br>​           </p>
<h4 id="2-3-上下文无关文法及相应的语言"><a href="#2-3-上下文无关文法及相应的语言" class="headerlink" title="2.3. 上下文无关文法及相应的语言"></a>2.3. 上下文无关文法及相应的语言</h4><p>所谓<code>上下文无关文法</code>是指它所定义的语法单位（或称语法实体）完全独立于这种语法单位可能出现的上下文环境。对于现有的程序设计语言来说，许多语法单位的构造中具有固定的递归结构，这样的结构可以用上下文无关文法来描述。</p>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-03-03_19-15-23.png" alt></p>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-03-03_19-20-28.png" alt></p>
<p>这里语言L(G)是所有包括加、减、乘、除四则运算的算术表达式的集合。</p>
<p>​         </p>
<h4 id="2-4-文法书写规定"><a href="#2-4-文法书写规定" class="headerlink" title="2.4. 文法书写规定"></a>2.4. 文法书写规定</h4><p>终结符号</p>
<ul>
<li>次序靠前的小写字母，如：a、b、c ；</li>
<li>运算符号，如：+、-、*、/ ；</li>
<li>各种标点符号，如：括号、逗号、冒号、等于号；</li>
<li>数字1、2、…、9；</li>
<li>黑体字符串，如：id、begin、if、then 等。</li>
</ul>
<p>非终结符号</p>
<ul>
<li>次序靠前的大写字母，如：A、B、C；</li>
<li>大写字母 S 常用作文法的开始符号；</li>
<li>小写的斜体符号串，如：<em>expr、term、factor、stmt</em> 等。</li>
</ul>
<p>​            </p>
<h3 id="3-推导和短语"><a href="#3-推导和短语" class="headerlink" title="3. 推导和短语"></a>3. 推导和短语</h3><h4 id="3-1-推导与归约"><a href="#3-1-推导与归约" class="headerlink" title="3.1. 推导与归约"></a>3.1. 推导与归约</h4><p>假定 $A \rightarrow \gamma$ 是一个产生式，$\alpha$ 和 $\beta$ 是任意的文法符号串，则有：$\alpha A \beta \Rightarrow \alpha \gamma \beta$ </p>
<ul>
<li>$\Rightarrow$ 表示『一步推导』，即利用产生式对左边符号串中的一个非终结符号进行替换，得到右边的符号串。</li>
<li>称 $\alpha A \beta$ 直接<code>推导</code>出 $\alpha \gamma \beta$ ，也可以说 $\alpha \gamma \beta$ 是 $\alpha A \beta$ 的直接<code>推导</code></li>
<li>或说 $\alpha \gamma \beta$ 直接<code>归约</code>到 $\alpha A \beta$ </li>
</ul>
<p>如果有直接推导序列：$\alpha_1 \Rightarrow \alpha_2 \Rightarrow \dots \Rightarrow \alpha_n$ ，则说 $\alpha_1$ 推导出 $\alpha_n$，记作：</p>
<script type="math/tex; mode=display">
\alpha_1 \stackrel{*}{\Longrightarrow} \alpha_n （允许 \alpha_1 = \alpha_n）\\
\alpha_1 \stackrel{+}{\Longrightarrow} \alpha_n （不允许 \alpha_1 = \alpha_n，即至少推导了一步）</script><p>称这个序列是从 $\alpha_1$ 到 $\alpha_n$ 的长度为 n 的『推导』。</p>
<p><strong>最左推导</strong> ：如果 $\alpha \stackrel{*}{\Longrightarrow} \beta$ 并且在每『一步推导』中，都替换 α 中最左边的非终结符号，则称这样的推导为『最左推导』。记作</p>
<script type="math/tex; mode=display">
\alpha \stackrel{*}{\underset{lm}\Longrightarrow} \beta</script><p><strong>最右推导</strong>：如果 $\alpha \stackrel{*}{\Longrightarrow} \beta$ 并且在每『一步推导』中，都替换 α 中最右边的非终结符号，则称这样的推导为『最右推导』，最右推导又被称为『规范推导』，与之对应的归约称为『规范归约』，记作 </p>
<script type="math/tex; mode=display">
\alpha \stackrel{*}{\underset{rm}\Longrightarrow} \beta</script><p>​       </p>
<h4 id="3-2-句型"><a href="#3-2-句型" class="headerlink" title="3.2. 句型"></a>3.2. 句型</h4><p><strong>句型</strong>：对于文法 $G=(V_T, V_N, S, φ)$ ，如果$S \stackrel{*}{\Longrightarrow} \alpha$ ，则称 $\alpha$ 是当前文法的一个<code>『句型』</code>。</p>
<ul>
<li>若 $S \stackrel{*}{\underset{lm}\Longrightarrow} \alpha$ ，则 $\alpha$ 是当前文法的一个左句型；</li>
<li>若 $S \stackrel{*}{\underset{rm}\Longrightarrow} \alpha$ ，则 $\alpha$ 是当前文法的一个右句型。</li>
</ul>
<p><strong>句子</strong>：仅含有终结符号的句型是文法的一个<code>『句子』</code>。</p>
<p><strong>语言</strong>：文法 $G$ 产生的所有句子组成的集合是文法 $G$ 所定义的<code>『语言』</code>，记作 $L(G)$ 。</p>
<script type="math/tex; mode=display">
L(G) = \{ \alpha | S  \stackrel{+}{\Longrightarrow} \alpha_n ，并且 \alpha \in {V_T}^* \}</script><p>​         </p>
<h4 id="3-3-短语"><a href="#3-3-短语" class="headerlink" title="3.3. 短语"></a>3.3. 短语</h4><p>对于文法 $G=(V_T, V_N, S, φ)$ ，假定 $\alpha\beta\delta$ 是文法 $G$ 的一个句型，如果存在：</p>
<script type="math/tex; mode=display">
S \stackrel{*}{\Rightarrow} \alpha A \delta，并且 A \stackrel{+}{\Rightarrow} \beta</script><p>则称 $\beta$ 为句型 $\alpha \beta \delta$ 关于非终结符号 $A$ 的<code>『短语』</code>，如果存在：</p>
<script type="math/tex; mode=display">
S \stackrel{*}{\Rightarrow} \alpha A \delta，并且 A \Rightarrow \beta</script><p>则称 $\beta$ 为句型 $\alpha \beta \delta$ 关于非终结符号 $A$ 的<code>『直接短语』</code>。</p>
<p><strong>句柄</strong>：一个句型的最左直接短语称为该句型的<code>『句柄』</code>。</p>
<p>​          </p>
<h3 id="4-分析树及文法的二义性"><a href="#4-分析树及文法的二义性" class="headerlink" title="4. 分析树及文法的二义性"></a>4. 分析树及文法的二义性</h3><h4 id="4-1-分析树（推导树）"><a href="#4-1-分析树（推导树）" class="headerlink" title="4.1. 分析树（推导树）"></a>4.1. 分析树（推导树）</h4><p><strong>分析树</strong>：是推导的图形表示，又称推导树。</p>
<ul>
<li>是一棵有序有向树，因此具有树的性质；</li>
<li>有自己的特点：每一个结点都有标记。<ul>
<li>根结点由文法的开始符号标记；</li>
<li>每个内部结点由非终结符号标记，它的子结点由这个非终结符号的这次推导所用产生式的右部各符号从左到右依次标记；</li>
<li>叶结点由非终结符号或终结符号标记，它们从左到右排列起来，构成句型。</li>
</ul>
</li>
</ul>
<p>举例：</p>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-03-04_10-46-21.png" alt></p>
<p><strong>子树</strong>：指分析树中一个特有的结点、连同它的全部后裔结点、连接这些结点的边、以及这些结点的标记。</p>
<ul>
<li>子树的根结点的标记可能不是文法的开始符号。</li>
<li>如果子树的根结点标记为非终结符号A，则可称该子树为『A-子树』。</li>
</ul>
<p>子树与短语的关系：</p>
<ul>
<li>一棵子树的所有叶结点自左至右排列起来，形成此句型相对于该子树根的短语；</li>
<li>分析树中只有父子两代的子树的所有叶结点自左至右排列起来，形成此句型相对于该子树根的直接短语；</li>
<li>分析树中最左边的那棵只有父子两代的子树的所有叶结点自左至右排列起来，就是该句型的句柄。</li>
</ul>
<p>​          </p>
<h4 id="4-2-二义性"><a href="#4-2-二义性" class="headerlink" title="4.2. 二义性"></a>4.2. 二义性</h4><p>如果一个文法的某个句子有不止一棵分析树，则这个句子是二义性的，含有二义性句子的文法是『二义性的文法』。</p>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-03-04_10-54-18.png" alt></p>
<p>形式语言理论可以证明两点结论：</p>
<ul>
<li>给定一个文法 $G$ ，就能从结构上唯一地确定其语言。</li>
<li>给定语言 $L$ ，可以确定其文法，但是文法不是唯一的。</li>
</ul>
<p>由此，从而有<code>『等价文法』</code>的概念，即 $G_1$ 和 $G_2$ 是两个不同的文法，如果 $L(G_1) = L(G_2)$ ，则称 $G_1$ 和 $G_2$ 为等价文法。</p>
<p>有时，一个二义性的文法可以变换为一个等价的、无二义性的文法。</p>
<p>有些语言，根本就不存在无二义性的文法，这样的语言称为『二义性的语言』。</p>
<p>二义性问题是不可判定的</p>
<ul>
<li>不存在一种算法，它能够在有限的步骤内确切地判定出一个文法是否是二义性的。</li>
<li>可以找出一些充分条件（未必是必要条件），当文法满足这些条件时，就可以确信该文法是无二义性的。</li>
</ul>
]]></content>
      <categories>
        <category>笔记整理</category>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
        <tag>复习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>《编译程序设计原理与技术》笔记之编译概述</title>
    <url>/posts/59737bf3.html</url>
    <content><![CDATA[<blockquote>
<p>本笔记基于北京邮电大学出版的李文生编著的《编译程序设计原理与技术》整理</p>
</blockquote>
<p>​         </p>
<h3 id="1-翻译和解释"><a href="#1-翻译和解释" class="headerlink" title="1. 翻译和解释"></a>1. 翻译和解释</h3><h4 id="1-1-翻译程序"><a href="#1-1-翻译程序" class="headerlink" title="1.1. 翻译程序"></a>1.1. 翻译程序</h4><p><code>翻译程序</code> 扫描所输入的源程序，并将其转换为目标程序，或将源程序直接翻译成结果。</p>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-03-03_13-41-25.png" alt></p>
<p>其中，若源语言是汇编语言，目标语言是机器语言，则该翻译程序称为 <code>汇编程序</code>；如果源语言为高级语言，目标语言是某机器的机器语言或汇编语言，则该翻译程序称为 <code>编译程序</code>。</p>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-03-03_13-46-24.png" alt></p>
<p>实现程序到目标程序的转换所占用的时间称为<code>编译时间</code>。源程序和数据是在不同时间（即分别在编译阶段和运行阶段）进行处理的。</p>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-03-03_13-49-11.png" alt></p>
<p>​         </p>
<h4 id="1-2-解释程序"><a href="#1-2-解释程序" class="headerlink" title="1.2. 解释程序"></a>1.2. 解释程序</h4><p><code>解释程序</code> 解释执行源程序，不生成目标程序，即同时处理源程序和数据。</p>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-03-03_13-52-44.png" alt></p>
<p>某些解释程序每次直接分析一条要执行的源程序语句很费时间，一种有效的方法：先将源程序转换为某种中间形式，然后对中间形式的程序解释执行。</p>
<p>​           </p>
<h3 id="2-编译的阶段和任务"><a href="#2-编译的阶段和任务" class="headerlink" title="2. 编译的阶段和任务"></a>2. 编译的阶段和任务</h3><p>按照编译程序的执行过程和所要完成的任务，可以把它分成前后两个阶段，即 <code>分析阶段</code> 和 <code>综合阶段</code>。</p>
<p><code>分析阶段</code>根据原语言的定义，分析源程序的结构，以检查是否符合语言的规定，确定源程序所表示的对象和规定的操作，并以某种中间形式表示出来。分析阶段包括：</p>
<ul>
<li><strong>词法分析</strong></li>
<li><strong>语法分析</strong></li>
<li><strong>语义分析</strong> </li>
</ul>
<p><code>综合阶段</code>根据分析结果构造出所要求的目标程序。综合阶段包括：</p>
<ul>
<li>中间代码生成</li>
<li><strong>代码优化</strong></li>
<li><strong>目标代码生成</strong></li>
</ul>
<p>​       </p>
<p>一种典型的编译程序结构：</p>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-03-03_14-07-31.png" alt></p>
<p>​                 </p>
<h4 id="2-1-词法分析"><a href="#2-1-词法分析" class="headerlink" title="2.1. 词法分析"></a>2.1. 词法分析</h4><p><code>词法分析</code> 又称为<code>扫描</code>，是一种『线性分析』，是编译过程的第一个阶段。</p>
<p><code>词法分析器</code> ：</p>
<ul>
<li>依次读入源程序中的每个字符，对构成源程序的字符串进行分解，识别出每个具有独立意义的字符串作为记号（token）并组织成记号流，形成记号的字符串叫做该记号的单词(lexeme)。</li>
<li>把需要存放的单词放到符号表中，如变量名，标号，常量等。</li>
</ul>
<p>词法分析的工作依据是源语言的构词规则(即词法)，也称为模式(pattern)。</p>
<p>​          </p>
<h4 id="2-2-语法分析"><a href="#2-2-语法分析" class="headerlink" title="2.2. 语法分析"></a>2.2. 语法分析</h4><p><code>语法分析</code> 是一种『层次结构的分析』，在词法分析的基础上把记号流按语言的语法结构层次地分组，以形成语法短语。源程序的语法短语常用分析树表示，语法分析树也称为语法树。</p>
<p>语法分析的工作依据是元语言的语法规则。</p>
<p>程序的层次结构通常由递归的规则表示，如表达式的定义如下：</p>
<ul>
<li>任何一个标识符是一个表达式</li>
<li>任何一个数是一个表达式</li>
<li>如果 $expr_1$和 $expr_2$ 是表达式，$expr_1 + expr_2$ 、$expr_1 * expr_2$ 、$(expr_1)$ 也都是表达式</li>
</ul>
<p>这里，规则 1 和规则 2 是非递归的基本规则，而规则 3 是把运算符作用于其他表达式来定义表达式的规则。</p>
<p>​          </p>
<h4 id="2-3-语义分析"><a href="#2-3-语义分析" class="headerlink" title="2.3. 语义分析"></a>2.3. 语义分析</h4><p><code>语义分析</code> 是对语句的意义进行检查，以保证程序各部分能够有机结合在一起，并为以后生成目标代码收集类型等必要信息。语义分析使用语法分析确定的层次结构来表示各语法成分。</p>
<p>语义分析的工作依据是源语言的语义规则。</p>
<p>语义分析的一个重要任务：类型检查</p>
<ul>
<li>根据规则检查每个运算符及其运算对象是否符合要求；</li>
<li>数组的下标是否合法；</li>
<li>过程调用时，形参与实参个数、类型是否匹配等</li>
</ul>
<p>​              </p>
<h4 id="2-4-中间代码生成"><a href="#2-4-中间代码生成" class="headerlink" title="2.4. 中间代码生成"></a>2.4. 中间代码生成</h4><p><code>中间代码</code> 是经语法分析和语义分析之后，编译程序通常将源程序生成的一种中间表示形式。我们可以把中间代码看成是一种抽象的机器程序。</p>
<p>中间代码应具有两个重要的特点：</p>
<ul>
<li>易于产生</li>
<li>易于翻译成目标代码</li>
</ul>
<p>​        </p>
<h4 id="2-5-代码优化"><a href="#2-5-代码优化" class="headerlink" title="2.5. 代码优化"></a>2.5. 代码优化</h4><p><code>代码优化</code> 是对代码进行改进，使之占用的空间少、运行速度快。编译程序的代码优化首先是在中间代码上进行的，从优化的中间代码可以得到较优的目标代码。</p>
<p>​          </p>
<h4 id="2-6-目标代码生成"><a href="#2-6-目标代码生成" class="headerlink" title="2.6. 目标代码生成"></a>2.6. 目标代码生成</h4><p>生成的目标代码一般是可以重定位的机器代码或汇编语言代码。</p>
<p>涉及到的两个重要问题：</p>
<ul>
<li>对程序中使用的每个变量要指定存储单元</li>
<li>对变量进行寄存器分配</li>
</ul>
]]></content>
      <categories>
        <category>笔记整理</category>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
        <tag>复习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>微软中文输入法中输入中文直角引号</title>
    <url>/posts/1561b045.html</url>
    <content><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>前天学习了一下🀄️ <a href="https://github.com/mzlogin/chinese-copywriting-guidelines" target="_blank" rel="noopener">Chinese Copywriting Guidelines：中文文案排版指北（简体中文版）</a> ，发现自己很多排版上的错误，于是下定决心以后一定要慢慢改掉，其中一个就是『简体中文使用直角引号』的问题，虽然是一个仁者见仁的问题，但是我还是决定以后简体中文的引号都改成<code>「」</code> <code>『』</code>来代替<code>‘ ’</code> <code>“ ”</code>。</p>
<p>​          </p>
<p>那么问题来了，我用的windows自带的输入法怎么才能很方便的打出这些字符呢？</p>
<p>​         </p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><h4 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h4><p>依次打开    <code>设置</code>/<code>时间和语言</code>/<code>区域和语言</code>的中文/<code>微软拼音</code> ，进入<code>高级</code>设置后，打开<code>U 模式输入</code> 。</p>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-03-03_14-33-57.png" alt></p>
<p>​           </p>
<h4 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h4><p>接下来便可以尝试输出了，在中文输入时输入<code>uu</code>，进入 U 模式输入如下图，可以看到 U 模式输入下，支持很多种符号输入，其中「直角引号」在标点输入下。 </p>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-03-03_14-40-03.png" alt></p>
<p>继续敲下：<code>bd</code>，就会弹出标点选择栏，在第一栏中，没有直角引号，但你可以看到一些其他的特殊符号，往后翻就会看到直角引号。</p>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-03-03_14-40-35.png" alt></p>
<p>​           </p>
]]></content>
      <categories>
        <category>日常技巧</category>
      </categories>
      <tags>
        <tag>排版</tag>
      </tags>
  </entry>
  <entry>
    <title>整数快速算法：快速幂&amp;矩阵快速幂总结</title>
    <url>/posts/32ad2daa.html</url>
    <content><![CDATA[<h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><p>第一次遇到快速幂是在做杭电题<code>HDU2034 人见人爱A^B</code>，求A^B的最后三位数表示的整数。看到题目的第一反应是用<code>高精度</code>来求，最后去后三位，反正<code>高精度</code>写的非常熟练了，几十行代码写完之后发现本题数据其实并不大，是一道水题而已，于是写了个很水的循环取余，后来就在评论区知道了<code>快速幂</code>这么个快速算法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;  </span><br><span class="line"><span class="function">ll <span class="title">mod_pow</span><span class="params">(ll x, ll n, ll mod)</span></span>&#123;  </span><br><span class="line">	ll res = <span class="number">1</span>;  </span><br><span class="line">	<span class="keyword">while</span>( n &gt; <span class="number">0</span> )&#123;   </span><br><span class="line">		<span class="keyword">if</span>( n &amp; <span class="number">1</span> ) res = res * x % mod;    <span class="comment">//n&amp;1 即 n%2  </span></span><br><span class="line">		x = x * x % mod;  </span><br><span class="line">		n &gt;&gt;= <span class="number">1</span>;                 <span class="comment">//n &gt;&gt;= 1 即 n/=2  </span></span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">return</span> res;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​           </p>
<h3 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h3><p>刷北邮复试机考题遇到了一道板子题，直接套上就可以了，顺便总结一下这个知识点。</p>
<blockquote>
<p>给定一个n*n的矩阵，求该矩阵的k次幂，即P^k。</p>
</blockquote>
<ul>
<li>题目地址：<a href="https://www.nowcoder.com/practice/31e539ab08f949a8bece2a7503e9319a?tpId=67&amp;tqId=29638&amp;tPage=1&amp;ru=%2Fkaoyan%2Fretest%2F1005&amp;qru=%2Fta%2Fbupt-kaoyan%2Fquestion-ranking" target="_blank" rel="noopener">矩阵幂</a></li>
</ul>
<p>AC代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e8</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mat[MAXN][MAXN]; <span class="comment">//矩阵</span></span><br><span class="line">    <span class="keyword">int</span> row, col;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123; <span class="comment">//初始化為單位矩陣</span></span><br><span class="line">        <span class="built_in">memset</span>(mat, <span class="number">0</span>, <span class="keyword">sizeof</span>(mat));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">                mat[i][j] = (i==j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node <span class="title">mod_mul</span><span class="params">(node a, node b, <span class="keyword">int</span> p)</span> <span class="comment">//矩阵乘法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node ans;</span><br><span class="line">    ans.row = a.row;</span><br><span class="line">    ans.col = b.col;</span><br><span class="line">    <span class="built_in">memset</span>(ans.mat, <span class="number">0</span>, <span class="keyword">sizeof</span>(ans.mat));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.row; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ans.col; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; a.col; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                ans.mat[i][j] += a.mat[i][k] * b.mat[k][j];</span><br><span class="line">                ans.mat[i][j] %= p;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node <span class="title">mod_pow</span><span class="params">(node a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span> <span class="comment">//矩陣快速冪</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node ans;</span><br><span class="line">    ans.row = a.row;</span><br><span class="line">    ans.col = a.col;</span><br><span class="line">    ans.init();</span><br><span class="line">    <span class="keyword">while</span> (k)&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) </span><br><span class="line">            ans = mod_mul(ans, a, p);</span><br><span class="line">        a = mod_mul(a, a, p);</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node m;</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m.mat[i][j]);</span><br><span class="line">                m.mat[i][j] %= MOD;</span><br><span class="line">            &#125;  </span><br><span class="line">        m.col = m.row = n;</span><br><span class="line">        node ans = mod_pow(m, k, MOD);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (j != <span class="number">0</span>)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans.mat[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>算法笔记</tag>
        <tag>快速幂</tag>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>C++几种类型相互转换</title>
    <url>/posts/48867be4.html</url>
    <content><![CDATA[<h2 id="1-string-转换为-int"><a href="#1-string-转换为-int" class="headerlink" title="1. string 转换为 int"></a>1. string 转换为 int</h2><h3 id="1-利用-stringstream"><a href="#1-利用-stringstream" class="headerlink" title="(1) 利用 stringstream"></a>(1) 利用 stringstream</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stringstream</span> ss;</span><br><span class="line"><span class="keyword">long</span> i;</span><br><span class="line">ss &lt;&lt; str;</span><br><span class="line">ss &gt;&gt; i;</span><br></pre></td></tr></table></figure>
<p>​            </p>
<h3 id="2-利用-C-函数-stoi"><a href="#2-利用-C-函数-stoi" class="headerlink" title="(2)利用 C++ 函数 stoi()"></a>(2)利用 C++ 函数 stoi()</h3><p><code>stoi()</code>是<code>string</code>库中的函数，它的参数是<code>string</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> str=<span class="string">"123"</span>;</span><br><span class="line"><span class="keyword">int</span> l =  stoi(str);</span><br></pre></td></tr></table></figure>
<p>​            </p>
<h2 id="2-int-转换为-string"><a href="#2-int-转换为-string" class="headerlink" title="2. int 转换为 string"></a>2. int 转换为 string</h2><h3 id="1-利用-stringstream-1"><a href="#1-利用-stringstream-1" class="headerlink" title="(1) 利用 stringstream"></a>(1) 利用 stringstream</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> l = <span class="number">15</span>;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="built_in">stringstream</span> ss;</span><br><span class="line">ss &lt;&lt; l;</span><br><span class="line">str = ss.str();</span><br></pre></td></tr></table></figure>
<p>​            </p>
<h3 id="2-利用-to-string-函数"><a href="#2-利用-to-string-函数" class="headerlink" title="(2) 利用 to_string() 函数"></a>(2) 利用 to_string() 函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> str = to_string(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>​             </p>
<h2 id="3-string-转换为-C-字符串"><a href="#3-string-转换为-C-字符串" class="headerlink" title="3. string 转换为 C 字符串"></a>3. string 转换为 C 字符串</h2><h3 id="1-利用-stringstream-2"><a href="#1-利用-stringstream-2" class="headerlink" title="(1) 利用 stringstream"></a>(1) 利用 stringstream</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="string">"hhhh"</span>)</span></span>;</span><br><span class="line"><span class="keyword">char</span> ch[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">stringstream</span> ss;</span><br><span class="line">ss &lt;&lt; str;</span><br><span class="line">ss &gt;&gt; ch;</span><br><span class="line"><span class="comment">//char 数组长度不做考虑</span></span><br></pre></td></tr></table></figure>
<p>​             </p>
<h3 id="2-利用-string-类的成员函数-c-str"><a href="#2-利用-string-类的成员函数-c-str" class="headerlink" title="(2) 利用 string 类的成员函数 c_str()"></a>(2) 利用 string 类的成员函数 c_str()</h3><p>注意不能直接用 const char<em> 对 char</em> 类型进行初始化或赋值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="string">"hhhh"</span>)</span></span>;</span><br><span class="line"><span class="keyword">char</span> *p = c_str(str);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> x[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(x, str.c_str());</span><br></pre></td></tr></table></figure>
<p>​         </p>
<h3 id="3-利用-string类-的-data-函数"><a href="#3-利用-string类-的-data-函数" class="headerlink" title="(3) 利用 string类 的 data() 函数"></a>(3) 利用 string类 的 data() 函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> str=<span class="string">"abc"</span>; </span><br><span class="line"><span class="keyword">char</span> *p=str.data();</span><br></pre></td></tr></table></figure>
<p>​        </p>
<h3 id="4-调用-string类-的-copy-函数"><a href="#4-调用-string类-的-copy-函数" class="headerlink" title="(4) 调用 string类 的 copy() 函数"></a>(4) 调用 string类 的 copy() 函数</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> str=<span class="string">"hello"</span>; </span><br><span class="line"><span class="keyword">char</span> p[<span class="number">40</span>]; </span><br><span class="line">str.copy(p,<span class="number">5</span>,<span class="number">0</span>); <span class="comment">//这里5，代表复制几个字符，0代表复制的位置</span></span><br><span class="line">*(p+5)='/0';     //要手动加上结束符</span><br></pre></td></tr></table></figure>
<p>​            </p>
<h2 id="4-C-字符串转换为-string"><a href="#4-C-字符串转换为-string" class="headerlink" title="4. C 字符串转换为 string"></a>4. C 字符串转换为 string</h2><h3 id="1-直接赋值"><a href="#1-直接赋值" class="headerlink" title="(1) 直接赋值"></a>(1) 直接赋值</h3><p>C++ 已对 string 进行了重载 可以在定义时直接初始化，或者赋值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *y = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> z[] = <span class="string">"hello world"</span>;</span><br><span class="line">x = y;</span><br><span class="line">x = z;</span><br></pre></td></tr></table></figure>
<p>​           </p>
<h2 id="5-C-字符串转换为-int"><a href="#5-C-字符串转换为-int" class="headerlink" title="5. C 字符串转换为 int"></a>5. C 字符串转换为 int</h2><h3 id="1-利用-stringstream-3"><a href="#1-利用-stringstream-3" class="headerlink" title="(1) 利用 stringstream"></a>(1) 利用 stringstream</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stringstream</span> ss;</span><br><span class="line"><span class="keyword">long</span> l;</span><br><span class="line">ss &lt;&lt; ch;</span><br><span class="line">ss &gt;&gt; l;</span><br></pre></td></tr></table></figure>
<p>​              </p>
<h3 id="2-利用-C-函数-atoi"><a href="#2-利用-C-函数-atoi" class="headerlink" title="(2) 利用 C 函数 atoi"></a>(2) 利用 C 函数 atoi</h3><p><code>atoi</code>是c里面的函数，因此在用string时，必须调<code>c_str()</code>方法将其转为char*的字符串。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = atoi(ch);</span><br><span class="line"><span class="keyword">int</span> j = atoi(str.c_str());</span><br></pre></td></tr></table></figure>
<p>​               </p>
<h3 id="3-利用-sscanf"><a href="#3-利用-sscanf" class="headerlink" title="(3) 利用 sscanf"></a>(3) 利用 sscanf</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int i;</span><br><span class="line">sscanf(&quot;17&quot;,&quot;%D&quot;,&amp;i); // 17</span><br><span class="line">//sscanf(&quot;17&quot;,&quot;%X&quot;,&amp;i); // 23</span><br><span class="line">//sscanf(&quot;0X17&quot;,&quot;%X&quot;,&amp;i); // 23</span><br></pre></td></tr></table></figure>
<p>​             </p>
<h2 id="6-int-转换为-C-字符串"><a href="#6-int-转换为-C-字符串" class="headerlink" title="6. int 转换为 C 字符串"></a>6. int 转换为 C 字符串</h2><h3 id="1-利用-stringstream-4"><a href="#1-利用-stringstream-4" class="headerlink" title="(1) 利用 stringstream"></a>(1) 利用 stringstream</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stringstream</span> ss;</span><br><span class="line">ss &lt;&lt; i;</span><br><span class="line">ss &gt;&gt; ch;</span><br></pre></td></tr></table></figure>
<p>​           </p>
<h3 id="2-利用-sprintf"><a href="#2-利用-sprintf" class="headerlink" title="(2) 利用 sprintf"></a>(2) 利用 sprintf</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char *ch;</span><br><span class="line">int i;</span><br><span class="line">sprintf(ch,&quot;%d&quot;, i);</span><br></pre></td></tr></table></figure>
<p>​               </p>
<blockquote>
<p>本文参考自：</p>
<p><a href="https://www.cnblogs.com/devilmaycry812839668/p/6353807.html" target="_blank" rel="noopener">c++ 中 char 与 string 之间的相互转换问题</a></p>
<p><a href="https://note-rtd.readthedocs.io/en/latest/source/2_%E8%AF%AD%E8%A8%80/CCpp/C++%E4%B8%AD%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/_content.html" target="_blank" rel="noopener">C++ 中几种类型相互转换</a></p>
</blockquote>
<p>​          </p>
<ul>
<li>封面图片来源：<a href="https://code.fb.com/developer-tools/three-optimization-tips-for-c/" target="_blank" rel="noopener">https://code.fb.com/developer-tools/three-optimization-tips-for-c/</a></li>
</ul>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++ String类用法与心得</title>
    <url>/posts/f58b376e.html</url>
    <content><![CDATA[<h3 id="String类简介"><a href="#String类简介" class="headerlink" title="String类简介"></a>String类简介</h3><p><code>String</code>是以<code>char</code>作为模板参数的模板类实例，把字符串的内存管理责任由<code>string</code>负责而不是由编程者负责，大大减轻了C语言风格的字符串的麻烦。<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>
<p><code>String</code>的特色：</p>
<ul>
<li>提供了大量的字符操作函数。</li>
<li>可与C语言风格字符串双向转换。<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></li>
</ul>
<p>​        </p>
<h3 id="成员函数简介与常用代码写法"><a href="#成员函数简介与常用代码写法" class="headerlink" title="成员函数简介与常用代码写法"></a>成员函数简介与常用代码写法</h3><h4 id="头文件与声明"><a href="#头文件与声明" class="headerlink" title="头文件与声明"></a>头文件与声明</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>注意这里不是string.h string.h是C字符串头文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> str; <span class="comment">//声明一个空字符串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="string">"hello C++"</span>)</span></span>; <span class="comment">//直接赋值</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(str)</span></span>; <span class="comment">//拷贝构造函数，生成str的复制品</span></span><br></pre></td></tr></table></figure>
<p>​       </p>
<h4 id="输入输出操作"><a href="#输入输出操作" class="headerlink" title="输入输出操作"></a>输入输出操作</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span>&gt;&gt;str; <span class="comment">//读入有效字符直到遇到空格</span></span><br><span class="line">getline(<span class="built_in">cin</span>, str); <span class="comment">//读取字符直到遇到换行</span></span><br><span class="line">getline(<span class="built_in">cin</span>, str, <span class="string">'a'</span>); <span class="comment">//直到遇到'a'结束，其中任何字符包括'\n'都可以读入</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>​       </p>
<h4 id="字符串赋值操作"><a href="#字符串赋值操作" class="headerlink" title="字符串赋值操作"></a>字符串赋值操作</h4><p><code>string &amp;operator=(const string &amp;s);</code>把字符串s赋给当前字符串<br><code>string &amp;assign(const char *s);</code>用c类型字符串s赋值<br><code>string &amp;assign(const char *s,int n);</code>用c字符串s开始的n个字符赋值<br><code>string &amp;assign(const string &amp;s);</code>把字符串s赋给当前字符串<br><code>string &amp;assign(int n,char c);</code>用n个字符c赋值给当前字符串<br><code>string &amp;assign(const string &amp;s,int start,int n);</code>把字符串s中从start开始的n个字符赋给当前字符串<br><code>string &amp;assign(const_iterator first,const_itertor last);</code>把first和last迭代器之间的部分赋给字符串</p>
<p>举例：<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// string::assign</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> str;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> base=<span class="string">"The quick brown fox jumps over a lazy dog."</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// used in the same order as described above:</span></span><br><span class="line"></span><br><span class="line">  str.assign(base);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  str.assign(base,<span class="number">10</span>,<span class="number">9</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">'\n'</span>;         <span class="comment">// "brown fox"</span></span><br><span class="line"></span><br><span class="line">  str.assign(<span class="string">"pangrams are cool"</span>,<span class="number">7</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">'\n'</span>;         <span class="comment">// "pangram"</span></span><br><span class="line"></span><br><span class="line">  str.assign(<span class="string">"c-string"</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">'\n'</span>;         <span class="comment">// "c-string"</span></span><br><span class="line"></span><br><span class="line">  str.assign(<span class="number">10</span>,<span class="string">'*'</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">'\n'</span>;         <span class="comment">// "**********"</span></span><br><span class="line"></span><br><span class="line">  str.assign&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>,<span class="number">0x2D</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">'\n'</span>;         <span class="comment">// "----------"</span></span><br><span class="line"></span><br><span class="line">  str.assign(base.begin()+<span class="number">16</span>,base.end()<span class="number">-12</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">'\n'</span>;         <span class="comment">// "fox jumps over"</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">The quick brown fox jumps over a lazy dog.</span></span><br><span class="line"><span class="comment">brown fox</span></span><br><span class="line"><span class="comment">pangram</span></span><br><span class="line"><span class="comment">c-string</span></span><br><span class="line"><span class="comment">**********</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line"><span class="comment">fox jumps over</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>​          </p>
<h4 id="在尾部添加字符"><a href="#在尾部添加字符" class="headerlink" title="在尾部添加字符"></a>在尾部添加字符</h4><p><code>string &amp;operator+=(const string &amp;s);</code> 把字符串s连接到当前字符串的结尾<br><code>string &amp;append(const char *s);</code>把c类型字符串s连接到当前字符串结尾<br><code>string &amp;append(const char *s,int n);</code>把c类型字符串s的前n个字符连接到当前字符串结尾<br><code>string &amp;append(const string &amp;s);</code>同operator+=()<br><code>string &amp;append(const string &amp;s,int pos,int n);</code>把字符串s中从pos开始的n个字符连接到当前字符串的结尾<br><code>string &amp;append(int n,char c);</code>在当前字符串结尾添加n个字符c<br><code>string &amp;append(const_iterator first,const_iterator last);</code>把迭代器first和last之间的部分连接到当前字符串的结尾</p>
<p>下面为举例：<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// appending to string</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> str;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> str2=<span class="string">"Writing "</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> str3=<span class="string">"print 10 and then 5 more"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// used in the same order as described above:</span></span><br><span class="line">  str.append(str2);                       <span class="comment">// "Writing "</span></span><br><span class="line">  str.append(str3,<span class="number">6</span>,<span class="number">3</span>);                   <span class="comment">// "10 "</span></span><br><span class="line">  str.append(<span class="string">"dots are cool"</span>,<span class="number">5</span>);          <span class="comment">// "dots "</span></span><br><span class="line">  str.append(<span class="string">"here: "</span>);                   <span class="comment">// "here: "</span></span><br><span class="line">  str.append(<span class="number">10u</span>,<span class="string">'.'</span>);                    <span class="comment">// ".........."</span></span><br><span class="line">  str.append(str3.begin()+<span class="number">8</span>,str3.end());  <span class="comment">// " and then 5 more"</span></span><br><span class="line">  str.append&lt;<span class="keyword">int</span>&gt;(<span class="number">5</span>,<span class="number">0x2E</span>);                <span class="comment">// "....."</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output: Writing 10 dots here: .......... and then 5 more.....</span></span><br></pre></td></tr></table></figure>
<p>另外string还可以用<code>push_back()</code>来添加单个字符</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">s.push_back(<span class="string">'a'</span>);<span class="comment">//这个函数只能增加单个字符</span></span><br></pre></td></tr></table></figure>
<p>​        </p>
<h4 id="String类的插入函数"><a href="#String类的插入函数" class="headerlink" title="String类的插入函数"></a>String类的插入函数</h4><p><code>string &amp;insert(int p0, const char *s);</code>在p0位置插入字符串s<br><code>string &amp;insert(int p0, const char *s, int n);</code>在p0位置插入字符串s的前n个字符<br><code>string &amp;insert(int p0,const string &amp;s);</code>在p0位置插入字符串s<br><code>string &amp;insert(int p0,const string &amp;s, int pos, int n);</code>在p0位置插入字符串s中pos开始的n个字符<br><code>string &amp;insert(int p0, int n, char c);</code>此函数在p0处插入n个字符c<br><code>iterator insert(iterator it, char c);</code>在it处插入字符c，返回插入后迭代器的位置<br><code>void insert(iterator it, const_iterator first, const_iterator last);</code>在it处插入<code>[first，last)</code>之间的字符<br><code>void insert(iterator it, int n, char c);</code>在it处插入n个字符c</p>
<p>举例如下：<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// inserting into a string</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> str=<span class="string">"to be question"</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> str2=<span class="string">"the "</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> str3=<span class="string">"or not to be"</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span>::iterator it;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// used in the same order as described above:</span></span><br><span class="line">  str.insert(<span class="number">6</span>,str2);                 <span class="comment">// to be (the )question</span></span><br><span class="line">  str.insert(<span class="number">6</span>,str3,<span class="number">3</span>,<span class="number">4</span>);             <span class="comment">// to be (not )the question</span></span><br><span class="line">  str.insert(<span class="number">10</span>,<span class="string">"that is cool"</span>,<span class="number">8</span>);    <span class="comment">// to be not (that is )the question</span></span><br><span class="line">  str.insert(<span class="number">10</span>,<span class="string">"to be "</span>);            <span class="comment">// to be not (to be )that is the question</span></span><br><span class="line">  str.insert(<span class="number">15</span>,<span class="number">1</span>,<span class="string">':'</span>);               <span class="comment">// to be not to be(:) that is the question</span></span><br><span class="line">  it = str.insert(str.begin()+<span class="number">5</span>,<span class="string">','</span>); <span class="comment">// to be(,) not to be: that is the question</span></span><br><span class="line">  str.insert (str.end(),<span class="number">3</span>,<span class="string">'.'</span>);       <span class="comment">// to be, not to be: that is the question(...)</span></span><br><span class="line">  str.insert (it+<span class="number">2</span>,str3.begin(),str3.begin()+<span class="number">3</span>); <span class="comment">// (or )</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output: to be, or not to be: that is the question...</span></span><br></pre></td></tr></table></figure>
<p>​         </p>
<h4 id="String类的删除函数"><a href="#String类的删除函数" class="headerlink" title="String类的删除函数"></a>String类的删除函数</h4><p><code>iterator erase(iterator first, iterator last);</code>删除<code>[first，last)</code>之间的所有字符，返回删除后迭代器的位置<br><code>iterator erase(iterator it);</code>删除it指向的字符，返回删除后迭代器的位置<br><code>string &amp;erase(int pos = 0, int n);</code>删除pos开始的n个字符，返回修改后的字符串</p>
<p>举例：<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// string::erase</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">str</span> <span class="params">(<span class="string">"This is an example sentence."</span>)</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">                                           <span class="comment">// "This is an example sentence."</span></span><br><span class="line">  str.erase (<span class="number">10</span>,<span class="number">8</span>);                        <span class="comment">//            ^^^^^^^^</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">                                           <span class="comment">// "This is an sentence."</span></span><br><span class="line">  str.erase (str.begin()+<span class="number">9</span>);               <span class="comment">//           ^</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">                                           <span class="comment">// "This is a sentence."</span></span><br><span class="line">  str.erase (str.begin()+<span class="number">5</span>, str.end()<span class="number">-9</span>);  <span class="comment">//       ^^^^^</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">                                           <span class="comment">// "This sentence."</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">This is an example sentence.</span></span><br><span class="line"><span class="comment">This is an sentence.</span></span><br><span class="line"><span class="comment">This is a sentence.</span></span><br><span class="line"><span class="comment">This sentence.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>​         </p>
<h4 id="String类的替换函数"><a href="#String类的替换函数" class="headerlink" title="String类的替换函数"></a>String类的替换函数</h4><p><code>string &amp;replace(int p0, int n0,const char *s);</code>删除从p0开始的n0个字符，然后在p0处插入串s<br><code>string &amp;replace(int p0, int n0,const char *s, int n);</code>删除p0开始的n0个字符，然后在p0处插入字符串s的前n个字符<br><code>string &amp;replace(int p0, int n0,const string &amp;s);</code>删除从p0开始的n0个字符，然后在p0处插入串s<br><code>string &amp;replace(int p0, int n0,const string &amp;s, int pos, int n);</code>删除p0开始的n0个字符，然后在p0处插入串s中从pos开始的n个字符<br><code>string &amp;replace(int p0, int n0,int n, char c);</code>删除p0开始的n0个字符，然后在p0处插入n个字符c<br><code>string &amp;replace(iterator first0, iterator last0,const char *s);</code>把[first0，last0)之间的部分替换为字符串s<br><code>string &amp;replace(iterator first0, iterator last0,const char *s, int n);</code>把[first0，last0)之间的部分替换为s的前n个字符<br><code>string &amp;replace(iterator first0, iterator last0,const string &amp;s);</code>把[first0，last0)之间的部分替换为串s<br><code>string &amp;replace(iterator first0, iterator last0,int n, char c);</code>把[first0，last0)之间的部分替换为n个字符c<br><code>string &amp;replace(iterator first0, iterator last0,const_iterator first, const_iterator last);</code>把[first0，last0)之间的部分替换成[first，last）之间的字符串</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// replacing in a string</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> base=<span class="string">"this is a test string."</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> str2=<span class="string">"n example"</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> str3=<span class="string">"sample phrase"</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> str4=<span class="string">"useful."</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// replace signatures used in the same order as described above:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Using positions: 0123456789*123456789*12345</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> str=base; <span class="comment">// "this is a test string."</span></span><br><span class="line">  str.replace(<span class="number">9</span>,<span class="number">5</span>,str2); <span class="comment">// "this is an example string." (1)</span></span><br><span class="line">  str.replace(<span class="number">19</span>,<span class="number">6</span>,str3,<span class="number">7</span>,<span class="number">6</span>); <span class="comment">// "this is an example phrase." (2)</span></span><br><span class="line">  str.replace(<span class="number">8</span>,<span class="number">10</span>,<span class="string">"just a"</span>); <span class="comment">// "this is just a phrase."     (3)</span></span><br><span class="line">  str.replace(<span class="number">8</span>,<span class="number">6</span>,<span class="string">"a shorty"</span>,<span class="number">7</span>); <span class="comment">// "this is a short phrase."    (4)</span></span><br><span class="line">  str.replace(<span class="number">22</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="string">'!'</span>); <span class="comment">// "this is a short phrase!!!"  (5)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Using iterators: 0123456789*123456789*</span></span><br><span class="line">  str.replace(str.begin(),str.end()<span class="number">-3</span>,str3); <span class="comment">// "sample phrase!!!"      (1)</span></span><br><span class="line">  str.replace(str.begin(),str.begin()+<span class="number">6</span>,<span class="string">"replace"</span>); <span class="comment">// "replace phrase!!!"     (3)</span></span><br><span class="line">  str.replace(str.begin()+<span class="number">8</span>,str.begin()+<span class="number">14</span>,<span class="string">"is coolness"</span>,<span class="number">7</span>); <span class="comment">// "replace is cool!!!" (4)</span></span><br><span class="line">  str.replace(str.begin()+<span class="number">12</span>,str.end()<span class="number">-4</span>,<span class="number">4</span>,<span class="string">'o'</span>); <span class="comment">// "replace is cooool!!!" (5)</span></span><br><span class="line">  str.replace(str.begin()+<span class="number">11</span>,str.end(),str4.begin(),str4.end());<span class="comment">// "replace is useful." (6)</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output: replace is useful.</span></span><br></pre></td></tr></table></figure>
<p>​          </p>
<h4 id="String的子串"><a href="#String的子串" class="headerlink" title="String的子串"></a>String的子串</h4><p><code>string substr(int pos = 0, int n) const;</code>返回pos开始的n个字符组成的字符串</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> hello = s.substr(<span class="number">9</span>, <span class="number">5</span>); <span class="comment">//hello</span></span><br><span class="line">s.substr(); <span class="comment">//返回s全部内容</span></span><br><span class="line">s.substr(<span class="number">11</span>); <span class="comment">//返回索引11往后的子串</span></span><br></pre></td></tr></table></figure>
<p>​        </p>
<h4 id="String类的查找函数"><a href="#String类的查找函数" class="headerlink" title="String类的查找函数"></a>String类的查找函数</h4><p><code>int find(char c, int pos = 0) const;</code>从pos开始查找字符c在当前字符串的位置<br><code>int find(const char *s, int pos = 0) const;</code>从pos开始查找字符串s在当前串中的位置<br><code>int find(const char *s, int pos, int n) const;</code>从pos开始查找字符串s中前n个字符在当前串中的位置<br><code>int find(const string &amp;s, int pos = 0) const;</code>从pos开始查找字符串s在当前串中的位置</p>
<p>除了<code>find()</code>外，还有</p>
<p><code>rfind()</code>：从pos开始从后向前查找字符串s在当前串中的位置</p>
<p><code>find_first_of()</code>从pos开始查找当前串中第一个出现的串位置</p>
<p><code>find_first_not_of()</code>从当前串中查找第一个不在串s中的字符出现的位置</p>
<p><code>find_last_of()</code>和<code>find_last_not_of()</code>从后向前找</p>
<p>更多的情况下，我们可以直接把函数和npos进行比较：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(s.find(hello) != <span class="built_in">string</span>::npos)&#123;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"'hello' found at:"</span>&lt;&lt;s.find(hello)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​              </p>
<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/* --------------1.string声明创建------------------ */</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="string">"hello C++"</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">sh</span><span class="params">(<span class="string">" C++"</span>)</span></span>;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* --------------2.字符串赋值操作------------------ */</span></span><br><span class="line">    s = s.assign(str);</span><br><span class="line">    s = s.assign(<span class="number">5</span>, <span class="string">'x'</span>); <span class="comment">//把5个x赋给字符串</span></span><br><span class="line">    s = s.assign(str, <span class="number">6</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">         &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    s = s.assign(<span class="string">"hello STL"</span>, <span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* --------------3.在尾部添加字符------------------ */</span></span><br><span class="line">    <span class="comment">//+=,append(),push_back()</span></span><br><span class="line">    s += str;</span><br><span class="line">    s.append(sh);</span><br><span class="line">    s.append(str, <span class="number">5</span>, <span class="number">4</span>);</span><br><span class="line">    s.append(<span class="string">"hello STL"</span>, <span class="number">5</span>, <span class="number">4</span>);</span><br><span class="line">    s.append(<span class="number">5</span>, <span class="string">'x'</span>);</span><br><span class="line">    s.push_back(<span class="string">'a'</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* --------------4.insert()------------------ */</span></span><br><span class="line">    s.insert(<span class="number">0</span>, <span class="string">"hello "</span>);</span><br><span class="line">    s.insert(<span class="number">0</span>, str, <span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line">    s.insert(<span class="number">0</span>, <span class="string">"that is cool"</span>,<span class="number">8</span>);</span><br><span class="line">    s.insert(<span class="number">7</span>, <span class="number">1</span>, <span class="string">':'</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* --------------5.erase()------------------ */</span></span><br><span class="line">    s.erase(<span class="number">9</span>, <span class="number">18</span>); <span class="comment">//删除三个"hello "</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* --------------6.replace()------------------ */</span></span><br><span class="line">    s.replace(<span class="number">15</span>, <span class="number">3</span>, str, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">    s.replace(<span class="number">25</span>, <span class="number">3</span>, <span class="string">"C++ Primer Plus"</span>, <span class="number">4</span>, <span class="number">11</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* --------------7.子串substr()------------------ */</span></span><br><span class="line">    <span class="built_in">string</span> hello = s.substr(<span class="number">9</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; hello &lt;&lt; <span class="built_in">endl</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* --------------8.查找------------------ */</span></span><br><span class="line">    <span class="keyword">if</span>(s.find(hello) != <span class="built_in">string</span>::npos)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"'hello' found at:"</span>&lt;&lt;s.find(hello)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="基本操作函数汇总"><a href="#基本操作函数汇总" class="headerlink" title="基本操作函数汇总"></a>基本操作函数汇总</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th style="text-align:left">用法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>begin</strong>()</td>
<td style="text-align:left">返回指向起始的迭代器</td>
</tr>
<tr>
<td style="text-align:center"><strong>clear</strong>()</td>
<td style="text-align:left">删除所有字符</td>
</tr>
<tr>
<td style="text-align:center"><strong>empty</strong>()</td>
<td style="text-align:left">检查字符串是否为空</td>
</tr>
<tr>
<td style="text-align:center"><strong>end</strong>()</td>
<td style="text-align:left">返回指向尾端的迭代器</td>
</tr>
<tr>
<td style="text-align:center"><strong>erase</strong>()</td>
<td style="text-align:left">删除字符</td>
</tr>
<tr>
<td style="text-align:center"><strong>insert</strong>()</td>
<td style="text-align:left">插入字符</td>
</tr>
<tr>
<td style="text-align:center"><strong>max_size</strong>()</td>
<td style="text-align:left">返回可以容纳的最大字符个数</td>
</tr>
<tr>
<td style="text-align:center"><strong>rbegin</strong>()</td>
<td style="text-align:left">返回指向起始的逆向迭代器</td>
</tr>
<tr>
<td style="text-align:center"><strong>rend</strong>()</td>
<td style="text-align:left">返回指向末尾的逆向迭代器</td>
</tr>
<tr>
<td style="text-align:center"><strong>size</strong>()</td>
<td style="text-align:left">返回容纳的字符数</td>
</tr>
<tr>
<td style="text-align:center"><strong>swap</strong>()</td>
<td style="text-align:left">交换内容</td>
</tr>
<tr>
<td style="text-align:center"><strong>find</strong>()</td>
<td style="text-align:left">寻找带有特定键的元素</td>
</tr>
<tr>
<td style="text-align:center"><strong>push_back</strong>()</td>
<td style="text-align:left">后附字符到结尾</td>
</tr>
<tr>
<td style="text-align:center"><strong>pop_back</strong>()</td>
<td style="text-align:left">移除末尾字符</td>
</tr>
<tr>
<td style="text-align:center"><strong>append</strong>()</td>
<td style="text-align:left">后附字符到结尾</td>
</tr>
<tr>
<td style="text-align:center"><strong>operator+=</strong></td>
<td style="text-align:left">后附字符到结尾</td>
</tr>
<tr>
<td style="text-align:center"><strong>compare</strong>()</td>
<td style="text-align:left">比较两个字符串</td>
</tr>
<tr>
<td style="text-align:center"><strong>replace</strong>()</td>
<td style="text-align:left">替换字符串的指定部分</td>
</tr>
<tr>
<td style="text-align:center"><strong>substr</strong>()</td>
<td style="text-align:left">返回子串</td>
</tr>
<tr>
<td style="text-align:center"><strong>copy</strong>()</td>
<td style="text-align:left">复制字符</td>
</tr>
<tr>
<td style="text-align:center"><strong>resize</strong>()</td>
<td style="text-align:left">更改存储的字符数</td>
</tr>
<tr>
<td style="text-align:center"><strong>find</strong>()</td>
<td style="text-align:left">在字符串中查找字符</td>
</tr>
<tr>
<td style="text-align:center"><strong>rfind</strong>()</td>
<td style="text-align:left">寻找子串的最后一次出现</td>
</tr>
<tr>
<td style="text-align:center"><strong>find_first_of</strong>()</td>
<td style="text-align:left">寻找子串的第一次出现</td>
</tr>
<tr>
<td style="text-align:center"><strong>find_first_not_of</strong>()</td>
<td style="text-align:left">寻找子串的第一次缺失</td>
</tr>
<tr>
<td style="text-align:center"><strong>find_last_of</strong>()</td>
<td style="text-align:left">寻找子串的最后一次出现</td>
</tr>
<tr>
<td style="text-align:center"><strong>find_last_not_of</strong>()</td>
<td style="text-align:left">寻找子串的最后一次缺失</td>
</tr>
<tr>
<td style="text-align:center"><strong>npos</strong></td>
<td style="text-align:left">特殊值</td>
</tr>
</tbody>
</table>
</div>
<p>​               </p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="https://zh.wikipedia.org/wiki/String_(C%2B%2B%E6%A0%87%E5%87%86%E5%BA%93)" target="_blank" rel="noopener">wiki</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;"><a href="https://mropengate.blogspot.com/2015/07/cc-string-stl.html" target="_blank" rel="noopener">mropengate</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;"><a href="http://www.cplusplus.com/reference/string/string" target="_blank" rel="noopener">cplusplus</a></span><a href="#fnref:3" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>编程开发</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Set(STL)用法与心得</title>
    <url>/posts/f5dd410d.html</url>
    <content><![CDATA[<p>STL总结系列：</p>
<ul>
<li>『<a href="https://wiki.hushhw.cn/posts/179.html">优先队列（priority_queue）用法与心得</a>』</li>
<li>『<a href="https://wiki.hushhw.cn/posts/38f87fc0.html">Map(STL)用法与心得</a>』</li>
<li>『<a href="https://wiki.hushhw.cn/posts/d20d34ce.html">Vector(STL)用法与心得</a>』</li>
</ul>
<p>​         </p>
<h3 id="Set简介"><a href="#Set简介" class="headerlink" title="Set简介"></a>Set简介</h3><p><code>std::set</code> 是一种包含已排序对象的关联容器，含有 <code>Key</code> 类型对象的已排序集。用比较函数 Compare进行排序。搜索、移除和插入拥有对数复杂度。 <code>set</code>通常以红黑树实现（C++ <code>STL</code>中的关联容器：<code>map</code>，<code>set</code>，<code>multiset</code>，<code>multimap</code>内部的数据结构为红黑树）。</p>
<p><code>set</code>/<code>multiset</code>会根据待定的排序准则，自动将元素排序。两者不同在于前者不允许元素重复，而后者允许。</p>
<p>1) 不能直接改变元素值，因为那样会打乱原本正确的顺序，要改变元素值必须先删除旧元素，则插入新元素；</p>
<p>2) 不提供直接存取元素的任何操作函数，只能通过迭代器进行间接存取，而且从迭代器角度来看，元素值是常数；</p>
<p>3) 元素比较动作只能用于型别相同的容器(即元素和排序准则必须相同)；</p>
<h3 id="成员函数简介与常用代码写法"><a href="#成员函数简介与常用代码写法" class="headerlink" title="成员函数简介与常用代码写法"></a>成员函数简介与常用代码写法</h3><h4 id="头文件与声明"><a href="#头文件与声明" class="headerlink" title="头文件与声明"></a>头文件与声明</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>使用set需要上面这个头文件。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; v;		<span class="comment">//创建一个int类型的set容器</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it;     <span class="comment">//创建一个他对应的迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> myints[] = &#123;<span class="number">75</span>,<span class="number">23</span>,<span class="number">65</span>,<span class="number">42</span>,<span class="number">13</span>,<span class="number">13</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; <span class="title">myset</span> <span class="params">(myints,myints+<span class="number">6</span>)</span></span>; <span class="comment">//另外一种直接读入数据</span></span><br></pre></td></tr></table></figure>
<p>​       </p>
<h4 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> A[<span class="number">10</span>]=&#123;<span class="number">9</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        v.insert(A[i]); <span class="comment">//在v的尾部循环插入元素</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>​        </p>
<h4 id="查找元素及删除元素"><a href="#查找元素及删除元素" class="headerlink" title="查找元素及删除元素"></a>查找元素及删除元素</h4><p>使用<code>find()</code>来查找某个元素，返回给定值的迭代器，如果没找到则返回end()。</p>
<p>使用<code>erase()</code>来删除某个元素，set中的删除操作是不进行任何的错误检查的，比如迭代器的是否合法等等，所以用的时候自己一定要注意。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">it=v.find(<span class="number">9</span>);</span><br><span class="line">v.erase (it); <span class="comment">//输出 0 1 2 3 4 5 6 7 8</span></span><br><span class="line">v.erase (v.find(<span class="number">0</span>)); <span class="comment">//输出1 2 3 4 5 6 7 8</span></span><br></pre></td></tr></table></figure>
<p>​         </p>
<h4 id="lower-bound-upper-bound"><a href="#lower-bound-upper-bound" class="headerlink" title="lower_bound/upper_bound"></a>lower_bound/upper_bound</h4><p><code>lower_bound</code> 返回指向首个<strong>不小于</strong>给定键的元素的迭代器</p>
<p><code>upper_bound</code> 返回指向首个<strong>大于</strong>给定键的元素的迭代器</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator itlower, itupper;</span><br><span class="line">itlower = v.lower_bound(<span class="number">3</span>); <span class="comment">//3</span></span><br><span class="line">itupper = v.upper_bound(<span class="number">6</span>); <span class="comment">//7</span></span><br><span class="line">v.erase(itlower, itupper);</span><br><span class="line"><span class="keyword">for</span> (it = v.begin(); it != v.end(); it++)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>; <span class="comment">//输出为 1 2 7 8，删除了3——6</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>​         </p>
<h4 id="返回某个值元素的个数count"><a href="#返回某个值元素的个数count" class="headerlink" title="返回某个值元素的个数count()"></a>返回某个值元素的个数count()</h4><p>只可能为0或1，所以可以用来判断一个元素是否存在</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; i;</span><br><span class="line">	<span class="keyword">if</span> (v.count(i)&gt;<span class="number">0</span>) <span class="comment">//返回某个值元素的个数</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">" is an element of v.\n"</span>;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">" is not an element of v.\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​              </p>
<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;		//迭代器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/* --------------1.set的创建------------------ */</span></span><br><span class="line">	<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; v;		<span class="comment">//创建一个int类型的set容器</span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it;     <span class="comment">//创建一个他对应的迭代器</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* -----2.插入元素------ */</span></span><br><span class="line">	<span class="keyword">int</span> A[<span class="number">10</span>]=&#123;<span class="number">9</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        v.insert(A[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ----------3.find()查找元素及erase()删除元素----------- */</span></span><br><span class="line">	it=v.find(<span class="number">9</span>);</span><br><span class="line">    v.erase (it); <span class="comment">//输出 0 1 2 3 4 5 6 7 8</span></span><br><span class="line">    v.erase (v.find(<span class="number">0</span>)); <span class="comment">//输出1 2 3 4 5 6 7 8</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ----4.返回某个值元素的个数---- */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i;</span><br><span class="line">        <span class="keyword">if</span> (v.count(i)&gt;<span class="number">0</span>) <span class="comment">//返回某个值元素的个数</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">" is an element of v.\n"</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">" is not an element of v.\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* ----5.lower_bound/upper_bound---- */</span></span><br><span class="line">	<span class="comment">//lower_bound 返回指向首个不小于给定键的元素的迭代器</span></span><br><span class="line">    <span class="comment">//upper_bound 返回指向首个大于给定键的元素的迭代器</span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator itlower, itupper;</span><br><span class="line">    itlower = v.lower_bound(<span class="number">3</span>); <span class="comment">//3</span></span><br><span class="line">    itupper = v.upper_bound(<span class="number">6</span>); <span class="comment">//7</span></span><br><span class="line">    v.erase(itlower, itupper);</span><br><span class="line">    <span class="keyword">for</span> (it = v.begin(); it != v.end(); it++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>; <span class="comment">//输出为 1 2 7 8，删除了3——6</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​          </p>
<h3 id="Set-改变排序顺序"><a href="#Set-改变排序顺序" class="headerlink" title="Set 改变排序顺序"></a>Set 改变排序顺序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">classcomp</span> &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; lhs, <span class="keyword">const</span> <span class="keyword">int</span>&amp; rhs)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lhs &gt; rhs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>, classcomp&gt; f;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>, classcomp&gt;::iterator fit;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  	<span class="keyword">int</span> A[<span class="number">10</span>]=&#123;<span class="number">9</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        f.insert(A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"reverse set: "</span>;</span><br><span class="line">    <span class="keyword">for</span> (fit = f.begin(); fit != f.end(); fit++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *fit&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出 9 8 7 6 5 4 3 2 1 0</span></span><br><span class="line">  	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面这段代码结构体排序按照 x 从小到大排序，x 相同则按照 y 从大到小排序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">classcomp</span>&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Node &amp;a, <span class="keyword">const</span> Node &amp;b)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x != b.x) <span class="keyword">return</span> a.x&lt;b.x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.y&gt;b.y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;Node, classcomp&gt; st;</span><br><span class="line"><span class="built_in">set</span>&lt;Node, classcomp&gt;::iterator sit;</span><br><span class="line"><span class="built_in">multiset</span>&lt;Node, classcomp&gt; mt;</span><br><span class="line"><span class="built_in">multiset</span>&lt;Node, classcomp&gt; mit;</span><br></pre></td></tr></table></figure>
<p>​          </p>
<h3 id="基本操作函数汇总"><a href="#基本操作函数汇总" class="headerlink" title="基本操作函数汇总"></a>基本操作函数汇总</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th style="text-align:left">用法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>begin</strong>()</td>
<td style="text-align:left">返回指向容器第一个元素的迭代器</td>
</tr>
<tr>
<td style="text-align:center"><strong>clear</strong>()</td>
<td style="text-align:left">删除所有元素</td>
</tr>
<tr>
<td style="text-align:center"><strong>empty</strong>()</td>
<td style="text-align:left">检查容器是否为空</td>
</tr>
<tr>
<td style="text-align:center"><strong>end</strong>()</td>
<td style="text-align:left">返回指向容器尾端的迭代器</td>
</tr>
<tr>
<td style="text-align:center"><strong>erase</strong>()</td>
<td style="text-align:left">删除一个元素</td>
</tr>
<tr>
<td style="text-align:center"><strong>insert</strong>()</td>
<td style="text-align:left">插入元素</td>
</tr>
<tr>
<td style="text-align:center"><strong>max_size</strong>()</td>
<td style="text-align:left">返回可以容纳的最大元素个数</td>
</tr>
<tr>
<td style="text-align:center"><strong>rbegin</strong>()</td>
<td style="text-align:left">返回指向容器最后元素的逆向迭代器</td>
</tr>
<tr>
<td style="text-align:center"><strong>rend</strong>()</td>
<td style="text-align:left">返回指向前端的逆向迭代器</td>
</tr>
<tr>
<td style="text-align:center"><strong>size</strong>()</td>
<td style="text-align:left">返回容纳的元素数</td>
</tr>
<tr>
<td style="text-align:center"><strong>swap</strong>()</td>
<td style="text-align:left">交换内容</td>
</tr>
<tr>
<td style="text-align:center"><strong>find</strong>()</td>
<td style="text-align:left">寻找带有特定键的元素</td>
</tr>
<tr>
<td style="text-align:center"><strong>count</strong>()</td>
<td style="text-align:left">返回匹配特定键的元素数量</td>
</tr>
<tr>
<td style="text-align:center"><strong>lower_bound</strong>()</td>
<td style="text-align:left">返回指向首个不小于给定键的元素的迭代器</td>
</tr>
<tr>
<td style="text-align:center"><strong>upper_bound</strong>()</td>
<td style="text-align:left">返回指向首个大于给定键的元素的迭代器</td>
</tr>
<tr>
<td style="text-align:center"><strong>equal_range</strong>()</td>
<td style="text-align:left">返回匹配特定键的元素范围</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>本文参考自：</p>
<p><a href="https://zh.cppreference.com/w/cpp/container/set" target="_blank" rel="noopener">https://zh.cppreference.com/w/cpp/container/set</a></p>
</blockquote>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo主题maupassant目录优化解决方案</title>
    <url>/posts/5dd904ed.html</url>
    <content><![CDATA[<p>整个探索的过程断断续续花费了我一些时间，写下这篇文章记录下这个工作的过程，并不复杂，但是有值得以后学习的地方。</p>
<p>​        </p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li><code>maupassant</code>主题的目录显示在正文中，一旦目录过长就会严重影响正文的排版。</li>
<li>将目录固定在页面上的需求</li>
</ul>
<p>​           </p>
<h3 id="探索之路"><a href="#探索之路" class="headerlink" title="探索之路"></a>探索之路</h3><p>当初选用<code>maupassant</code>主题就是因为其侧栏特别简约实用，如果在打开文章浏览时将目录也放入侧栏内问题不就解决了吗？于是开始扒主题源码，了解侧栏的机制并开始着手制作目录栏。</p>
<blockquote>
<p>注：以下为逐渐探索的过程，若想直接完成我的这个效果，可以直接从第三回开始。</p>
</blockquote>
<p>​        </p>
<h4 id="第一回"><a href="#第一回" class="headerlink" title="第一回"></a>第一回</h4><ol>
<li><p>新建<code>toc.pug</code>文件在<code>_widgets</code>文件夹下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.widget</span><br><span class="line">  if page.toc</span><br><span class="line">    .widget-title</span><br><span class="line">      i(class=&apos;fa fa-bars&apos;)= &apos;  &apos; + __(&apos;contents&apos;)</span><br><span class="line">     div(id=&apos;stoc&apos; class=&apos;stoc-article&apos;)</span><br><span class="line">       != toc(page.content, &#123;list_number: theme.toc_number&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>之后在主题配置文件<code>_config.yml</code>中添加侧栏<code>toc</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">widgets: </span><br><span class="line">  - toc</span><br><span class="line">  - about</span><br><span class="line">  - search</span><br><span class="line">  - category</span><br><span class="line">  - tag</span><br><span class="line">  - archivelist</span><br><span class="line">  - recent_posts</span><br><span class="line">  - links</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>style.scss</code>中修改基本样式</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.stoc-article</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0.7em</span> <span class="number">0.7em</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#stoc</span> &#123;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1em</span>;</span><br><span class="line">    <span class="selector-class">.toc</span> &#123;</span><br><span class="line">      <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">      <span class="attribute">margin</span>: <span class="number">0.5em</span>;</span><br><span class="line">      <span class="attribute">line-height</span>: <span class="number">1.8em</span>;</span><br><span class="line">      <span class="selector-tag">li</span> &#123;</span><br><span class="line">        <span class="attribute">list-style-type</span>: none;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.toc-child</span> &#123;</span><br><span class="line">      <span class="attribute">margin-left</span>: <span class="number">1em</span>;</span><br><span class="line">      <span class="attribute">padding-left</span>: <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>本地执行<code>hexo server</code>预览</p>
</li>
</ol>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-02-17_00-39-20.png" alt></p>
<p>​      </p>
<p>到这里我以为完结撒花啦🎉，当我发布出去后发现并没有显示出来，之后做了判断验证确实是无法显示，这个问题困扰了我很久，为什么<code>if page.toc</code>这句判断失败而本地预览却可以呢？侧栏无法识别当前<code>page</code>吗？</p>
<p>问题搁置了许久，问题没有解决就很闹心，今天在研究博客整体框架时突然想到把目录的配置提前，放到文章生成前的<code>base.pug</code>文件内，以引入的形式引入到<code>post.pug</code>能不能成功呢？</p>
<p>​       </p>
<h4 id="第二回"><a href="#第二回" class="headerlink" title="第二回"></a>第二回</h4><ol>
<li>新建<code>base-post.pug</code>页面（为了避免破坏其他页面的排版），主要代码复制于<code>base.pug</code>，修改的部分如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#layout.pure-g</span><br><span class="line">   .pure-u-1.pure-u-md-3-4: .content_container</span><br><span class="line">      block content</span><br><span class="line">   if page.toc != true</span><br><span class="line">     .pure-u-1.pure-u-md-1-4: #sidebar</span><br><span class="line">       each item in theme.widgets</span><br><span class="line">        != partial(&apos;_widget/&apos; + item + &apos;.pug&apos;, null, &#123;cache: !config.relative_link&#125;)</span><br><span class="line">   else</span><br><span class="line">      .pure-u-1.pure-u-md-1-4: #posttoc</span><br><span class="line">       	i(class=&apos;fa fa-bars&apos;)= &apos; TOC &apos;</span><br><span class="line">          div(id=&apos;stoc&apos; class=&apos;stoc-article&apos;)</span><br><span class="line">            != toc(page.content, &#123;list_number: theme.toc_number&#125;)</span><br><span class="line">   .pure-u-1.pure-u-md-3-4</span><br><span class="line">      != partial(&apos;_partial/footer.pug&apos;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>代码进行前面类似的判断，如果当前文章在<code>front-matter</code>设置了<code>toc: true</code>即显示目录，否则显示侧栏。</p>
<blockquote>
<p>注：在 <code>post.pug</code> 开头要修改继承的文件为 <code>base-post</code> 。</p>
</blockquote>
<ol>
<li><p>在<code>style.scss</code>中修改基本样式</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#posttoc</span>&#123;</span><br><span class="line">  	<span class="attribute">position</span>: fixed;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">25px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.stoc-article</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0.7em</span> <span class="number">0.7em</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#stoc</span> &#123;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1em</span>;</span><br><span class="line">    <span class="selector-class">.toc</span> &#123;</span><br><span class="line">      <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">      <span class="attribute">margin</span>: <span class="number">0.5em</span>;</span><br><span class="line">      <span class="attribute">line-height</span>: <span class="number">1.8em</span>;</span><br><span class="line">      <span class="selector-tag">li</span> &#123;</span><br><span class="line">        <span class="attribute">list-style-type</span>: none;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.toc-child</span> &#123;</span><br><span class="line">      <span class="attribute">margin-left</span>: <span class="number">1em</span>;</span><br><span class="line">      <span class="attribute">padding-left</span>: <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>本地预览及推送发布均成功显示，说明这个尝试是可行的，终于算是解决了这个问题：</p>
</li>
</ol>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-02-17_00-11-45.png" alt></p>
<p>​        </p>
<p>另外，是否可以把目录伪装成侧栏中的一栏呢？</p>
<p>把代码改成如下即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#layout.pure-g</span><br><span class="line">  .pure-u-1.pure-u-md-3-4: .content_container</span><br><span class="line">    block content</span><br><span class="line">  if page.toc != true</span><br><span class="line">    .pure-u-1.pure-u-md-1-4: #sidebar</span><br><span class="line">      each item in theme.widgets</span><br><span class="line">        != partial(&apos;_widget/&apos; + item + &apos;.pug&apos;, null, &#123;cache: !config.relative_link&#125;)</span><br><span class="line">  else</span><br><span class="line">    .pure-u-1.pure-u-md-1-4: #sidebar</span><br><span class="line">      #posttoc</span><br><span class="line">        .widget</span><br><span class="line">          .widget-title</span><br><span class="line">            i(class=&apos;fa fa-bars&apos;)= &apos;  &apos; + __(&apos;contents&apos;)</span><br><span class="line">          div(id=&apos;stoc&apos; class=&apos;stoc-article&apos;)</span><br><span class="line">            != toc(page.content, &#123;list_number: theme.toc_number&#125;)</span><br><span class="line">      each item in theme.widgets</span><br><span class="line">        != partial(&apos;_widget/&apos; + item + &apos;.pug&apos;, null, &#123;cache: !config.relative_link&#125;)  </span><br><span class="line">  .pure-u-1.pure-u-md-3-4</span><br><span class="line">    != partial(&apos;_partial/footer.pug&apos;)</span><br></pre></td></tr></table></figure>
<p>把目录的样式改成侧栏，然后在目录后面遍历出侧栏其它栏目。</p>
<p>​         </p>
<h4 id="第三回"><a href="#第三回" class="headerlink" title="第三回"></a>第三回</h4><p>继续优化第二个问题固定目录栏并优化移动端隐藏目录栏。</p>
<ol>
<li>在 <code>base-post.pug</code> 中增加移动端判断并修改类名等</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#layout.pure-g</span><br><span class="line">      .pure-u-1.pure-u-md-3-4: .content_container</span><br><span class="line">        block content</span><br><span class="line">      if page.toc != true</span><br><span class="line">        .pure-u-1.pure-u-md-1-4: #sidebar</span><br><span class="line">          each item in theme.widgets</span><br><span class="line">            != partial(&apos;_widget/&apos; + item + &apos;.pug&apos;, null, &#123;cache: !config.relative_link&#125;)</span><br><span class="line">      else</span><br><span class="line">        if theme.toc_on_small_screens</span><br><span class="line">          .pure-u-1.pure-u-md-1-4: #sidebar-toc</span><br><span class="line">            div(id=&quot;sidebar-stoc&quot; class=&quot;stoc-article&quot;)</span><br><span class="line">              strong(class=&quot;stoc-title&quot;)</span><br><span class="line">                i(class=&apos;fa fa-blind&apos;)= &apos; Contents &apos;</span><br><span class="line">              div(id=&quot;stoc&quot; class=&apos;toc-nav&apos;)</span><br><span class="line">                != toc(page.content, &#123;list_number: theme.toc_number&#125;)</span><br><span class="line">        else </span><br><span class="line">          .pure-u-1-4.hidden_mid_and_down: #sidebar-toc</span><br><span class="line">            div(id=&quot;sidebar-stoc&quot; class=&quot;stoc-article&quot;)</span><br><span class="line">              strong(class=&quot;stoc-title&quot;)</span><br><span class="line">                i(class=&apos;fa fa-blind&apos;)= &apos; Contents &apos;</span><br><span class="line">              div(id=&quot;stoc&quot; class=&apos;toc-nav&apos;)</span><br><span class="line">                != toc(page.content, &#123;list_number: theme.toc_number&#125;)</span><br><span class="line">      .pure-u-1.pure-u-md-3-4</span><br><span class="line">        != partial(&apos;_partial/footer.pug&apos;)</span><br></pre></td></tr></table></figure>
<ol>
<li>修改样式</li>
</ol>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#sidebar-toc</span> &#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">padding-bottom</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">word-wrap</span>: break-word;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.stoc-article</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">1em</span> <span class="number">1em</span> <span class="number">0</span> <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: rgba(<span class="number">88</span>,<span class="number">88</span>,<span class="number">88</span>,<span class="number">0.1</span>) <span class="number">1px</span> solid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.stoc-title</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">150%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#sidebar-stoc</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: inherit;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">0.9em</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">overflow</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.stoc-fixed</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">60px</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">max-height</span>: <span class="number">81%</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.toc-nav</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0.7em</span> <span class="number">0.7em</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#stoc</span> &#123;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1em</span>;</span><br><span class="line">    <span class="selector-class">.toc</span> &#123;</span><br><span class="line">      <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">      <span class="attribute">margin</span>: <span class="number">0.5em</span>;</span><br><span class="line">      <span class="attribute">line-height</span>: <span class="number">1.8em</span>;</span><br><span class="line">      <span class="selector-tag">li</span> &#123;</span><br><span class="line">        <span class="attribute">list-style-type</span>: none;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.toc-child</span> &#123;</span><br><span class="line">      <span class="attribute">margin-left</span>: <span class="number">1em</span>;</span><br><span class="line">      <span class="attribute">padding-left</span>: <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>为了实现固定目录的功能，引入了 <code>toc.js</code>文件放在<code>source/js</code>文件夹中，然后注意在 <code>base-post.pug</code> 中 include 该 js 文件。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> toc = <span class="built_in">document</span>.getElementById(<span class="string">'sidebar-stoc'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (toc != <span class="literal">null</span>) &#123;</span><br><span class="line">	<span class="built_in">window</span>.addEventListener(<span class="string">"scroll"</span>, scrollcatelogHandler);</span><br><span class="line">	<span class="keyword">var</span> tocPosition = toc.offsetTop;</span><br><span class="line">	<span class="keyword">var</span> height_header = $(<span class="string">"#header"</span>).height();</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">scrollcatelogHandler</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">		 <span class="keyword">var</span> event = e || <span class="built_in">window</span>.event,</span><br><span class="line">		     target = event.target || event.srcElement;</span><br><span class="line">		 <span class="keyword">var</span> scrollTop = <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop;</span><br><span class="line">		 <span class="keyword">if</span> (scrollTop &gt;  tocPosition <span class="number">-60</span>) &#123;</span><br><span class="line">		     toc.classList.add(<span class="string">"stoc-fixed"</span>);</span><br><span class="line">		 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		     toc.classList.remove(<span class="string">"stoc-fixed"</span>);</span><br><span class="line">		 &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是现在正在使用的样式啦！</p>
<p>​         </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>基本实现了预期功能，前后折腾了很长时间，但是这种心想事成的感觉还是很nice的呢！</p>
<p>后面如果有新的bug再慢慢解决吧。</p>
<p>​        </p>
<h3 id="更新2019-2-17"><a href="#更新2019-2-17" class="headerlink" title="更新2019.2.17"></a>更新2019.2.17</h3><p>点击无法跳转，我枯了。。。</p>
<p>多方查找原因终于找到了根源，居然是因为<code>aplayer播放器</code>与<code>toc</code>不兼容，要是没有看到别人的文章我感觉一辈子都解决不了这个<a href="https://github.com/MoePlayer/hexo-tag-aplayer/issues/65" target="_blank" rel="noopener">问题</a>了。</p>
<p>于是把播放器配置设置开关在<code>front-matter</code>中，在需要使用音乐播放器的页面才设为<code>music: true</code>，其它用到目录的页面关闭使用。</p>
<p>​          </p>
<h3 id="更新2019-4-3"><a href="#更新2019-4-3" class="headerlink" title="更新2019.4.3"></a>更新2019.4.3</h3><p>滚条时对应标题高亮，修改如下：</p>
<p>在<code>toc.js</code>中增加对每一个标题位置的判断，并为其添加一个<code>class</code>为<code>active</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> toc = <span class="built_in">document</span>.getElementById(<span class="string">'sidebar-stoc'</span>)</span><br><span class="line"><span class="keyword">var</span> HEADER_OFFSET = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">var</span> toclink = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'toc-link'</span>);</span><br><span class="line"><span class="keyword">var</span> headerlink = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'headerlink'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (toc != <span class="literal">null</span>) &#123;</span><br><span class="line">	<span class="built_in">window</span>.addEventListener(<span class="string">"scroll"</span>, scrollcatelogHandler);</span><br><span class="line">	<span class="keyword">var</span> tocPosition = toc.offsetTop;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">scrollcatelogHandler</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">		 <span class="keyword">var</span> event = e || <span class="built_in">window</span>.event,</span><br><span class="line">		     target = event.target || event.srcElement;</span><br><span class="line">		 <span class="keyword">var</span> scrollTop = <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop;</span><br><span class="line">		 <span class="keyword">if</span> (scrollTop &gt;  tocPosition <span class="number">-60</span>) &#123;</span><br><span class="line">		     toc.classList.add(<span class="string">"stoc-fixed"</span>);</span><br><span class="line">		 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		     toc.classList.remove(<span class="string">"stoc-fixed"</span>);</span><br><span class="line">		 &#125;</span><br><span class="line">		 <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;toclink.length; i++)&#123;</span><br><span class="line">			<span class="comment">//console.log(i);</span></span><br><span class="line">			<span class="keyword">var</span> currentHeaderTop = headerlink[i].offsetTop - HEADER_OFFSET,</span><br><span class="line">				nextHeaderTop = i+<span class="number">1</span> === toclink.length ? <span class="literal">Infinity</span> : headerlink[i+<span class="number">1</span>].offsetTop - HEADER_OFFSET;</span><br><span class="line">			<span class="keyword">if</span>(currentHeaderTop &lt; scrollTop &amp;&amp; scrollTop &lt;= nextHeaderTop)&#123;</span><br><span class="line">				toclink[i].classList.add(<span class="string">'active'</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				toclink[i].classList.remove(<span class="string">'active'</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>style.scss</code>中添加<code>active</code>类的样式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#stoc &#123;</span><br><span class="line">    line-height: <span class="number">1</span>em;</span><br><span class="line">    font-weight: <span class="number">700</span>;</span><br><span class="line">    .active &#123;</span><br><span class="line">        color: #0085a1;</span><br><span class="line">        border-radius: <span class="number">4</span>px;</span><br><span class="line">        background-color: #F5F5F5;</span><br><span class="line">    &#125;</span><br><span class="line">    .toc &#123;</span><br><span class="line">      padding: <span class="number">0</span>;</span><br><span class="line">      margin: <span class="number">0.5</span>em;</span><br><span class="line">      line-height: <span class="number">1.8</span>em;</span><br><span class="line">      li &#123;</span><br><span class="line">        list-style-type: none;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .toc-child &#123;</span><br><span class="line">      margin-left: <span class="number">1</span>em;</span><br><span class="line">      padding-left: <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>建站笔记</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Vector(STL)用法与心得</title>
    <url>/posts/d20d34ce.html</url>
    <content><![CDATA[<p>STL总结系列：</p>
<ul>
<li>『<a href="https://wiki.hushhw.cn/posts/179.html">优先队列（priority_queue）用法与心得</a>』</li>
<li>『<a href="https://wiki.hushhw.cn/posts/38f87fc0.html">Map(STL)用法与心得</a>』</li>
</ul>
<p>​         </p>
<h3 id="Vector简介"><a href="#Vector简介" class="headerlink" title="Vector简介"></a>Vector简介</h3><p><strong>Vector</strong> 是C++标准程序库中的一个类，可视为会自动扩展容量的数组，以循序(Sequential)的方式维护变量集合。vector的特色有支持随机存取，在集合尾端增删元素很快，但是在集合中间增删元素比较费时。vector是C++标准程序库中的众多容器（<em>container</em>）之一。 vector以模板(泛型)方式实现，可以保存任意类型的变量，包括用户自定义的数据类型，例如：它可以是放置整数（int）类型的 vector、也可以是放置字符串（string）类型的 vector、或者放置用户自定类别（user-defined class）的 vector。</p>
<h3 id="成员函数简介与常用代码写法"><a href="#成员函数简介与常用代码写法" class="headerlink" title="成员函数简介与常用代码写法"></a>成员函数简介与常用代码写法</h3><h4 id="头文件与声明"><a href="#头文件与声明" class="headerlink" title="头文件与声明"></a>头文件与声明</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vetor&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>使用vector需要上面这个头文件。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个int类型的vector容器</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;	</span><br><span class="line"><span class="comment">//创建一个int类型的vector容器，该容器暂有10个int元素，每个元素被赋初始值为0</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">10</span>)</span></span>;	</span><br><span class="line"><span class="comment">//创建一个int类型的vector容器，该容器有5个int元素，每个元素被赋值99</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">5</span>,<span class="number">99</span>)</span></span>;</span><br><span class="line"><span class="comment">//创建一个int类型的vector容器，该容器拷贝v2，该容器具有10个值为0的元素。</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v4</span><span class="params">(v2)</span></span>;</span><br></pre></td></tr></table></figure>
<p>​       </p>
<h4 id="push-back-pop-back-添加删除元素"><a href="#push-back-pop-back-添加删除元素" class="headerlink" title="push_back(),pop_back()添加删除元素"></a>push_back(),pop_back()添加删除元素</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> A[<span class="number">10</span>]=&#123;<span class="number">9</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">		v.push_back(A[i]);	<span class="comment">//在v的尾部循环插入元素</span></span><br><span class="line">	&#125;</span><br><span class="line">	v.pop_back(); <span class="comment">//在v的尾部删除元素</span></span><br></pre></td></tr></table></figure>
<p>在vector头部添加元素，无法完成，因为vector的数据结构为数组，无法在头部插入元素，否则需要整个数组前移；在vector头部删除元素，无法完成，理由同上。</p>
<p>​            </p>
<h4 id="取某位置的元素值"><a href="#取某位置的元素值" class="headerlink" title="取某位置的元素值"></a>取某位置的元素值</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"在0位置的元素值为："</span>&lt;&lt;v.at(<span class="number">0</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"在1位置的元素值为："</span>&lt;&lt;v[<span class="number">1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h4 id="vector的遍历"><a href="#vector的遍历" class="headerlink" title="vector的遍历"></a>vector的遍历</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sort(v.begin(), v.end()); sort的时候经常用到</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator vIter; <span class="comment">//迭代器</span></span><br><span class="line"><span class="keyword">for</span> (vIter = v.begin(); vIter &lt; v.end(); vIter++)&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *vIter &lt;&lt; <span class="string">" "</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​          </p>
<h4 id="访问头部元素和尾部元素"><a href="#访问头部元素和尾部元素" class="headerlink" title="访问头部元素和尾部元素"></a>访问头部元素和尾部元素</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回尾部数据的引用</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"尾部数据的值为："</span> &lt;&lt; v.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// 返回头部数据的引用</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"头部数据的值为："</span> &lt;&lt; v.front() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>​          </p>
<h4 id="vector的大小及判空"><a href="#vector的大小及判空" class="headerlink" title="vector的大小及判空"></a>vector的大小及判空</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"vector中的最大容量为："</span> &lt;&lt; v.max_size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"vector中的元素个数为："</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"vector是否为空："</span> &lt;&lt; v.empty() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>​          </p>
<h4 id="交换元素位置"><a href="#交换元素位置" class="headerlink" title="交换元素位置"></a>交换元素位置</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">swap(v[<span class="number">0</span>],v[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
<p>​        </p>
<h4 id="升降排序"><a href="#升降排序" class="headerlink" title="升降排序"></a>升降排序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对vector进行升序排序</span></span><br><span class="line">sort(v.begin(), v.end());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对vector进行降序排序</span></span><br><span class="line">reverse(v.begin(), v.end());</span><br></pre></td></tr></table></figure>
<p>​            </p>
<h4 id="删除某个元素"><a href="#删除某个元素" class="headerlink" title="删除某个元素"></a>删除某个元素</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator vItera = v.begin();</span><br><span class="line">vItera = vItera + <span class="number">2</span>;</span><br><span class="line">v.erase(vItera);</span><br></pre></td></tr></table></figure>
<p>为什么要使用iterator来进行定位，因为数组如果要删除一个元素或者插入一个元素，会导致其他元素移动，所以不能直接进行删除</p>
<p>​       </p>
<h4 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h4><p>vector插入某元素，要使用iterator来定位某个位置</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator vInsert = v.begin();</span><br><span class="line">vInsert = vInsert + <span class="number">2</span>;</span><br><span class="line">v.insert(vInsert, <span class="number">777</span>);</span><br></pre></td></tr></table></figure>
<p>​        </p>
<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;		//使用vector需要引用这个头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;		//迭代器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintVector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c)</span></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Vector中的数据为："</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator vIter; <span class="comment">//迭代器</span></span><br><span class="line">	<span class="keyword">for</span> (vIter = c.begin(); vIter &lt; c.end(); vIter++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *vIter &lt;&lt; <span class="string">" "</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">/* --------------1.vector的创建------------------ */</span></span><br><span class="line">	<span class="comment">//创建一个int类型的vector容器</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;	</span><br><span class="line">	<span class="comment">//创建一个int类型的vector容器，该容器暂有10个int元素，每个元素被赋初始值为0</span></span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">10</span>)</span></span>;	</span><br><span class="line">	<span class="comment">//创建一个int类型的vector容器，该容器有5个int元素，每个元素被赋值99</span></span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">5</span>,<span class="number">99</span>)</span></span>;</span><br><span class="line">	<span class="comment">//创建一个int类型的vector容器，该容器拷贝v2，该容器具有10个值为0的元素。</span></span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v4</span><span class="params">(v2)</span></span>;	</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* -----2.push_back(),pop_back()添加删除元素------ */</span></span><br><span class="line">	<span class="keyword">int</span> A[<span class="number">10</span>]=&#123;<span class="number">9</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">		v.push_back(A[i]);	<span class="comment">//在v的尾部循环插入元素</span></span><br><span class="line">	&#125;</span><br><span class="line">	v.pop_back(); <span class="comment">//在v的尾部删除元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ----------3.[],at(),取某位置的元素值----------- */</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"在0位置的元素值为："</span>&lt;&lt;v.at(<span class="number">0</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"在1位置的元素值为："</span>&lt;&lt;v[<span class="number">1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ----4.begin(),end(),指向头元素、尾元素的指针---- */</span></span><br><span class="line">	<span class="comment">//sort(v.begin(), v.end()); sort的时候经常用到</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator vIter; <span class="comment">//迭代器</span></span><br><span class="line">	<span class="keyword">for</span> (vIter = v.begin(); vIter &lt; v.end(); vIter++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *vIter &lt;&lt; <span class="string">" "</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ----5.back(),front(),访问头部元素和尾部元素---- */</span></span><br><span class="line">	<span class="comment">// 返回尾部数据的引用</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"尾部数据的值为："</span> &lt;&lt; v.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 返回头部数据的引用</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"头部数据的值为："</span> &lt;&lt; v.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* -----------6.max_size()和size()------------- */</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"vector中的最大容量为："</span> &lt;&lt; v.max_size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"vector中的元素个数为："</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ----------7.empty()，判断是否为空------------ */</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"vector是否为空："</span> &lt;&lt; v.empty() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ----------8.swap(),交换两个元素位置------------ */</span></span><br><span class="line">	swap(v[<span class="number">0</span>],v[<span class="number">1</span>]);</span><br><span class="line">	PrintVector(v);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* -------------9.sort()和reverse()------------- */</span></span><br><span class="line">	<span class="comment">// 对vector进行升序排序</span></span><br><span class="line">	sort(v.begin(), v.end());</span><br><span class="line">	PrintVector(v);</span><br><span class="line">	<span class="comment">// 对vector进行降序排序</span></span><br><span class="line">	reverse(v.begin(), v.end());</span><br><span class="line">	PrintVector(v);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ----------10.erase()：删除某个元素----------- */</span></span><br><span class="line">	<span class="comment">// 删除数组的某个元素,要使用iterator来定位某个位置</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator vItera = v.begin();</span><br><span class="line">	vItera = vItera + <span class="number">2</span>;</span><br><span class="line">	v.erase(vItera);</span><br><span class="line">	PrintVector(v);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ----------11.insert(): 插入元素------------ */</span></span><br><span class="line">	<span class="comment">// vector插入某元素，要使用iterator来定位某个位置</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator vInsert = v.begin();</span><br><span class="line">	vInsert = vInsert + <span class="number">2</span>;</span><br><span class="line">	v.insert(vInsert, <span class="number">777</span>);</span><br><span class="line">	PrintVector(v);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ---------12.clear()：清除所有元素------------*/</span></span><br><span class="line">	<span class="comment">// 清除所有数据</span></span><br><span class="line">	v.clear();</span><br><span class="line">	PrintVector(v);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"vector是否为空："</span> &lt;&lt; v.empty() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="基本操作函数汇总"><a href="#基本操作函数汇总" class="headerlink" title="基本操作函数汇总"></a>基本操作函数汇总</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th style="text-align:left">用法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>begin</strong>()</td>
<td style="text-align:left">返回指向容器第一个元素的迭代器</td>
</tr>
<tr>
<td style="text-align:center"><strong>clear</strong>()</td>
<td style="text-align:left">删除所有元素</td>
</tr>
<tr>
<td style="text-align:center"><strong>empty</strong>()</td>
<td style="text-align:left">检查容器是否为空</td>
</tr>
<tr>
<td style="text-align:center"><strong>end</strong>()</td>
<td style="text-align:left">返回指向容器尾端的迭代器</td>
</tr>
<tr>
<td style="text-align:center"><strong>erase</strong>()</td>
<td style="text-align:left">删除一个元素</td>
</tr>
<tr>
<td style="text-align:center"><strong>insert</strong>()</td>
<td style="text-align:left">插入元素</td>
</tr>
<tr>
<td style="text-align:center"><strong>max_size</strong>()</td>
<td style="text-align:left">返回可以容纳的最大元素个数</td>
</tr>
<tr>
<td style="text-align:center"><strong>rbegin</strong>()</td>
<td style="text-align:left">返回指向容器最后元素的逆向迭代器</td>
</tr>
<tr>
<td style="text-align:center"><strong>rend</strong>()</td>
<td style="text-align:left">返回指向前端的逆向迭代器</td>
</tr>
<tr>
<td style="text-align:center"><strong>size</strong>()</td>
<td style="text-align:left">返回容纳的元素数</td>
</tr>
<tr>
<td style="text-align:center"><strong>swap</strong>()</td>
<td style="text-align:left">交换内容</td>
</tr>
<tr>
<td style="text-align:center"><strong>push_back</strong>()</td>
<td style="text-align:left">将元素添加到容器末尾</td>
</tr>
<tr>
<td style="text-align:center"><strong>pop_back</strong>()</td>
<td style="text-align:left">移除末元素</td>
</tr>
<tr>
<td style="text-align:center"><strong>resize</strong>()</td>
<td style="text-align:left">改变容器中可存储元素的个数</td>
</tr>
<tr>
<td style="text-align:center"><strong>front</strong>()</td>
<td style="text-align:left">访问第一个元素</td>
</tr>
<tr>
<td style="text-align:center"><strong>back</strong>()</td>
<td style="text-align:left">访问最后一个元素</td>
</tr>
<tr>
<td style="text-align:center"><strong>data</strong>()</td>
<td style="text-align:left">返回指向内存中数组第一个元素的指针</td>
</tr>
<tr>
<td style="text-align:center"><strong>capacity</strong>()</td>
<td style="text-align:left">返回当前存储空间能够容纳的元素数</td>
</tr>
<tr>
<td style="text-align:center"><strong>reserve</strong>()</td>
<td style="text-align:left">预留存储空间</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>本文参考自：</p>
<p><a href="https://zh.wikipedia.org/wiki/Vector_(STL" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Vector_(STL</a>)</p>
<p><a href="https://zh.cppreference.com/w/cpp/container/vector" target="_blank" rel="noopener">https://zh.cppreference.com/w/cpp/container/vector</a></p>
</blockquote>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Map(STL)用法与心得</title>
    <url>/posts/38f87fc0.html</url>
    <content><![CDATA[<p>STL总结系列：</p>
<ul>
<li>『<a href="https://wiki.hushhw.cn/posts/179.html">优先队列（priority_queue）用法与心得</a>』</li>
</ul>
<p>​         </p>
<h3 id="Map简介"><a href="#Map简介" class="headerlink" title="Map简介"></a>Map简介</h3><p>map是STL的一种关联式容器，他提供一对一的Hash映射功能：</p>
<ul>
<li>第一个称为关键字（key），每个关键字只能在map中出现一次。</li>
<li>第二个称为该关键字的值（value）。</li>
</ul>
<p>Map的键值对应主要用于资料一对一映射（一对一）的情况，比如一个班级中，每个学生的学号跟他的姓名就存在着一对一映射的关系。</p>
<p>map内部自建一棵红黑树，这棵树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的，也基于此，不能直接改变元素的key，因为这会破坏正确次序，要修改元素的key，必须先移除该key的元素，然后插入拥有新的key/value的元素，任何两个元素没有相同的key值。</p>
<ul>
<li>map：红黑树（查询，插入，删除都是 $O(logn)$ ）</li>
<li>unordered_map：hash结构，C ++ 11标准函式库。</li>
<li>unordered_set：hash结构，但值本身即是key。</li>
<li>hash_map：hash结构，非标准函式库。</li>
</ul>
<p>​          </p>
<h3 id="成员函数简介与常用代码写法"><a href="#成员函数简介与常用代码写法" class="headerlink" title="成员函数简介与常用代码写法"></a>成员函数简介与常用代码写法</h3><h4 id="头文件与声明"><a href="#头文件与声明" class="headerlink" title="头文件与声明"></a>头文件与声明</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>使用map需要上面这个头文件。</p>
<p>其次，一个map的声明格式为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; mapStudent;</span><br></pre></td></tr></table></figure>
<p>其中key/value的类型可以是任意你需要的类型。</p>
<p>​       </p>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用insert函数插入pair数据</span></span><br><span class="line">    mapStudent.insert(pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;(<span class="string">"r000"</span>, <span class="string">"student_zero"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用insert函数插入value_type数据</span></span><br><span class="line">    mapStudent.insert(<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::value_type(<span class="string">"r001"</span>, <span class="string">"student_one"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用数组方式插入数据</span></span><br><span class="line">    mapStudent [ <span class="string">"r123"</span> ] =  <span class="string">"student_first"</span> ;</span><br><span class="line">    mapStudent [ <span class="string">"r456"</span> ] =  <span class="string">"student_second"</span> ;</span><br></pre></td></tr></table></figure>
<p>以上三种用法，虽然都可以实现数据的插入，但是它们是有区别的，当然了第一种和第二种在效果上是完成一样的，用insert函数插入数据，在数据的 插入上涉及到集合的唯一性这个概念，即当map中有这个关键字时，insert操作是插入数据不了的，但是用数组方式就不同了，它可以覆盖以前该关键字对应的值。</p>
<p>​            </p>
<h4 id="map的大小"><a href="#map的大小" class="headerlink" title="map的大小"></a>map的大小</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> size = mapStudent.size();</span><br></pre></td></tr></table></figure>
<h4 id="map的遍历"><a href="#map的遍历" class="headerlink" title="map的遍历"></a>map的遍历</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//应用前向迭代器</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter = mapStudent.begin(); iter != mapStudent.end(); iter++)</span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">' '</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//应用反相迭代器</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::reverse_iterator iter_r;  </span><br><span class="line">    <span class="keyword">for</span>(iter_r = mapStudent.rbegin(); iter_r != mapStudent.rend(); iter_r++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;iter_r-&gt;first&lt;&lt;<span class="string">"  "</span>&lt;&lt;iter_r-&gt;second&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//数组，用于类型可以很方便数字遍历</span></span><br></pre></td></tr></table></figure>
<p>​          </p>
<h4 id="查找并获取map中的元素"><a href="#查找并获取map中的元素" class="headerlink" title="查找并获取map中的元素"></a>查找并获取map中的元素</h4><p>用find函数来定位数据出现位置，它返回的一个迭代器，当数据出现时，它返回数据所在位置的迭代器，如果map中没有要查找的数据，它返回的迭代器等于end函数返回的迭代器。</p>
<p>查找map中是否包含某个关键字条目用find()方法，传入的参数是要查找的key，在这里需要提到的是<strong>begin()</strong>和<strong>end()</strong>两个成员，分别代表map对象中第一个条目和最后一个条目，这两个数据的类型是iterator。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">iter = mapStudent.find(<span class="string">"r123"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(iter != mapStudent.end())</span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;<span class="string">"Find, the value is"</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="string">"Do not Find"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>​          </p>
<h4 id="从map中删除元素"><a href="#从map中删除元素" class="headerlink" title="从map中删除元素"></a>从map中删除元素</h4><p>移除某个map中某个条目用erase（）</p>
<p>该成员方法的定义如下：</p>
<ul>
<li>iterator erase（iterator it);//通过一个条目对象删除</li>
<li>iterator erase（iterator first，iterator last）//删除一个范围</li>
<li>size_type erase(const Key&amp;key);//通过关键字删除</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//迭代器删除</span></span><br><span class="line">iter = mapStudent.find(<span class="string">"r123"</span>);</span><br><span class="line">mapStudent.erase(iter);</span><br><span class="line"></span><br><span class="line"><span class="comment">//用关键字删除</span></span><br><span class="line"><span class="keyword">int</span> n = mapStudent.erase(<span class="string">"r123"</span>);<span class="comment">//如果删除了會返回1，否則返回0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用迭代器范围删除 : 把整個map清空</span></span><br><span class="line">mapStudent.erase(mapStudent.begin(), mapStudent.end());</span><br><span class="line"><span class="comment">//等同於mapStudent.clear()</span></span><br></pre></td></tr></table></figure>
<p>​          </p>
<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;		//迭代器</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/* --------------1.map的声明及迭代器声明------------------ */</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; mapStudent;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator iter;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::reverse_iterator iter_r;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* --------------2.map插入数据------------------ */</span></span><br><span class="line">    <span class="comment">//用insert函数插入pair数据</span></span><br><span class="line">    mapStudent.insert(pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;(<span class="string">"r000"</span>, <span class="string">"student_zero"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用insert函数插入value_type数据</span></span><br><span class="line">    mapStudent.insert(<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::value_type(<span class="string">"r001"</span>, <span class="string">"student_one"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用数组方式插入数据</span></span><br><span class="line">    mapStudent [ <span class="string">"r123"</span> ] =  <span class="string">"student_first"</span> ;</span><br><span class="line">    mapStudent [ <span class="string">"r456"</span> ] =  <span class="string">"student_second"</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* --------------3.map的大小------------------ */</span></span><br><span class="line">    <span class="keyword">int</span> nsize = mapStudent.size();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* --------------4.map的遍历------------------ */</span></span><br><span class="line">    <span class="comment">//traversal</span></span><br><span class="line">    <span class="keyword">for</span>(iter = mapStudent.begin(); iter != mapStudent.end(); iter++)</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">" "</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(iter_r = mapStudent.rbegin(); iter_r != mapStudent.rend(); iter_r++)</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;iter_r-&gt;first&lt;&lt;<span class="string">" "</span>&lt;&lt;iter_r-&gt;second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* --------------5.map的查找------------------ */</span></span><br><span class="line">    iter = mapStudent.find(<span class="string">"r123"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(iter != mapStudent.end())</span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;<span class="string">"Find, the value is "</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;<span class="string">"Do not Find"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* --------------6.map删除元素------------------ */</span></span><br><span class="line">    <span class="comment">//迭代器删除</span></span><br><span class="line">    iter = mapStudent.find(<span class="string">"r123"</span>);</span><br><span class="line">    mapStudent.erase(iter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用关键字删除</span></span><br><span class="line">    <span class="keyword">int</span> n = mapStudent.erase(<span class="string">"r123"</span>);<span class="comment">//如果删除了會返回1，否則返回0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//用迭代器范围删除 : 把整個map清空</span></span><br><span class="line">    mapStudent.erase(mapStudent.begin(), mapStudent.end());</span><br><span class="line">    <span class="comment">//等同於mapStudent.clear()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="基本操作函数汇总"><a href="#基本操作函数汇总" class="headerlink" title="基本操作函数汇总"></a>基本操作函数汇总</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th style="text-align:left">用法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>begin</strong>()</td>
<td style="text-align:left">返回指向map头部的迭代器</td>
</tr>
<tr>
<td style="text-align:center"><strong>clear</strong>()</td>
<td style="text-align:left">删除所有元素</td>
</tr>
<tr>
<td style="text-align:center"><strong>count</strong>()</td>
<td style="text-align:left">返回指定元素出现的次数</td>
</tr>
<tr>
<td style="text-align:center"><strong>empty</strong>()</td>
<td style="text-align:left">如果map为空则返回true</td>
</tr>
<tr>
<td style="text-align:center"><strong>end</strong>()</td>
<td style="text-align:left">返回指向map末尾的迭代器</td>
</tr>
<tr>
<td style="text-align:center"><strong>equal_range</strong>()</td>
<td style="text-align:left">返回特殊条目的迭代器对</td>
</tr>
<tr>
<td style="text-align:center"><strong>erase</strong>()</td>
<td style="text-align:left">删除一个元素</td>
</tr>
<tr>
<td style="text-align:center"><strong>find</strong>()</td>
<td style="text-align:left">查找一个元素</td>
</tr>
<tr>
<td style="text-align:center"><strong>get_allocator</strong>()</td>
<td style="text-align:left">返回map的配置器</td>
</tr>
<tr>
<td style="text-align:center"><strong>insert</strong>()</td>
<td style="text-align:left">插入元素</td>
</tr>
<tr>
<td style="text-align:center"><strong>key_comp</strong>()</td>
<td style="text-align:left">返回比较元素key的函数</td>
</tr>
<tr>
<td style="text-align:center"><strong>lower_bound</strong>()</td>
<td style="text-align:left">返回键值&gt;=给定元素的第一个位置</td>
</tr>
<tr>
<td style="text-align:center"><strong>max_size</strong>()</td>
<td style="text-align:left">返回可以容纳的最大元素个数</td>
</tr>
<tr>
<td style="text-align:center"><strong>rbegin</strong>()</td>
<td style="text-align:left">返回一个指向map尾部的逆向迭代器</td>
</tr>
<tr>
<td style="text-align:center"><strong>rend</strong>()</td>
<td style="text-align:left">返回一个指向map头部的逆向迭代器</td>
</tr>
<tr>
<td style="text-align:center"><strong>size</strong>()</td>
<td style="text-align:left">返回map中元素的个数</td>
</tr>
<tr>
<td style="text-align:center"><strong>swap</strong>()</td>
<td style="text-align:left">交换两个map</td>
</tr>
<tr>
<td style="text-align:center"><strong>upper_bound</strong>()</td>
<td style="text-align:left">返回键值&gt;给定元素的第一个位置</td>
</tr>
<tr>
<td style="text-align:center"><strong>value_comp</strong>()</td>
<td style="text-align:left">返回比较元素value的函数</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>本文参考自：</p>
<p><a href="https://www.cnblogs.com/fnlingnzb-learner/p/5833051.html" target="_blank" rel="noopener">https://www.cnblogs.com/fnlingnzb-learner/p/5833051.html</a></p>
<p><a href="http://mropengate.blogspot.com/2015/12/cc-map-stl.html" target="_blank" rel="noopener">http://mropengate.blogspot.com/2015/12/cc-map-stl.html</a></p>
<p><a href="http://www.cplusplus.com/reference/map/map/key_comp/" target="_blank" rel="noopener">http://www.cplusplus.com/reference/map/map/key_comp/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>【动态规划-最大连续子序列】HDU 1003 Max Sum</title>
    <url>/posts/a996c21e.html</url>
    <content><![CDATA[<blockquote>
<p>求一段数列的最大连续子序列和，然后让你输出三个数字，</p>
<p>分别是该段数列的最大连续子序列和的值，最大连续子序列第一个数的下标（下标从1开始），最大连续子序列最后一个数的下标。</p>
</blockquote>
<a id="more"></a>
<p>​         </p>
<ul>
<li>题目地址：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1003" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1003</a></li>
</ul>
<p>​         </p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>把数列第一个数存入dp[0].</p>
<p>状态转移方程，max( dp[i-1] + a[i] , a[i] )</p>
<h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>, max = <span class="number">-1001</span>;</span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">0</span>, last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i<span class="number">-1</span>]+a[i]&gt;=a[i])&#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + a[i];</span><br><span class="line">                end = i;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i] = a[i];</span><br><span class="line">                start = end = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(max&lt;dp[i])&#123;</span><br><span class="line">                max = dp[i];</span><br><span class="line">                first = start;</span><br><span class="line">                last = end;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d:\n%d %d %d\n"</span>, ++i, max, first+<span class="number">1</span>, last+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(T!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>OJ刷题</category>
      </categories>
      <tags>
        <tag>OJ</tag>
        <tag>动态规划</tag>
        <tag>hdu</tag>
      </tags>
  </entry>
  <entry>
    <title>【动态规划-多重背包】HDU 2844 Coins</title>
    <url>/posts/dab6998b.html</url>
    <content><![CDATA[<blockquote>
<p>n种硬币，每个硬币的值ai，有ci个，求能组成多少个不大于m的不同的金额。</p>
</blockquote>
<a id="more"></a>
<p>​         </p>
<ul>
<li>题目地址：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2844" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=2844</a></li>
</ul>
<p>​         </p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>典型的多重背包</p>
<h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">105</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[MAXN]; <span class="comment">//表示当前价值是否可以达到（0不可达，1可达）</span></span><br><span class="line"><span class="keyword">int</span> a[MAXM]; <span class="comment">//value</span></span><br><span class="line"><span class="keyword">int</span> c[MAXM]; <span class="comment">//num</span></span><br><span class="line"><span class="keyword">int</span> cnt[MAXN]; <span class="comment">//表示达到j状态i物品的使用次数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)!=EOF)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span> &amp;&amp; m==<span class="number">0</span>) <span class="comment">//m可能为负数</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, a + i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, c + i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = a[i]; j &lt;= m; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j-a[i]]==<span class="number">1</span> &amp;&amp; dp[j]==<span class="number">0</span> &amp;&amp; cnt[j-a[i]]&lt;c[i])&#123;</span><br><span class="line">                    cnt[j] = cnt[j - a[i]] + <span class="number">1</span>;</span><br><span class="line">                    dp[j] = <span class="number">1</span>;</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>OJ刷题</category>
      </categories>
      <tags>
        <tag>OJ</tag>
        <tag>动态规划</tag>
        <tag>hdu</tag>
      </tags>
  </entry>
  <entry>
    <title>【动态规划-完全背包】HDU 2159 FATE</title>
    <url>/posts/2e53604.html</url>
    <content><![CDATA[<blockquote>
<p>最近xhd正在玩一款叫做FATE的游戏，为了得到极品装备，xhd在不停的杀怪做任务。</p>
<p>久而久之xhd开始对杀怪产生的厌恶感，但又不得不通过杀怪来升完这最后一级。</p>
<p>现在的问题是，xhd升掉最后一级还需n的经验值，xhd还留有m的忍耐度，</p>
<p>每杀一个怪xhd会得到相应的经验，并减掉相应的忍耐度。</p>
<p>当忍耐度降到0或者0以下时，xhd就不会玩这游戏。</p>
<p>xhd还说了他最多只杀s只怪。请问他能升掉这最后一级吗？</p>
</blockquote>
<a id="more"></a>
<p>​         </p>
<ul>
<li>题目地址：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2159" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=2159</a></li>
</ul>
<p>​         </p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>完全背包问题：</p>
<p>忍耐度m，杀怪数s</p>
<p><code>dp[m][s]</code>表示在忍耐度为j，杀了k个怪的状态下所对应的经验值</p>
<h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> a[MAXN], b[MAXN]; <span class="comment">//得到的经验值和会减掉的忍耐度</span></span><br><span class="line"><span class="keyword">int</span> dp[MAXN][MAXN]; <span class="comment">//表示在忍耐度为j，杀了k个怪的状态下所对应的经验值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, k, s;<span class="comment">//还需经验，忍耐度，怪的种数和最多的杀怪数</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;m,&amp;k,&amp;s)!=EOF)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;k; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a[i], &amp;b[i]);</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = b[i]; j &lt;= m; j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= s; k++)</span><br><span class="line">                    dp[j][k] = max(dp[j][k], dp[j-b[i]][k<span class="number">-1</span>]+a[i]);</span><br><span class="line">        <span class="keyword">if</span>(dp[m][s]&gt;=n)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][s]&gt;=n)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, m - i);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>OJ刷题</category>
      </categories>
      <tags>
        <tag>OJ</tag>
        <tag>动态规划</tag>
        <tag>hdu</tag>
      </tags>
  </entry>
  <entry>
    <title>【动态规划-0-1背包】HDU 2639 Bone Collector II</title>
    <url>/posts/e729ac5b.html</url>
    <content><![CDATA[<blockquote>
<p>给定背包容量，骨头的个数和每个骨头的价值，这次不是求在背包容量允许的情况下，最多装的价值，而是求在背包容量内，可以装的第k大价值，如果没有第k个最大值，那么输出0</p>
<p>输入包括多组样例，第一行输入一个T,样例的个数，接下来每个样例都有三行，第一行包括三个整数，N,V,K,分别代表骨头的个数，背包的容量，我们需要输出的第K个最大值，</p>
<p>第二行包括N个数，分别代表骨头的数量和接下来一行有N个数，分别表示每种骨头的价值。</p>
<p>输出第K个最大价值，每个样例输出一行</p>
</blockquote>
<a id="more"></a>
<p>​         </p>
<ul>
<li>题目地址：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2639" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=2639</a></li>
</ul>
<p>​         </p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>常规的0-1背包是求V体积下能装的物品的最大价值，而本题求的是第K大价值。</p>
<p>常规0-1背包的状态转移公式：<code>dp[j]=max(dp[j],dp[j-w[i]]+v[i])</code></p>
<p>而本题的区别是要求第K大价值，于是将数组升级为二维<code>dp[V][K]</code>，表示背包容量为V能装下的第K大价值，对于每一个V都保存着K个值，从大到小排序。</p>
<p>还是一样的二重循环，然后多加一重循环，对于<code>dp[j]</code>，需要计算<code>dp[j-bone[i].b]+bone[i].a</code>，然后对<code>dp[j-bone[i].b]+bone[i].a</code>的K个值与<code>dp[j]</code>的K个值进行合并，合并后得到的新的K个值返回保存<code>dp[j]</code>中。</p>
<p>这样就可以实现背包的K优解的计算，最后输出<code>dp[V][K]</code>（K从1开始）。</p>
<h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN1 = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN2 = <span class="number">35</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[MAXN1][MAXN2];</span><br><span class="line"><span class="keyword">int</span> q1[MAXN2], q2[MAXN2];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125; bone[MAXN1];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="keyword">int</span> N, V, K;</span><br><span class="line">        <span class="keyword">int</span> x,y,z;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;N, &amp;V, &amp;K);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;bone[i].a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;bone[i].b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=V; j&gt;=bone[i].b; j--)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">1</span>; p&lt;=K; p++)&#123;</span><br><span class="line">                    q1[p] = dp[j][p];</span><br><span class="line">                    q2[p] = dp[j-bone[i].b][p]+bone[i].a;</span><br><span class="line">                &#125;</span><br><span class="line">                q1[K+<span class="number">1</span>]=q2[K+<span class="number">1</span>]=<span class="number">-1</span>;</span><br><span class="line">                x=y=z=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(z&lt;=K &amp;&amp; (q1[x]!=<span class="number">-1</span> || q2[y]!=<span class="number">-1</span>))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(q1[x]&gt;q2[y]) dp[j][z] = q1[x++];</span><br><span class="line">                    <span class="keyword">else</span> dp[j][z] = q2[y++];</span><br><span class="line">                    <span class="keyword">if</span>(dp[j][z]!=dp[j][z<span class="number">-1</span>]) z++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[V][K]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>OJ刷题</category>
      </categories>
      <tags>
        <tag>OJ</tag>
        <tag>动态规划</tag>
        <tag>hdu</tag>
      </tags>
  </entry>
  <entry>
    <title>【动态规划-0-1背包】HDU 2602 Bone Collector</title>
    <url>/posts/b0fea3aa.html</url>
    <content><![CDATA[<p>一位骨头收集者有一个体积为V的背包，不同的骨头有不同的价值和体积，现在考虑到每块骨头的价值及体积，计算出能收集的骨头最大的价值。</p>
<a id="more"></a>
<p>​         </p>
<ul>
<li>题目地址：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2602" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=2602</a></li>
</ul>
<p>​         </p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>0-1背包常规题</p>
<p>​       </p>
<h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125; bone[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="keyword">int</span> N, V;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;N, &amp;V);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;bone[i].a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;bone[i].b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &gt;= bone[i].b; j--)&#123;</span><br><span class="line">                dp[j] = max(dp[j], dp[j - bone[i].b] + bone[i].a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[V]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>OJ刷题</category>
      </categories>
      <tags>
        <tag>OJ</tag>
        <tag>动态规划</tag>
        <tag>hdu</tag>
      </tags>
  </entry>
  <entry>
    <title>【动态规划-0-1背包】HDU 1864 最大报销额</title>
    <url>/posts/44777a5c.html</url>
    <content><![CDATA[<blockquote>
<p>现有一笔经费可以报销一定额度的发票。允许报销的发票类型包括买图书（A类）、文具（B类）、差旅（C类），要求每张发票的总额不得超过1000元，每张发票上，单项物品的价值不得超过600元。现请你编写程序，在给出的一堆发票中找出可以报销的、不超过给定额度的最大报销额。</p>
<p>测试输入包含若干测试用例。每个测试用例的第1行包含两个正数 Q 和 N，其中 Q 是给定的报销额度，N（&lt;=30）是发票张数。随后是 N 行输入，每行的格式为：<br>m Type_1:price_1 Type_2:price_2 … Type_m:price_m<br>其中正整数 m 是这张发票上所开物品的件数，Type_i 和 price_i 是第 i 项物品的种类和价值。物品种类用一个大写英文字母表示。当N为0时，全部输入结束，相应的结果不要输出。</p>
<p>对每个测试用例输出1行，即可以报销的最大数额，精确到小数点后2位。</p>
</blockquote>
<a id="more"></a>
<p>​         </p>
<ul>
<li>题目地址：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1864" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1864</a></li>
</ul>
<p>​         </p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题作为2007年浙大计算机研究生复试上机考试题个人认为是非常成功的，因为很多细节点需要去把握。</p>
<p>本题属于简单的0-1背包，但是前面的细节限制很容易出错：</p>
<ul>
<li>只有A，B，C三种类型的发票，如测试数据一中的X发票就不报销</li>
<li>物品单项的报销额不超过600，如测试数据一第三张发票两个A类需要累加后计算</li>
<li>每张发票总额不超过1000</li>
</ul>
<p>除了限制条件外，还有一些需要处理的点：</p>
<ul>
<li>报销额都为保留两位小数的浮点数，遍历起来不方便，可以采取都乘100，最后结果除100的方式来处理。</li>
<li>数据输入处理很麻烦，可以用%*c来过滤空格</li>
</ul>
<p>解决完这些问题，剩下就是0-1背包了。</p>
<p>​       </p>
<h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">3000050</span>;<span class="comment">//发票张数30*每张总额1000*放大倍数100 = 3000000</span></span><br><span class="line"><span class="keyword">int</span> dp[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">&#125; invoice[<span class="number">35</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> Q;</span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">    <span class="keyword">int</span> a,b,c,t;</span><br><span class="line">    <span class="keyword">bool</span> flag;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%lf%d"</span>,&amp;Q,&amp;N)!=EOF &amp;&amp; N)&#123;</span><br><span class="line">        q = (<span class="keyword">int</span>)(Q * <span class="number">100</span>);</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;invoice[i].m);</span><br><span class="line">            a = b = c = <span class="number">0</span>;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; invoice[i].m; j++)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%*c%c:%lf"</span>, &amp;ch, &amp;y);</span><br><span class="line">                t = (<span class="keyword">int</span>)(y * <span class="number">100.0</span>);</span><br><span class="line">                <span class="keyword">if</span>(ch == <span class="string">'A'</span>)</span><br><span class="line">                    a += t;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">'B'</span>)</span><br><span class="line">                    b += t;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">'C'</span>)</span><br><span class="line">                    c += t;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a+b+c&lt;=<span class="number">100000</span> &amp;&amp; a&lt;=<span class="number">60000</span> &amp;&amp; b &lt;= <span class="number">60000</span> &amp;&amp; c &lt;= <span class="number">60000</span> &amp;&amp; flag)</span><br><span class="line">                invoice[i].sum = a + b + c;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                invoice[i].sum = q + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = q; j &gt;= invoice[i].sum; j--)&#123;</span><br><span class="line">                dp[j] = max(dp[j], dp[j - invoice[i].sum] + invoice[i].sum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>, (dp[q] / <span class="number">100.0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>OJ刷题</category>
      </categories>
      <tags>
        <tag>OJ</tag>
        <tag>动态规划</tag>
        <tag>hdu</tag>
      </tags>
  </entry>
  <entry>
    <title>【动态规划-0-1背包】HDU 2955 Robberies</title>
    <url>/posts/b883e502.html</url>
    <content><![CDATA[<blockquote>
<p>有一个小偷要偷银行的钱，可是他偷每家银行总是有一定的概率被抓，现在给了你一个概率P，只要他被抓的概率乘积不大与P，他就是安全的。问你在他安全的情况下，他最多可以偷多少钱。</p>
<p>首先给定一个数T，表示的是有T组数据，每组数据首先给出一个小数p和一个整数n，分别表示的是最大的能够被抓住的概率，如果&gt;这个概率这个强盗的母亲就不让他去，然后下面有n行数据，每行有两个数，分别表示这个银行的钱数和被抓住的概率。</p>
</blockquote>
<a id="more"></a>
<p>​         </p>
<ul>
<li>题目地址：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2955" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=2955</a></li>
</ul>
<p>​         </p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>典型的0-1背包问题</p>
<p>本题特殊点在于浮点数不好遍历，于是转成所有银行的总资产为背包容量V，求最大的逃跑概率。</p>
<p>题目中给的是被抓的概率，所以求逃跑概率为<code>1-p[i]</code>。</p>
<p>状态转移方程：<code>dp[j] = max(dp[j], dp[j - bank[i].Mj] * bank[i].Pj)</code>。</p>
<h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> dp[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Mj;</span><br><span class="line">    <span class="keyword">double</span> Pj;</span><br><span class="line">&#125; bank[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n, sum;</span><br><span class="line">        <span class="keyword">double</span> p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%d"</span>, &amp;p, &amp;n);</span><br><span class="line">        p = <span class="number">1.0</span> - p;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%lf"</span>, &amp;bank[i].Mj, &amp;bank[i].Pj);</span><br><span class="line">            bank[i].Pj = <span class="number">1.0</span> - bank[i].Pj;</span><br><span class="line">            sum += bank[i].Mj;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = sum; j &gt;= bank[i].Mj; j--)&#123;</span><br><span class="line">                dp[j] = max(dp[j], dp[j - bank[i].Mj] * bank[i].Pj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = sum; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]-p&gt;<span class="number">0.000000001</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>OJ刷题</category>
      </categories>
      <tags>
        <tag>OJ</tag>
        <tag>动态规划</tag>
        <tag>hdu</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo主题插入音乐之aplayer音乐播放器</title>
    <url>/posts/a84d1ef1.html</url>
    <content><![CDATA[<p>今天折腾的点是给博客中插入音乐，找到的具体可行的方案有：</p>
<ul>
<li>使用音乐平台提供的插件 <code>体验很差</code></li>
<li>使用<a href="https://github.com/MoePlayer/hexo-tag-aplayer" target="_blank" rel="noopener">hexo-tag-aplayer</a>插件 <code>排了坑后体验极佳</code></li>
</ul>
<a id="more"></a>
<p>​        </p>
<h2 id="1-使用音乐平台提供插件"><a href="#1-使用音乐平台提供插件" class="headerlink" title="1. 使用音乐平台提供插件"></a>1. 使用音乐平台提供插件</h2><p>以网易云为例，网页端点击<code>生成外链播放器</code>即可生成外链代码，如我的某个歌单生成<a href="https://music.163.com/#/outchain/0/2205641361/" target="_blank" rel="noopener">外链</a>。</p>
<p>可以在自己博客页面中嵌入插件:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;iframe </span><br><span class="line"> frameborder=<span class="string">"no"</span> border=<span class="string">"0"</span> </span><br><span class="line"> marginwidth=<span class="string">"0"</span> marginheight=<span class="string">"0"</span> </span><br><span class="line"> width=<span class="number">530</span> height=<span class="number">310</span> </span><br><span class="line"> src=<span class="string">"//music.163.com/outchain/player?type=0&amp;id=2205641361&amp;auto=0&amp;height=430"</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/iframe&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果：</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="530" height="330" src="//music.163.com/outchain/player?type=0&id=2205641361&auto=0&height=430"></iframe>

<p>缺点非常明显，而最不能忍得是网易音乐有些音乐因为版权保护，没办法生成外链：</p>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-01-22_22-55-46.png" alt></p>
<p>​         </p>
<h2 id="2-使用-hexo-tag-aplayer-插件"><a href="#2-使用-hexo-tag-aplayer-插件" class="headerlink" title="2. 使用 hexo-tag-aplayer 插件"></a>2. 使用 hexo-tag-aplayer 插件</h2><p><a href="https://github.com/MoePlayer/hexo-tag-aplayer" target="_blank" rel="noopener">hexo-tag-aplayer</a> 就是将 <a href="https://github.com/DIYgod/APlayer" target="_blank" rel="noopener">APlayer</a> 内嵌入博客页面的 Hexo 插件。</p>
<p>安装执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install --save hexo-tag-aplayer</span><br></pre></td></tr></table></figure>
<p>原先 <code>hexo-tag-aplayer</code> 不支持 <code>MetingJS</code>，使得需要图片url，音乐url等等参数，操作起来都很麻烦，需要去音乐网站扒音乐播放链接或者下载下来存储在七牛云或本地，要了解具体参数和使用可以查看其<a href="https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md" target="_blank" rel="noopener">中文文档</a>了解。</p>
<h3 id="3-MeingJS-支持-3-0-新功能"><a href="#3-MeingJS-支持-3-0-新功能" class="headerlink" title="3. MeingJS 支持 (3.0 新功能)"></a>3. MeingJS 支持 (3.0 新功能)</h3><p><a href="https://github.com/metowolf/MetingJS" target="_blank" rel="noopener">MetingJS</a> 是基于<a href="https://github.com/metowolf/Meting" target="_blank" rel="noopener">Meting API</a> 的 APlayer 衍生播放器，引入 MetingJS 后，播放器将支持对于 QQ音乐、网易云音乐、虾米、酷狗、百度等平台的音乐播放。</p>
<p>如果想在本插件中使用 MetingJS，请在 Hexo 配置文件 <code>_config.yml</code> 中设置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aplayer:</span><br><span class="line">  meting: true</span><br></pre></td></tr></table></figure>
<p>接着就可以 在文章中使用 MetingJS 播放器了，例如打开网易云音乐网站找到这首<code>coldplay</code>的《<em>Viva la Vida</em>》，从url中可以得到其<code>id</code>为<code>3986040</code>，按下面格式即可使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% meting &quot;3986040&quot; &quot;netease&quot; &quot;song&quot; &quot;theme:#555&quot; &quot;mutex:true&quot; &quot;listmaxheight:340px&quot; &quot;preload:auto&quot; %&#125;</span><br></pre></td></tr></table></figure>
<p>效果：</p>

    <div id="aplayer-BrfrwBwf" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="3986040" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div>
<p>​       </p>
<p>再来一个歌单模板：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% meting &quot;627070825&quot; &quot;netease&quot; &quot;playlist&quot; &quot;theme:#555&quot; &quot;mutex:true&quot; &quot;listmaxheight:340px&quot; &quot;preload:auto&quot; %&#125;</span><br></pre></td></tr></table></figure>

    <div id="aplayer-tbaVolPZ" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="627070825" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div>
<p>​         </p>
<p>有关选项列表如下:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td><strong>必须值</strong></td>
<td>歌曲 id / 播放列表 id / 相册 id / 搜索关键字</td>
</tr>
<tr>
<td>server</td>
<td><strong>必须值</strong></td>
<td>音乐平台: <code>netease</code>, <code>tencent</code>, <code>kugou</code>, <code>xiami</code>, <code>baidu</code></td>
</tr>
<tr>
<td>type</td>
<td><strong>必须值</strong></td>
<td><code>song</code>, <code>playlist</code>, <code>album</code>, <code>search</code>, <code>artist</code></td>
</tr>
<tr>
<td>fixed</td>
<td><code>false</code></td>
<td>开启固定模式</td>
</tr>
<tr>
<td>mini</td>
<td><code>false</code></td>
<td>开启迷你模式</td>
</tr>
<tr>
<td>loop</td>
<td><code>all</code></td>
<td>列表循环模式：<code>all</code>, <code>one</code>,<code>none</code></td>
</tr>
<tr>
<td>order</td>
<td><code>list</code></td>
<td>列表播放模式： <code>list</code>, <code>random</code></td>
</tr>
<tr>
<td>volume</td>
<td>0.7</td>
<td>播放器音量</td>
</tr>
<tr>
<td>lrctype</td>
<td>0</td>
<td>歌词格式类型</td>
</tr>
<tr>
<td>listfolded</td>
<td><code>false</code></td>
<td>指定音乐播放列表是否折叠</td>
</tr>
<tr>
<td>storagename</td>
<td><code>metingjs</code></td>
<td>LocalStorage 中存储播放器设定的键名</td>
</tr>
<tr>
<td>autoplay</td>
<td><code>true</code></td>
<td>自动播放，移动端浏览器暂时不支持此功能</td>
</tr>
<tr>
<td>mutex</td>
<td><code>true</code></td>
<td>该选项开启时，如果同页面有其他 aplayer 播放，该播放器会暂停</td>
</tr>
<tr>
<td>listmaxheight</td>
<td><code>340px</code></td>
<td>播放列表的最大长度</td>
</tr>
<tr>
<td>preload</td>
<td><code>auto</code></td>
<td>音乐文件预载入模式，可选项： <code>none</code>, <code>metadata</code>, <code>auto</code></td>
</tr>
<tr>
<td>theme</td>
<td><code>#ad7a86</code></td>
<td>播放器风格色彩设置</td>
</tr>
</tbody>
</table>
</div>
<p>​         </p>
<h3 id="4-遇到的坑"><a href="#4-遇到的坑" class="headerlink" title="4. 遇到的坑"></a>4. 遇到的坑</h3><p>我原先是用的主题是<code>yilia</code>，非常喜欢它的相册功能，于是换到现在的主题后把该功能移植了过来，如果有小伙伴也想要实现可以参看我的这篇文章：『<a href="https://wiki.hushhw.cn/posts/6ff333ed.html">Hexo主题maupassant博客搭建相册</a>』。</p>
<p>当把<a href="https://github.com/MoePlayer/hexo-tag-aplayer" target="_blank" rel="noopener">hexo-tag-aplayer</a> 配置好并且用几个页面测试后，发现相册功能失效了，查找问题后发现在<code>ins.js</code>中自动加了下面这些代码导致的失效。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css"</span>&gt;</span><br><span class="line">&lt;script src=<span class="string">"https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="https:/</span><span class="regexp">/cdn.jsdelivr.net/</span>npm/meting@<span class="number">1.2</span>/dist/Meting.min.js<span class="string">"&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>经过一番在网上寻找后无果后，于是决定仔细研读官方文档，查看官方的<a href="https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md" target="_blank" rel="noopener">中文文档</a>后发现，可能是插件的自动脚本插入功能导致的，使得<code>ins.js</code>中自动插入了代码，于是关闭该功能试试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aplayer:</span><br><span class="line">  asset_inject: false</span><br></pre></td></tr></table></figure>
<p>关闭后确实解决了问题，相册功能恢复，下面的问题就是自己配置插件，在需要的地方引用代码了。</p>
<h4 id="4-1-恢复-post-页面插件功能"><a href="#4-1-恢复-post-页面插件功能" class="headerlink" title="4.1. 恢复 post 页面插件功能"></a>4.1. 恢复 post 页面插件功能</h4><p>我是使用的主题<a href="https://github.com/tufu9441/maupassant-hexo" target="_blank" rel="noopener">maupassant-hexo</a>都是用的是<code>.pug</code>格式，其他小伙伴根据自己的渲染文件进行修改。</p>
<p>主题配置页面写入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 播放器</span><br><span class="line">aplayer:</span><br><span class="line"> enable: true</span><br></pre></td></tr></table></figure>
<p>新建文件<code>aplayer.pug</code>放在<code>/layout/_partial</code>文件夹下，写入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">link(rel=&quot;stylesheet&quot; type=&apos;text/css&apos;, href=&quot;https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css&quot;)</span><br><span class="line">script(type=&apos;text/javascript&apos;, src=&quot;https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js&quot;)</span><br><span class="line">script(type=&apos;text/javascript&apos;, src=&quot;https://cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js&quot;)</span><br></pre></td></tr></table></figure>
<p>最后在<code>post.pug</code>中引用即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if theme.aplayer.enable</span><br><span class="line">  include _partial/aplayer.pug</span><br></pre></td></tr></table></figure>
<p>这样在文章页面可以使用该插件了。</p>
<p>可以通过本地<code>hexo server</code>来检查一下文章页面<code>head</code>中有没有成功引入。</p>
<p>​       </p>
<h4 id="4-2-在非-post-页面使用插件功能"><a href="#4-2-在非-post-页面使用插件功能" class="headerlink" title="4.2. 在非 post 页面使用插件功能"></a>4.2. 在非 post 页面使用插件功能</h4><p>我在<code>/source/</code>文件夹下自定义的页面<code>life</code>，我需要该页面使用插件，最简单的方式就是直接在<code>index.md</code>中引用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css"</span>&gt;</span><br><span class="line">&lt;script src=<span class="string">"https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="https:/</span><span class="regexp">/cdn.jsdelivr.net/</span>npm/meting@<span class="number">1.2</span>/dist/Meting.min.js<span class="string">"&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-01-22_23-54-20.png" alt></p>
<p>最终效果：</p>
<p> <img src="https://photo.hushhw.cn/images/Snipaste_2019-01-22_23-55-27.png" alt></p>
<p>​            </p>
<h4 id="4-3-与-toc-不兼容（2019-2-17-更新）"><a href="#4-3-与-toc-不兼容（2019-2-17-更新）" class="headerlink" title="4.3. 与 toc 不兼容（2019.2.17 更新）"></a>4.3. 与 toc 不兼容（2019.2.17 更新）</h4><p>toc 中文点击无法跳转，我枯了。。。（比如本页面）</p>
<p>多方查找原因终于找到了根源，居然是因为<code>aplayer播放器</code>与<code>toc</code>不兼容，要是没有看到别人的文章我感觉一辈子都解决不了这个<a href="https://github.com/MoePlayer/hexo-tag-aplayer/issues/65" target="_blank" rel="noopener">问题</a>了。</p>
<p>于是把播放器配置设置开关在<code>front-matter</code>中，在需要使用音乐播放器的页面才设为<code>music: true</code>，其它用到目录的页面关闭使用。</p>
<p>​             </p>
<h4 id="4-4-toc-兼容问题解决（2019-4-24-更新）"><a href="#4-4-toc-兼容问题解决（2019-4-24-更新）" class="headerlink" title="4.4. toc 兼容问题解决（2019.4.24 更新）"></a>4.4. toc 兼容问题解决（2019.4.24 更新）</h4><p>找到一位大佬的解决方案，具体见大佬的这篇文章：<a href="https://blog.wangriyu.wang/2018/06-Aplayer.html" target="_blank" rel="noopener">使用 Aplayer 导致博客目录跳转失效</a> 。</p>
<p>我使用他提供的 <code>APlayer.min.js</code> 替换了我原来的 js 文件，目前中文目录点击无法跳转的 bug 已经修复解决。</p>
<blockquote>
<p>本文参考自：</p>
<p><a href="https://github.com/MoePlayer/hexo-tag-aplayer" target="_blank" rel="noopener">https://github.com/MoePlayer/hexo-tag-aplayer</a></p>
<p><a href="https://tianma.space/post/3998746934/index.html" target="_blank" rel="noopener">https://tianma.space/post/3998746934/index.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>建站笔记</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>【动态规划-递推】POJ 1664 放苹果</title>
    <url>/posts/d0e7bee4.html</url>
    <content><![CDATA[<blockquote>
<p>把M个同样的苹果放在N个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？（用K表示）5，1，1和1，5，1 是同一种分法。</p>
<p>第一行是测试数据的数目t（0 &lt;= t &lt;= 20）。以下每行均包含二个整数M和N，以空格分开。1&lt;=M，N&lt;=10。</p>
<p>对输入的每组数据M和N，用一行输出相应的K。</p>
</blockquote>
<a id="more"></a>
<ul>
<li>题目地址：<a href="http://poj.org/problem?id=1664" target="_blank" rel="noopener">http://poj.org/problem?id=1664</a></li>
</ul>
<p>​          </p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>又是一题思路超级重要的题。</p>
<p>M个相同的苹果放在N个同样的盘子里，允许有的盘子空着不放。</p>
<p>设f(m,n)为m个苹果，n个盘子的放法数目，先对n作讨论，</p>
<p>当n&gt;m：则必定有n-m个盘子永远空着，去掉它们对摆放苹果方法数目不产生影响。即 if(n&gt;m) f(m,n) = f(m,m)</p>
<p>当n &lt;= m:不同的放法可以分成两类：含有0的方案数，不含有0的方案数</p>
<p>含有0的方案数，即有至少一个盘子空着，即相当于 f(m,n)=f(m,n-1);</p>
<p>不含有0的方案数，即所有的盘子都有苹果，相当于可以从每个盘子中拿掉一个苹果，不影响不同放法的数目，即 f(m,n)=f(m-n,n).</p>
<p>而总的放苹果的放法数目等于两者的和，即 f(m,n)=f(m,n-1)+f(m-n,n)</p>
<p>递归出口条件说明：</p>
<p>当n==1时，所有苹果都必须放在一个盘子里，所以返回1；</p>
<p>当m==0(没有苹果可放)时，定义为1种放法；</p>
<p>​        </p>
<h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1001</span>][<span class="number">1001</span>];  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> n;  </span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;  </span><br><span class="line">    <span class="keyword">while</span>(n--)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">int</span> M,N;  </span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;M&gt;&gt;N;  </span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=M;i++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="number">0</span>;  </span><br><span class="line">            dp[i][<span class="number">1</span>]=<span class="number">1</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=N;i++)  </span><br><span class="line">            dp[<span class="number">0</span>][i]=<span class="number">1</span>;  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;i++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=N;j++)  </span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="keyword">if</span>(i&lt;j)  </span><br><span class="line">                    dp[i][j]=dp[i][i];  </span><br><span class="line">                <span class="keyword">else</span>  </span><br><span class="line">                    dp[i][j]=dp[i][j<span class="number">-1</span>]+dp[i-j][j];  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;dp[M][N]&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>OJ刷题</category>
      </categories>
      <tags>
        <tag>OJ</tag>
        <tag>动态规划</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title>【动态规划-递推】HDU 2046 骨牌铺方格</title>
    <url>/posts/482e4bcc.html</url>
    <content><![CDATA[<blockquote>
<p>在2×n的一个长方形方格中,用一个1× 2的骨牌铺满方格,输入n ,输出铺放方案的总数.</p>
<p>例如n=3时,为2× 3方格，骨牌的铺放方案有三种,如下图：</p>
<p><img src="https://photo.hushhw.cn/images/C40-1003-1.jpg" alt></p>
<p>输入数据由多行组成，每行包含一个整数n,表示该测试实例的长方形方格的规格是2×n (0&lt;n&lt;=50)。</p>
<p>对于每个测试实例，请输出铺放方案的总数，每个实例的输出占一行。</p>
</blockquote>
<a id="more"></a>
<p>​         </p>
<ul>
<li>题目地址：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2046" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=2046</a></li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>假设用<code>a[i]</code>表示2*i的方格一共有组成的方法数，我们知道<code>a[1]=1</code> ， <code>a[2]=2</code>;</p>
<p>放第n的时候,可在n-2的情况下在最右边横着放两块,有<code>a[n-2]</code>种情况,</p>
<p>也可在n-1的情况下在最右边竖着放一块,有<code>a[n-1]</code>种情况.</p>
<p>故:<code>a[n]=a[n-2]+a[n-1]</code></p>
<h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">51</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    a[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            a[i] = a[i - <span class="number">2</span>] + a[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, a[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>OJ刷题</category>
      </categories>
      <tags>
        <tag>OJ</tag>
        <tag>动态规划</tag>
        <tag>hdu</tag>
      </tags>
  </entry>
  <entry>
    <title>【动态规划-递推】HDU 2045 LELE的RPG难题</title>
    <url>/posts/1d8d1ae8.html</url>
    <content><![CDATA[<blockquote>
<p>有排成一行的ｎ个方格，用红(Red)、粉(Pink)、绿(Green)三色涂每个格子，每格涂一色，要求任何相邻的方格不能同色，且首尾两格也不同色．求全部的满足要求的涂法.</p>
<p>输入数据包含多个测试实例,每个测试实例占一行,由一个整数N组成，(0&lt;n&lt;=50)。</p>
<p>对于每个测试实例，请输出全部的满足要求的涂法，每个实例的输出占一行。</p>
</blockquote>
<a id="more"></a>
<p>​         </p>
<ul>
<li>题目地址：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2045" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=2045</a></li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>f(n) = 1, … , n-2 , n-1, n<br>前n-2个已涂好后，涂第n-1个即有2种情况： </p>
<ol>
<li>n-1的色与1的色不相同，那么n就是剩下的那个色，即<code>f(n-1)</code></li>
<li>n-1的色与1的色一样，那么n的色就有2个色选择.即<code>f(n-2)*2</code></li>
</ol>
<p>综上得：</p>
<p><code>f[n]=f[n-1]+f[n-2]*2 (n&gt;3);</code></p>
<p><code>f[1]=3;  f[2]=6;  f[3]=6;  f[4]=18</code></p>
<h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">10005</span>];  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">	<span class="keyword">int</span> n;  </span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)  </span><br><span class="line">	&#123;  </span><br><span class="line">		a[<span class="number">0</span>]=<span class="number">0</span>;  </span><br><span class="line">		a[<span class="number">1</span>]=<span class="number">3</span>;  </span><br><span class="line">		a[<span class="number">2</span>]=<span class="number">6</span>;  </span><br><span class="line">		a[<span class="number">3</span>]=<span class="number">6</span>;  </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">4</span>;i&lt;=n;i++)  </span><br><span class="line">		&#123;  </span><br><span class="line">			a[i]=a[i<span class="number">-1</span>]+<span class="number">2</span>*a[i<span class="number">-2</span>];  </span><br><span class="line">		&#125;  </span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;a[n]&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>OJ刷题</category>
      </categories>
      <tags>
        <tag>OJ</tag>
        <tag>动态规划</tag>
        <tag>hdu</tag>
      </tags>
  </entry>
  <entry>
    <title>【动态规划-递推】HDU 2047 阿牛的EOF牛肉串</title>
    <url>/posts/f94672dd.html</url>
    <content><![CDATA[<blockquote>
<p>阿牛从家里拿来了一块上等的牛肉干，准备在上面刻下一个长度为n的只由”E” “O” “F”三种字符组成的字符串（可以只有其中一种或两种字符，但绝对不能有其他字符）,</p>
<p>阿牛同时禁止在串中出现O相邻的情况，他认为，”OO”看起来就像发怒的眼睛，效果不好。你，NEW ACMer,EOF的崇拜者，能帮阿牛算一下一共有多少种满足要求的不同的字符串吗？</p>
<p>输入数据包含多个测试实例,每个测试实例占一行,由一个整数n组成，(0&lt;n&lt;40)。</p>
<p>对于每个测试实例，请输出全部的满足要求的涂法，每个实例的输出占一行。</p>
</blockquote>
 <a id="more"></a>
<ul>
<li>题目地址：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2047" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=2047</a></li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>当最后一个为E时，则倒数第二位可以随意，即<code>a[i-1]</code>;</p>
<p>同理，当最有一个为F时，倒数第二位也可以随意填，即<code>a[i-1]</code>;</p>
<p>当最后一个为O时，就不能随意了，因为倒数第二位不能为O,所以再细分下面两种情况：</p>
<p>第一，当倒数两位为EO时，倒数第三位可以随意填，即<code>a[i-2]</code>;</p>
<p>第二，当倒数两位为FO时，倒数第三位也可以随意填，即<code>a[i-2]</code>;</p>
<p>此时，已经考虑完所有情况了，所以<code>a[i] = 2*a[i-1] + 2*a[i-2]</code>.</p>
<h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">41</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">    a[<span class="number">2</span>] = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            a[i] = <span class="number">2</span> * (a[i - <span class="number">1</span>] + a[i - <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, a[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>OJ刷题</category>
      </categories>
      <tags>
        <tag>OJ</tag>
        <tag>动态规划</tag>
        <tag>hdu</tag>
      </tags>
  </entry>
  <entry>
    <title>【动态规划-递推】HDU 2044 一只小蜜蜂...</title>
    <url>/posts/ace523f9.html</url>
    <content><![CDATA[<blockquote>
<p>有一只经过训练的蜜蜂只能爬向右侧相邻的蜂房，不能反向爬行。请编程计算蜜蜂从蜂房a爬到蜂房b的可能路线数。</p>
<p>其中，蜂房的结构如下所示。</p>
<p><img src="https://photo.hushhw.cn/images/C40-1001-1.jpg" alt></p>
<p>输入数据的第一行是一个整数N,表示测试实例的个数，然后是N 行数据，每行包含两个整数a和b(0&lt;a&lt;b&lt;50)。</p>
<p>对于每个测试实例输出蜜蜂从蜂房a爬到蜂房b的可能路线数，每个实例的输出占一行。</p>
</blockquote>
<a id="more"></a>
<p>​         </p>
<ul>
<li>题目地址：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2044" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=2044</a></li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>很简单的斐波那契额数列的变形，用<code>f</code>数组来记录从开始到当前位置的可能路线数，求a到b的路线数就可以转化为求<code>f[b-a]</code>，    ，数据量为0到50,所以先打表存进f数组，因此从头至尾只打表进行计算，以后需要直接调用即可。</p>
<h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="keyword">int</span> a,b,num=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">		num = b-a;</span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> f[<span class="number">100</span>];</span><br><span class="line">		f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">		f[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;=num; i++)</span><br><span class="line">			f[i]=f[i<span class="number">-1</span>]+f[i<span class="number">-2</span>];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,f[num]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>OJ刷题</category>
      </categories>
      <tags>
        <tag>OJ</tag>
        <tag>动态规划</tag>
        <tag>hdu</tag>
      </tags>
  </entry>
  <entry>
    <title>从头开始学算法——动态规划</title>
    <url>/posts/61022a09.html</url>
    <content><![CDATA[<h2 id="什么是动态规划"><a href="#什么是动态规划" class="headerlink" title="什么是动态规划"></a>什么是动态规划</h2><blockquote>
<p><strong>dynamic programming </strong>is a method for solving a complex problem by breaking it down into a collection of simpler subproblems, solving each of those subproblems just once, and storing their solutions.</p>
</blockquote>
<p>动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量： 一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。 这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。</p>
<p><strong>动态规划问题满足三大重要性质：</strong></p>
<ol>
<li><strong>最优子结构性质：</strong>如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。</li>
<li><strong>无后效性：</strong>即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。</li>
<li><strong>子问题重叠性质：</strong>子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。</li>
</ol>
<p>对于动态规划的概念其实不好把握，最好的方式是在做题中去体会动态规划的思想。</p>
<h2 id="简单基础DP"><a href="#简单基础DP" class="headerlink" title="简单基础DP"></a>简单基础DP</h2><p>这类<code>dp</code>主要是问题比较常见，遇到这类题目可以直接在基础模板上变化即可，包括<strong>递推、背包、LIS（最长递增序列），LCS（最长公共子序列）</strong></p>
<h3 id="递推"><a href="#递推" class="headerlink" title="递推"></a>递推</h3><p>经典的递推dp是<code>斐波那契数列</code>(Fibonacci sequence)，在求F(n)F(n)时，总会先求F(n−1)F(n−1)和F(n−2)F(n−2)，然后根据公式F(n)=F(n−1)+F(n−2)F(n)=F(n−1)+F(n−2)求出，例如我们在求出F(3)F(3)后，再求F(5)F(5)时就不必从头再推一遍而是直接调用。</p>
<ul>
<li><a href="https://wiki.hushhw.cn/posts/ace523f9.html">【动态规划-递推】HDU 2044 一只小蜜蜂…</a></li>
<li><a href="https://wiki.hushhw.cn/posts/f94672dd.html">【动态规划-递推】HDU 2047 阿牛的EOF牛肉串</a></li>
<li><a href="https://wiki.hushhw.cn/posts/1d8d1ae8.html">【动态规划-递推】HDU 2045 RPG难题</a></li>
<li><a href="https://wiki.hushhw.cn/posts/482e4bcc.html">【动态规划-递推】HDU 2046 骨牌铺方格</a></li>
<li><a href="https://wiki.hushhw.cn/posts/d0e7bee4.html">【动态规划-递推】POJ 1664 放苹果</a></li>
</ul>
<p>​       </p>
<h3 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h3><h4 id="0-1背包-每个物品最多只能放一次"><a href="#0-1背包-每个物品最多只能放一次" class="headerlink" title="0-1背包(每个物品最多只能放一次)"></a>0-1背包(每个物品最多只能放一次)</h4><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><p>有N件物品和一个容量为V的背包。第i件物品的费用是c[i],价值是w[i]。求解将哪些物品装入背包可使价值总和最大</p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>这是最基础的背包问题，特点是：每种物品只有一件，可以选择放或者不放</p>
<p>用子问题定义状态：即<code>dp[i][j]</code>表示前i件物品放入一个容量为j的背包可以获得的最大价值。则其状态转移方程为：</p>
<p><code>dp[i][j] = max{dp[i - 1][j], dp[i - 1][j - c[i]] + w[i]}</code></p>
<p>这个方程非常重要，基本上所有跟背包相关的问题的方程都是由它衍生出来。这里详细解释一下：</p>
<p><strong>将前i件物品放入容量为j的背包中</strong>这个子问题，若只考虑第i件物品的策略（放或者不放），那么就可以转换为一个只牵扯前i-1件物品的问题。</p>
<ul>
<li>如果不放第i件物品，那么问题就转换为前i-1件物品放入容量为j的背包中的最大价值，价值为<code>dp[i - 1][j]</code></li>
<li>如果放入第i件物品，那么问题就转换为前i-1件物品放入容量为j-c[i]的背包中，此时能获得的最大价值是<code>dp[i-1][j-c[i]]</code>,再加上放入第i件物品获得的价值w[i]</li>
</ul>
<h5 id="优化空间复杂度"><a href="#优化空间复杂度" class="headerlink" title="优化空间复杂度"></a>优化空间复杂度</h5><p>先考虑一下上面的状态转移方程如何实现，肯定有一个主循环i = 1…N,每次算出来二维数组dp[i][0..V]的所有值。那么如果只用一个数组<code>f[0...V]</code>,能不能保证第i次循环结束后<code>f[v]</code>就是我们定义的状态<code>f[i][v]</code>呢？<code>f[i][v]</code>是由<code>f[i-1][v]</code>和<code>f[i-1][v-c[i]]</code>两个子问题递推而来，能否保证在推<code>f[i][v]</code>时（也即在第i次主循环中推f[v]时）能够得到<code>f[i-1][v]</code>和<code>f[i-1][v-c[i]]</code>的值呢？事实上，这要求在每次主循环中我们以v=V…0的顺序推f[v]，这样才能保证推f[v]时f[v-c[i]]保存的是状态<code>f[i-1][v-c[i]]</code>的值。伪代码如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i  in 0 ... N</span><br><span class="line">    for  v = V ... 0</span><br><span class="line">        f[v] = max&#123;f[v], f[v-c[i]] + w[i]&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="练习题目"><a href="#练习题目" class="headerlink" title="练习题目"></a>练习题目</h5><ul>
<li><a href="https://wiki.hushhw.cn/posts/b883e502.html">【动态规划-0-1背包】HDU 2955 Robberies</a> </li>
<li><p><a href="https://wiki.hushhw.cn/posts/44777a5c.html">【动态规划-0-1背包】HDU 1864 最大报销额</a></p>
</li>
<li><p><a href="https://wiki.hushhw.cn/posts/b0fea3aa.html">【动态规划-0-1背包】HDU 2602 Bone Collector</a></p>
</li>
<li><a href="https://wiki.hushhw.cn/posts/e729ac5b.html">【动态规划-0-1背包】HDU 2639 Bone Collector II</a></li>
</ul>
<p>​           </p>
<h4 id="完全背包-每种物品可以放无限多次"><a href="#完全背包-每种物品可以放无限多次" class="headerlink" title="完全背包(每种物品可以放无限多次)"></a>完全背包(每种物品可以放无限多次)</h4><h5 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h5><p>有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是c[i]，价值是w[i].</p>
<p>求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大</p>
<h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>这个问题类似于0-1背包问题，所不同的是每种物品有无限件。也就是从每种物品的角度考虑，与它相关的策略已非取或不取两种，而且有取0件、取1件、取2件…等很多种。如果仍然按照0-1背包的思路，令<code>dp[i][v]</code>表示前i种物品恰好放入一个容量为v的背包的最大权值。仍然可以按照每种物品不同的策略写出状态转移方程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i][v] = max&#123;dp[i-1][v - k * c[i]] + k * w[i] | 0 &lt;= k * c[i]&lt;= v&#125;</span><br></pre></td></tr></table></figure>
<p>转化为01背包求解<br>最简单的想法是：考虑到第i种物品最多选V/c[i]件，于是可以把第i种物品转换为V/c[i]件费用及价值均不变的物品，然后求解这个01背包问题。但是这样完全没有改进时间复杂度，但这毕竟给了我们将完全背包转换为01背包问题的思路：将一种物品拆成多件物品</p>
<h5 id="O-VN-的算法"><a href="#O-VN-的算法" class="headerlink" title="O(VN)的算法"></a>O(VN)的算法</h5><p>这个算法使用一维数组，先看伪代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i = 1 ... N</span><br><span class="line">    for v = 0 ... V</span><br><span class="line">        f[v] = max&#123;f[v], f[v-cost] + weight&#125;</span><br></pre></td></tr></table></figure></p>
<p>你会发现，这个伪代码与01背包的伪代码只有v的循环次序不同而已。为什么这样一改就行呢？首先，想想为什么01背包问题中要按照v=V…0的逆序来循环。这是因为要保证第i次循环中的状态f[i][v]是由状态<code>f[i-1][v-c[i]]</code>递推而来。换句话说，这正是为了保证每件物品只选一次，保证在考虑“选入第i件物品”这件策略时，依据的是一个绝无已经选入第i件物品的子结果<code>f[i-1][v-c[i]]</code>。而现在完全背包的特点恰好是每种物品可选无限件，所以在考虑“加选一件dii种物品”这种策略时，却正需要一个可能已选入第i种物品的子结果<code>f[i][c-v[i]]</code>,所以就可以并且必须采用v=0…V的顺序循环。这就是这个简单的程序为何成立的道理。</p>
<p>值得一提的是，上面的伪代码中两层for循环的次序可以颠倒。这个结论有可能会带来算法时间常数上的优化。</p>
<p>这个算法也可以以另外的思路得出。例如，将基本思路中求解f[i][v-c[i]]的状态转移方程显式地写出来，代入原方程中，会发现该方程可以等价地变形成这种形式：</p>
<p><code>f[i][v]=max{f[i-1][v],f[i][v-c[i]]+w[i]}</code></p>
<p>将这个方程用一维数组实现，便得到了上面的伪代码。</p>
<h5 id="练习题目-1"><a href="#练习题目-1" class="headerlink" title="练习题目"></a>练习题目</h5><ul>
<li><a href="https://wiki.hushhw.cn/posts/2e53604.html">【动态规划-完全背包】HDU 2159 FATE</a></li>
</ul>
<p>​         </p>
<h4 id="多重背包-每种物品有一个固定的次数上限"><a href="#多重背包-每种物品有一个固定的次数上限" class="headerlink" title="多重背包(每种物品有一个固定的次数上限)"></a>多重背包(每种物品有一个固定的次数上限)</h4><h5 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h5><p>有N种物品和一个容量为V的背包。第i种物品最多有n[i]件，每件费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大</p>
<h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>多重背包问题的思路跟完全背包的思路非常类似，只是k的取值是有限制的，因为每件物品的数量是有限制的，状态转移方程为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i][v] = max&#123;dp[i - 1][v - k * c[i]] + w[i] | 0 &lt;=k &lt;= n[i]&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度是<code>O(V*Σn[i])</code>。</p>
<h5 id="练习题目-2"><a href="#练习题目-2" class="headerlink" title="练习题目"></a>练习题目</h5><ul>
<li><a href="https://wiki.hushhw.cn/posts/dab6998b.html">【动态规划-多重背包】HDU 2844 Coins</a></li>
</ul>
<p>​        </p>
<h3 id="LIS-最长递增子序列"><a href="#LIS-最长递增子序列" class="headerlink" title="LIS(最长递增子序列)"></a>LIS(最长递增子序列)</h3><p><strong>最长递增子序列，朴素的是o(n^2)算法，二分下可以写成o(nlgn)：维护一个当前最优的递增序列——找到恰好大于它更新</strong></p>
<ul>
<li><a href="https://wiki.hushhw.cn/posts/a996c21e.html">【动态规划-最大连续子序列】HDU 1003 Max Sum</a></li>
</ul>
<p>​         </p>
<h3 id="LCS-最长公共子序列"><a href="#LCS-最长公共子序列" class="headerlink" title="LCS(最长公共子序列)"></a>LCS(最长公共子序列)</h3><p>​          </p>
<p>​           </p>
<h2 id="区间dp"><a href="#区间dp" class="headerlink" title="区间dp"></a>区间dp</h2><p> 区间DP是一类在区间上进行动态规划的最优问题，一般是根据问题设出一个表示状态的dp，可以是二维的也可以是三维的，一般情况下为二维。然后将问题划分成两个子问题，也就是一段区间分成左右两个区间，然后将左右两个区间合并到整个区间，或者说局部最优解合并为全局最优解，然后得解。</p>
<blockquote>
<p>本文参考自：</p>
<p><a href="https://en.wikipedia.org/wiki/Dynamic_programming" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Dynamic_programming</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92</a></p>
<p><a href="https://blog.csdn.net/cc_again/article/details/25866971" target="_blank" rel="noopener">https://blog.csdn.net/cc_again/article/details/25866971</a></p>
<p><a href="https://blog.csdn.net/woshi250hua/article/details/7969225" target="_blank" rel="noopener">https://blog.csdn.net/woshi250hua/article/details/7969225</a></p>
</blockquote>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>算法笔记</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo主题maupassant添加推荐阅读功能</title>
    <url>/posts/f2c9bfb4.html</url>
    <content><![CDATA[<p>推荐阅读是通过插件 <a href="https://github.com/huiwang/hexo-recommended-posts" target="_blank" rel="noopener">hexo-recommended-posts</a> 来实现的, 它不仅可以推荐你自己的博客, 还可以推荐别人的相关博客. 如果有比较多人使用这个插件的话, 不仅能帮读者快速找到感兴趣的内容, 同时也能增加自己博客的流量。</p>
<p>先安装 hexo-recommended-posts :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-recommended-posts --save</span><br></pre></td></tr></table></figure>
<p>首先我们还是需要在主题的 <code>_config.yml</code> 文件中添加一些配置信息:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">recommended_posts:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure>
<p>然后同样也是在 <code>layout/post.pug</code> 文件中添加相关的代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if theme.recommended_posts.enable == true</span><br><span class="line">  div.recommended_posts</span><br><span class="line">    h3() 推荐阅读</span><br><span class="line">    - var post_list = recommended_posts(page, site)</span><br><span class="line">    - for (var i in post_list)</span><br><span class="line">        li</span><br><span class="line">          a(href=post_list[i].permalink, target=&apos;_blank&apos;)= post_list[i].title</span><br></pre></td></tr></table></figure>
<p>再在 <code>source/css/style.scss</code> 中添加样式配置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.recommended_posts &#123;</span><br><span class="line">    padding: 0.5em 1em;</span><br><span class="line">    border-left: 3px solid #6f42c1;</span><br><span class="line">    background-color: #f5f0fa;</span><br><span class="line">    li &#123; margin: 5px 0; &#125;</span><br><span class="line">    a:link &#123; color: blue; &#125;</span><br><span class="line">    a:hover &#123; text-decoration:underline;color: red&#125;</span><br><span class="line">    a:visited &#123; color: green; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后我们还需要在博客的 <code>_config.yml</code> 文件中添加插件相关的配置信息:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">recommended_posts:</span><br><span class="line">  autoDisplay: false</span><br></pre></td></tr></table></figure>
<p>现在当我们执行下列命令后便可以在博客中看到推荐文章相关的信息:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo recommend</span><br><span class="line">hexo generate</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p>具体配置过程也可以参见：<a href="https://github.com/hiberabyss/maupassant-hexo/commit/499d5ef3f73b6735cd5cf848438055501208a59b" target="_blank" rel="noopener">https://github.com/hiberabyss/maupassant-hexo/commit/499d5ef3f73b6735cd5cf848438055501208a59b</a></p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a href="https://github.com/huiwang/hexo-recommended-posts" target="_blank" rel="noopener">hexo-recommended-posts</a></li>
</ul>
]]></content>
      <categories>
        <category>建站笔记</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo主题maupassant博客搭建相册</title>
    <url>/posts/6ff333ed.html</url>
    <content><![CDATA[<p>之前一直想要在博客里加一个相册的功能，自己折腾无果后，转入使用主题 <code>yilia</code> ，该主题是将其在ins上的相册转过来，我也刚好也是想把ins上的照片转过来，太喜欢这个app了，所以这个主题真的是深得我心。可是，男人都是善变的，我现在又转入了新主题 <code>Manpassant</code> ，于是开始了我的漫漫迁移路。</p>
<p>本篇文章仅介绍如何在Manpassant主题上迁移yilia上的相册功能，如何获取ins上的照片，以后有时间再补充介绍。</p>
<a id="more"></a>
<p>​        </p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>首先你得搭建好你的相册库，无论是本地存储还是用github、七牛云都可以。</p>
<p>​          </p>
<h3 id="生成相册页面"><a href="#生成相册页面" class="headerlink" title="生成相册页面"></a>生成相册页面</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new page &quot;photos&quot;</span><br></pre></td></tr></table></figure>
<p>执行完毕后找到 <code>source/photos</code> 文件夹下 <code>index.md</code> 进行修改，<code>Manpassant</code> 支持是否显示侧栏两种 <code>page</code> 模式，设置layout为<code>layout: page</code>则显示双栏，若需要单栏页面，就将layout设置为 <code>layout: single-column</code>。</p>
<p>我的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">layout: single-column</span><br><span class="line">type: &quot;photos&quot;</span><br><span class="line">title: 相册</span><br><span class="line">noDate: &apos;true&apos;</span><br><span class="line">comments: &apos;true&apos;</span><br><span class="line">copyright: false</span><br></pre></td></tr></table></figure>
<p>正文代码部分如下：</p>
<ul>
<li>前面三个<code>link</code>的文件都要一起放在<code>photos</code>文件夹中，点击之后可以下载<ul>
<li><a href="https://github.com/hushhw/nodejs-ins/blob/master/backup/ins.css" target="_blank" rel="noopener">ins.css</a></li>
<li><a href="https://github.com/dimsemenov/PhotoSwipe/blob/master/dist/photoswipe.css" target="_blank" rel="noopener">photoswipe.css</a></li>
<li><a href="https://github.com/dimsemenov/PhotoSwipe/tree/master/dist/default-skin" target="_blank" rel="noopener">default-skin</a> </li>
</ul>
</li>
<li>第8行超链接可以替换成你自己的ins网页</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"./ins.css"</span>&gt;</span><br><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"./photoswipe.css"</span>&gt; </span><br><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"./default-skin/default-skin.css"</span>&gt; </span><br><span class="line"></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"instagram itemscope"</span>&gt;</span><br><span class="line">	&lt;section <span class="class"><span class="keyword">class</span></span>=<span class="string">"archives album"</span>&gt;</span><br><span class="line">		&lt;ul <span class="class"><span class="keyword">class</span></span>=<span class="string">"img-box-ul"</span>&gt;</span><br><span class="line">			&lt;a href=<span class="string">"https://www.instagram.com/hushhw/"</span> target=<span class="string">"_blank"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"open-ins"</span>&gt;图片来自instagram，正在加载中…&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">		&lt;/u</span>l&gt;</span><br><span class="line">	&lt;<span class="regexp">/section&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">add0</span>(<span class="params">m</span>)</span>&#123;<span class="keyword">return</span> m&lt;<span class="number">10</span>?<span class="string">'0'</span>+m:m &#125;;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">getDate</span>(<span class="params">timeString</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">parseInt</span>(timeString) * <span class="number">1000</span>);</span><br><span class="line">		<span class="keyword">var</span> y = time.getFullYear();</span><br><span class="line">		<span class="keyword">var</span> m = time.getMonth()+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">var</span> d = time.getDate();</span><br><span class="line">		<span class="keyword">return</span> y+<span class="string">'-'</span>+add0(m)+<span class="string">'-'</span>+add0(d);</span><br><span class="line">	&#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">	(function() &#123;</span></span><br><span class="line"><span class="regexp">		var loadScript = function(path) &#123;</span></span><br><span class="line"><span class="regexp">			var $script = document.createElement('script')</span></span><br><span class="line"><span class="regexp">			document.getElementsByTagName('body')[0].appendChild($script)</span></span><br><span class="line"><span class="regexp">			$script.setAttribute('src', path)</span></span><br><span class="line"><span class="regexp">		&#125;</span></span><br><span class="line"><span class="regexp">		setTimeout(function() &#123;</span></span><br><span class="line"><span class="regexp">			loadScript('./i</span>ns.js<span class="string">')</span></span><br><span class="line"><span class="string">		&#125;, 0)</span></span><br><span class="line"><span class="string">	&#125;)()</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>此时，页面的基本样式已经完成，完成图如下：</p>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-01-18_02-17-44.png" alt></p>
<p>此时若点击图片试图查看大图，浏览器将会报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Uncaught ReferenceError: PhotoSwipe is not defined</span><br></pre></td></tr></table></figure>
<p>​      </p>
<h3 id="引入JS文件"><a href="#引入JS文件" class="headerlink" title="引入JS文件"></a>引入JS文件</h3><p>前面添加的<code>photoswipe.css</code>和<code>default-skin.css</code>是使用photoswipe来查看相册图片，具体可以参考网址 <a href="http://photoswipe.com/" target="_blank" rel="noopener">photoswipe</a>。其实Manpassant主题已经内置了<code>fancybox</code>来查看图片，那为什么还要使用<code>OpenSwipe</code>呢？因为我们想要实现显示在网页上的图片是压缩版本，点击之后图片显示未压缩版本<del>（其实主要是因为yilia主题用的就是这个，我只会魔改。。。）</del>。</p>
<p>现在继续添加js文件到主题文件夹中，找到<code>themes/maupassant/source/js</code>文件夹下面两个文件放入其中（可以从PhotoSwipe项目中下载）：</p>
<ul>
<li><a href="https://github.com/dimsemenov/PhotoSwipe/blob/master/dist/photoswipe.min.js" target="_blank" rel="noopener">photoswipe.min.js</a></li>
<li><a href="https://github.com/dimsemenov/PhotoSwipe/blob/master/dist/photoswipe-ui-default.min.js" target="_blank" rel="noopener">photoswipe-ui-default.min.js</a></li>
</ul>
<p>在主题目录<code>layout/_partial</code>下新建文件<code>openswipe.pug</code>写入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">script(type=<span class="string">'text/javascript'</span>, src=url_for(theme.js) + <span class="string">'/photoswipe.min.js'</span> + <span class="string">'?v='</span> + theme.version)</span><br><span class="line">script(type=<span class="string">'text/javascript'</span>, src=url_for(theme.js) + <span class="string">'/photoswipe-ui-default.min.js'</span> + <span class="string">'?v='</span> + theme.version)</span><br></pre></td></tr></table></figure>
<p>之后，在<code>base-without-sidebar.pug</code>文件最后加上一句<code>include _partial/openswipe.pug</code>，如果你前面选的是双栏页面使用的是<code>layout: page</code>，那么你应该在<code>base.pug</code>文件中添加。</p>
<p>完成到这里，<code>OpenSwipe</code>的配置基本完成，当你点击图片时浏览器报错将是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Uncaught TypeError: Cannot read property &apos;firstChild&apos; of undefined</span><br></pre></td></tr></table></figure>
<p>​          </p>
<h3 id="点击图片判断"><a href="#点击图片判断" class="headerlink" title="点击图片判断"></a>点击图片判断</h3><p>找到文件<code>single-column.pug</code>，加入判断语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if page.type == &quot;photos&quot;</span><br><span class="line">    div(class=&quot;pswp&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; aria-hidden=&quot;true&quot;)</span><br><span class="line">     div(class=&quot;pswp__bg&quot;)</span><br><span class="line">     div(class=&quot;pswp__scroll-wrap&quot;)</span><br><span class="line">      div(class=&quot;pswp__container&quot;)</span><br><span class="line">       div(class=&quot;pswp__item&quot;)</span><br><span class="line">       div(class=&quot;pswp__item&quot;)</span><br><span class="line">       div(class=&quot;pswp__item&quot;)</span><br><span class="line">      div(class=&quot;pswp__ui pswp__ui--hidden&quot;)</span><br><span class="line">       div(class=&quot;pswp__top-bar&quot;)</span><br><span class="line">        div(class=&quot;pswp__counter&quot;)</span><br><span class="line">        button(class=&quot;pswp__button pswp__button--close&quot; title=&quot;Close (Esc)&quot;)</span><br><span class="line">        button(class=&quot;pswp__button pswp__button--share&quot; title=&quot;Share&quot;)</span><br><span class="line">        button(class=&quot;pswp__button pswp__button--fs&quot; title=&quot;Toggle fullscreen&quot;)</span><br><span class="line">        button(class=&quot;pswp__button pswp__button--zoom&quot; title=&quot;Zoom in/out&quot;)</span><br><span class="line">        div(class=&quot;pswp__preloader&quot;)</span><br><span class="line">         div(class=&quot;pswp__preloader__icn&quot;)</span><br><span class="line">          div(class=&quot;pswp__preloader__cut&quot;)</span><br><span class="line">           div(class=&quot;pswp__preloader__donut&quot;)</span><br><span class="line">       div(class=&quot;pswp__share-modal pswp__share-modal--hidden pswp__single-tap&quot;)</span><br><span class="line">        div(class=&quot;pswp__share-tooltip&quot;)</span><br><span class="line">       button(class=&quot;pswp__button pswp__button--arrow--left&quot; title=&quot;Previous (arrow left)&quot;)</span><br><span class="line">       button(class=&quot;pswp__button pswp__button--arrow--right&quot; title=&quot;Next (arrow right)&quot;)</span><br><span class="line">       div(class=&quot;pswp__caption&quot;)</span><br><span class="line">        div(class=&quot;pswp__caption__center&quot;)</span><br></pre></td></tr></table></figure>
<p>由于该主题文件都是<code>.pug</code>，而本人对jade并不熟悉，所以查了一下基本语法魔改了一下javascript代码。</p>
<p>添加完成之后，相册页面也就完结撒花啦！</p>
<p>​         </p>
<h3 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h3><ul>
<li>使用<a href="https://github.com/hushhw/nodejs-ins" target="_blank" rel="noopener">nodejs-ins</a>工具生成图片及ins.json文件</li>
<li>正常使用<code>hexo g -d</code>更新博客</li>
</ul>
]]></content>
      <categories>
        <category>建站笔记</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo折腾笔记</title>
    <url>/posts/28187ef7.html</url>
    <content><![CDATA[<blockquote>
<p>当我开始打算搭建一个博客写总结时，就注定有一天我会入一个万劫不复的坑。</p>
<p>腾讯的学生服务器每个月都要续，而且Wordpress使用起来并不对我的胃口，于是转用Hexo和github pages 服务搭建个人博客。</p>
<p>对于门面功夫上的折腾，我从来都没有让自己失望过，根本停不下来，总是感觉不够完美。</p>
<p>时间跨度有点长，之前配置的一些东西又忘记了，所以这篇笔记很有必要写。</p>
</blockquote>
<a id="more"></a>
<p>​            </p>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-01-14_13-08-00.png" alt></p>
<ul>
<li>本文介绍的所有设置均在windows环境下进行</li>
<li>因为网上有很多教程，本篇是基于汇总的基础上进行补充</li>
</ul>
<h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><ol>
<li><a href="https://segmentfault.com/a/1190000015756932" target="_blank" rel="noopener">Hexo+Netlify快速搭建个人博客</a></li>
<li><a href="https://segmentfault.com/a/1190000002632530" target="_blank" rel="noopener">hexo常用命令笔记</a></li>
<li><a href="https://www.zhihu.com/question/24422335" target="_blank" rel="noopener">有哪些好看的Hexo主题</a></li>
</ol>
<h2 id="提高篇"><a href="#提高篇" class="headerlink" title="提高篇"></a>提高篇</h2><p>因为很多配置很早以前就做过了，所以只能再遇到坑的时候再补充。。。</p>
<p>​        </p>
<h3 id="打造个性超赞博客超深度优化"><a href="#打造个性超赞博客超深度优化" class="headerlink" title="打造个性超赞博客超深度优化"></a>打造个性超赞博客超深度优化</h3><p>大佬这篇超深度的优化必看！！</p>
<p><a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html" target="_blank" rel="noopener">打造个性超赞博客Hexo+NexT+GitHubPages的超深度优化</a></p>
<p>​             </p>
<h3 id="博客文章链接优化"><a href="#博客文章链接优化" class="headerlink" title="博客文章链接优化"></a>博客文章链接优化</h3><p>Hexo的永久链接的默认格式是 <code>:year/:month/:day/:title/</code> ，比如访问站点下某一篇文章时，其路径是 <code>2018/04/12/xxxx/</code> ，如果我们的文章标题是中文的，那么该路径就会出现中文字符，之前使用 <code>gitment</code> 的同胞应该深受其害，在路径中出现了中文字符很容易引发各种问题，而且也不利于seo，因为路径包含了年月日三个层级，层级太深不利于搜索抓取。</p>
<p>网上的解决方案大致有两种，其一见 <a href="https://clearsky.me/hexo-permalinks.html" target="_blank" rel="noopener">Hexo 永久链接管理</a> 一文，通过在 <code>Front-matter</code> 自己添加变量 <code>urlname</code> 来做到，另一种方案则是安装使用插件 <a href="https://link.jianshu.com/?t=https://github.com/rozbo/hexo-abbrlink" target="_blank" rel="noopener">hexo-abbrlink</a> 可以做到自定义文章链接，安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure>
<p>然后在Hexo的<strong>根目录</strong>的配置文件<code>_config.yml</code>中修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">permalink: :abbrlink/</span><br><span class="line">#abbrlink配置</span><br><span class="line">abbrlink:</span><br><span class="line">  alg: crc32  # 算法：crc16(default) and crc32</span><br><span class="line">  rep: dec    # 进制：dec(default) and hex</span><br></pre></td></tr></table></figure>
<p>之后再md文件的<code>Front-matter</code>就会加上<code>abbrlink：xxxxx</code></p>
<p>这样就确保了博文链接的唯一化，只要不修改md文件的<code>abbrlink</code>的值，url就永久不会改变。如此md文件名和文件内容也可以随便改了。这样也有利于SEO优化。</p>
<p>最后附上我的配置，以及相关可以设定的参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#我的配置，post为固定链接后面带&quot;:&quot;的为变量</span><br><span class="line">permalink: posts/:category/:abbrlink.html</span><br><span class="line"></span><br><span class="line">#abbrlink</span><br><span class="line">abbrink:</span><br><span class="line">  alg: crc32</span><br><span class="line">  rep: dec</span><br></pre></td></tr></table></figure>
<p>​             </p>
<h3 id="文章置顶及置顶标签"><a href="#文章置顶及置顶标签" class="headerlink" title="文章置顶及置顶标签"></a>文章置顶及置顶标签</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm uninstall hexo-generator-index --save</span><br><span class="line">$ npm install hexo-generator-index-pin-top --save</span><br></pre></td></tr></table></figure>
<p>然后在需要置顶的文章的<code>Front-matter</code>中加上<code>top: true</code>即可。</p>
<p>搜索定位到<code>post-meta</code>类位置添加置顶标签，例如我使用的主题配置：</p>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-01-14_21-11-50.png" alt></p>
<p>最终效果</p>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-01-14_21-12-58.png" alt></p>
<p>​         </p>
<h3 id="Hexo主题maupassant博客搭建相册"><a href="#Hexo主题maupassant博客搭建相册" class="headerlink" title="Hexo主题maupassant博客搭建相册"></a>Hexo主题maupassant博客搭建相册</h3><p><a href="https://wiki.hushhw.cn/posts/6ff333ed.html">Hexo主题maupassant博客搭建相册</a></p>
<p>​        </p>
<h3 id="archive页面数量设置"><a href="#archive页面数量设置" class="headerlink" title="archive页面数量设置"></a>archive页面数量设置</h3><p>当文章数量达到十几篇左右时，突然发觉archive归档页面仅显示10篇文章，并且出现了分页功能，对于我们这种个人博客，文章数量不会很多，所以更希望是在一页中完全展示出来，便于访问者查找感兴趣的文章。</p>
<p>在网上查找原因，发现此处的10条限制来自_config.yml文件中的配置，这个配置控制所有的分页配置，包括首页、归档页、tag分类页面。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">per_page: 10</span><br></pre></td></tr></table></figure>
<p>如果我们想对上面三个页面做独立的配置，需要安装插件进行功能支持。</p>
<ul>
<li><a href="https://github.com/hexojs/hexo-generator-index" target="_blank" rel="noopener">hexo-generator-index</a></li>
<li><a href="https://github.com/hexojs/hexo-generator-archive" target="_blank" rel="noopener">hexo-generator-archive</a></li>
<li><a href="https://github.com/hexojs/hexo-generator-tag" target="_blank" rel="noopener">hexo-generator-tag</a></li>
</ul>
<p>使用如下命令进行安装需要的插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-archive --save</span><br></pre></td></tr></table></figure>
<p>对应的<code>_config.yml</code>文件中添加如下配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">index_generator:</span><br><span class="line">  per_page: 5</span><br><span class="line"></span><br><span class="line">archive_generator:</span><br><span class="line">  per_page: 20</span><br><span class="line"></span><br><span class="line">tag_generator:</span><br><span class="line">  per_page: 10</span><br></pre></td></tr></table></figure>
<p>​     </p>
<h3 id="maupassant主题添加推荐阅读功能"><a href="#maupassant主题添加推荐阅读功能" class="headerlink" title="maupassant主题添加推荐阅读功能"></a>maupassant主题添加推荐阅读功能</h3><p><a href="https://wiki.hushhw.cn/posts/f2c9bfb4.html">maupassant主题添加推荐阅读功能</a></p>
<p>​            </p>
<h3 id="maupassant主题目录优化解决方案"><a href="#maupassant主题目录优化解决方案" class="headerlink" title="maupassant主题目录优化解决方案"></a>maupassant主题目录优化解决方案</h3><p><a href="https://wiki.hushhw.cn/posts/5dd904ed.html">maupassant主题目录优化解决方案</a></p>
<p>​          </p>
]]></content>
      <categories>
        <category>建站笔记</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-OpenCV学习笔记——像素读取和写入</title>
    <url>/posts/d566ce3c.html</url>
    <content><![CDATA[<blockquote>
<p>获取三维矩阵[i, j]处的元素</p>
<p>获取三维矩阵的子矩阵</p>
</blockquote>
<a id="more"></a>
<p>​       </p>
<h3 id="获取三维矩阵-i-j-处的元素"><a href="#获取三维矩阵-i-j-处的元素" class="headerlink" title="获取三维矩阵[i, j]处的元素"></a>获取三维矩阵[i, j]处的元素</h3><p>读取某一点的像素值，image中是一个矩阵结构，所以使用img[100, 100]来读取（100，100）位置的像素，返回会以一个元组存在，使用一个三元组来存储，其顺序为BGR。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">'image0.jpg'</span>, <span class="number">1</span>)</span><br><span class="line">(b,g,r) = img[<span class="number">100</span>, <span class="number">100</span>]</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"位置(100,100)处的像素 - 红:%d,绿:%d,蓝:%d"</span> %(r,g,b)) <span class="comment">#显示像素值</span></span><br><span class="line"></span><br><span class="line">img[<span class="number">100</span>,<span class="number">100</span>] = (<span class="number">100</span>,<span class="number">150</span>,<span class="number">200</span>) <span class="comment">#更改位置(100,100)处的像素</span></span><br><span class="line">(b,g,r) = img[<span class="number">100</span>, <span class="number">100</span>]</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"位置(100,100)处的像素 - 红:%d,绿:%d,蓝:%d"</span> %(r,g,b)) <span class="comment">#显示更改后的像素值</span></span><br></pre></td></tr></table></figure>
<p>其输出结果为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">位置(<span class="number">100</span>,<span class="number">100</span>)处的像素 - 红:<span class="number">30</span>,绿:<span class="number">86</span>,蓝:<span class="number">181</span></span><br><span class="line">位置(<span class="number">100</span>,<span class="number">100</span>)处的像素 - 红:<span class="number">200</span>,绿:<span class="number">150</span>,蓝:<span class="number">100</span></span><br></pre></td></tr></table></figure>
<h3 id="获取三维矩阵的子矩阵"><a href="#获取三维矩阵的子矩阵" class="headerlink" title="获取三维矩阵的子矩阵"></a>获取三维矩阵的子矩阵</h3><p>newImage = img[i:j, m:n]，可以获取第i行到第j行与第m列到第n列的交叉部分</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">corner = img[<span class="number">0</span>:<span class="number">100</span>,<span class="number">0</span>:<span class="number">100</span>]<span class="comment">#读取像素块</span></span><br><span class="line">cv2.imshow(<span class="string">"Corner"</span>,corner)<span class="comment">#显示读取的像素块</span></span><br></pre></td></tr></table></figure>
<p>显示结果为：</p>
<p><img src="https://photo.hushhw.cn/images/images_zijuchen.png" alt></p>
<h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>下面实现一个修改像素块颜色的demo</p>
<p>第一种方法可以通过上面第一种方法从某一点开始用for循环对区域内进行像素值改变，完整代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">img = cv2.imread(<span class="string">'image0.jpg'</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">100</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">100</span>):</span><br><span class="line">        img[i, j] = (<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>) <span class="comment">#green 像素值的写入</span></span><br><span class="line">cv2.imshow(<span class="string">'image_xiangsu'</span>, img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>第二种方法可以用上面第二种方法直接得到像素块，直接修改像素值，完整代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">img = cv2.imread(<span class="string">'image0.jpg'</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">img[<span class="number">0</span>:<span class="number">100</span>, <span class="number">0</span>:<span class="number">100</span>] = (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>)</span><br><span class="line">cv2.imshow(<span class="string">'image_xiangsu'</span>, img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>显示结果一样：</p>
<p><img src="https://photo.hushhw.cn/images/images_xiangsu.png" alt></p>
<p>​       </p>
<blockquote>
<p>本文整理自：</p>
<p>《OpenCV文档》</p>
<p>《OpenCV+TensorFlow 入门人工智能图像处理》系列课程视频</p>
</blockquote>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>计算机视觉</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>使用七牛插件自动上传图片</title>
    <url>/posts/42084.html</url>
    <content><![CDATA[<blockquote>
<p>之前使用七牛云都是手动打开网页传图片，</p>
<p>复制图片网址来用，</p>
<p>最近才发现这个插件可以直接本地上传，</p>
<p>记录一下备之后使用。</p>
</blockquote>
<a id="more"></a>
<p>​       </p>
<p><img src="https://photo.hushhw.cn/images/qiniu.png alt:图片来源网络" alt></p>
<p>​        </p>
<h3 id="设置hexo-qiniu-sync插件"><a href="#设置hexo-qiniu-sync插件" class="headerlink" title="设置hexo-qiniu-sync插件"></a>设置<code>hexo-qiniu-sync</code>插件</h3><ol>
<li><p>安装插件：在hexo主目录下运行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-qiniu-sync --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加插件配置信息到<code>_config.yml</code>文件中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugins:</span><br><span class="line">  - hexo-qiniu-sync</span><br><span class="line"></span><br><span class="line">#七牛云存储设置</span><br><span class="line">##offline       是否离线. 离线状态将使用本地地址渲染</span><br><span class="line">##sync          是否同步</span><br><span class="line">##bucket        空间名称.</span><br><span class="line">##access_key    上传密钥AccessKey</span><br><span class="line">##secret_key    上传密钥SecretKey</span><br><span class="line">##secret_file   秘钥文件路径，可以将上述两个属性配置到文件内，防止泄露，json格式。绝对路径相对路径均可</span><br><span class="line">##dirPrefix     上传的资源子目录前缀.如设置，需与urlPrefix同步 </span><br><span class="line">##urlPrefix     外链前缀.</span><br><span class="line">##local_dir     本地目录.</span><br><span class="line">##update_exist  是否更新已经上传过的文件(仅文件大小不同或在上次上传后进行更新的才会重新上传)</span><br><span class="line">##image/js/css  子参数folder为不同静态资源种类的目录名称，一般不需要改动</span><br><span class="line">##image.extend  这是个特殊参数，用于生成缩略图或加水印等操作。具体请参考http://developer.qiniu.com/docs/v6/api/reference/fop/image/ </span><br><span class="line">##              可使用基本图片处理、高级图片处理、图片水印处理这3个接口。例如 ?imageView2/2/w/500 即生成宽度最多500px的缩略图</span><br><span class="line"></span><br><span class="line">qiniu:</span><br><span class="line">  offline: false</span><br><span class="line">  sync: true</span><br><span class="line">  bucket: bucket_name</span><br><span class="line">  secret_file: sec/qn.json or C:</span><br><span class="line">  access_key: AccessKey</span><br><span class="line">  secret_key: SecretKey</span><br><span class="line">  dirPrefix: static</span><br><span class="line">  urlPrefix: http://bucket_name.qiniudn.com/static</span><br><span class="line">  local_dir: static</span><br><span class="line">  update_exist: true</span><br><span class="line">  image: </span><br><span class="line">    folder: images</span><br><span class="line">    extend: </span><br><span class="line">  js:</span><br><span class="line">    folder: js</span><br><span class="line">  css:</span><br><span class="line">    folder: css</span><br></pre></td></tr></table></figure>
<p>几个需要注意修改的地方：</p>
<ul>
<li><p><code>bucket</code>：修改为你申请的七牛空间名称</p>
</li>
<li><p><code>access_key</code>、<code>secret_key</code>：上传密钥AK和SK，可以在七牛个人空间找到。</p>
<p><img src="https://photo.hushhw.cn/images/qiniu_ak_sk.png" alt></p>
</li>
<li><p><code>urlPrefix</code> : 七牛空间地址的前缀。上面的示例是复制的github文档写的，还是使用的二级域名表示的，但现在七牛已经取消了二级域名，而需要自己建的空间中找分配的七牛测试域名然后填写在这里，也可以查看一个已上传的文件外链地址，确认前缀无误。例如我的是<code>http://p86wg7kc2.bkt.clouddn.com</code>。</p>
</li>
<li><p><code>dirPrefix</code>：资源将上传到七牛空间的此目录下，也可以设置为空，该参数会影响外链地址，如设置为非空值，例如默认的<code>static</code>，则 <code>urlPrefix</code> 为保持一致需加上目录后缀 <code>/static</code> ，改为 <code>http://p86wg7kc2.bkt.clouddn.com/static</code> 。</p>
</li>
<li><p><code>local_dir</code> ：本地资源储存目录。在本例中，待上传的资源都储存在hexo主目录中的 <code>cdn</code> 文件夹（也就是与 <code>source</code> 目录平级）中。</p>
</li>
<li><p><code>update_exist</code> ：设置为 <code>true</code> ，则会在文件更新之后重新上传并更新七牛空间上中的原有文件。</p>
</li>
<li><p><code>image</code> : <code>extend</code> 参数：这是个特殊参数，是文章内使用 <code>qnimg</code> 标签引用图片的默认图片处理操作。可以使用 基本图片处理（imageView2）、高级图片处理（imageMogr2）、图片水印处理（watermark） 这三个图片处理接口，多个接口内容之间用 <code>|</code> 间隔。例如 <code>?imageView2/2/w/500</code> 即生成宽度最多500px的缩略图。</p>
</li>
</ul>
</li>
</ol>
<p>​      </p>
<h3 id="配置本地目录"><a href="#配置本地目录" class="headerlink" title="配置本地目录"></a>配置本地目录</h3><p>本地目录名需要与<code>local_dir</code>参数的值一致，本例中在hexo主目录下新建与source平级的目录cdn，用于存放需要上传到七牛的资源。</p>
<p>在 <code>cdn</code> 目录下创建子目录： <code>css</code> 、 <code>images</code> 、 <code>js</code> ，与 <code>image/js/css</code> 子参数 <code>folder</code> 保持一致，待上传的css、图片、js文件应该存储到相应子目录。我的Hexo主目录结构如下：</p>
<blockquote>
<p>├─.deploy_git<br>├─cdn<br>│ ├─css<br>│ ├─images<br>│ └─js<br>├─node_modules<br>├─public<br>├─scaffolds<br>├─source<br>└─theme</p>
</blockquote>
<p>​     </p>
<h3 id="引用七牛资源"><a href="#引用七牛资源" class="headerlink" title="引用七牛资源"></a>引用七牛资源</h3><p>在文中需要放图片的地方插入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![](https://photo.hushhw.cn/images/ImgFile)</span><br></pre></td></tr></table></figure>
<p>其中<code>ImgFile</code>为放在本地images文件下的图片名称，例如我这里插入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![](https://photo.hushhw.cn/images/xiaoanphoto.jpg)</span><br></pre></td></tr></table></figure>
<p>就会显示图片：</p>
<p><img src="https://photo.hushhw.cn/images/xiaoanphoto.jpg" alt></p>
<p>这里生成的图片外链被自动转为 <code>urlPrefix</code> + <code>/</code> + <code>image.folder</code> + <code>/</code> + <code>ImgFile</code> ，这里我插入的这张图片的链接为：<code>http://p86wg7kc2.bkt.clouddn.com/images/xiaoanphoto.jpg</code>。</p>
<p>​    </p>
<p>高级用法的通用模板：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![](https://photo.hushhw.cn/images/imageFile attr1:value1 attr2:value2 &apos;attr3:value31 value32 value3n&apos; [extend:... | normal:yes])</span><br></pre></td></tr></table></figure>
<ul>
<li><code>[]</code> 表示可选项，按需添加，也可以不写</li>
<li><code>|</code> 表示二选一<ul>
<li><code>extend:...</code> 图片处理参数，表示对图片进行某种特定处理，可以使用 基本图片处理（imageView2）、高级图片处理（imageMogr2）、图片水印处理（watermark） 这三个图片处理接口，多个处理之间用 <code>|</code> 间隔。</li>
<li><code>normal:yes</code> 表示使用原图，忽略 <code>_config.yml</code> 文件中的 <code>image.extend</code> 设置</li>
</ul>
</li>
</ul>
<p>比如下面这个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![](https://photo.hushhw.cn/images/xiaoanphoto.jpg title:图片来源@小安 alt:@小安 &apos;class:class1 class2&apos; extend:?imageView2/2/w/600)</span><br></pre></td></tr></table></figure>
<p>将被渲染成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img title=&quot;图片来源@小安&quot; alt=&quot;@小安&quot; class=&quot;class1 class2&quot; src=&quot;http://p86wg7kc2.bkt.clouddn.com/images/xiaoanphoto.jpg?imageView2/2/w/600&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>如果你在 <code>_config.yml</code> 文件中配置了 <code>extend</code> 字段，则默认会对插入的图片进行对应的处理。<br>如果不想对一个图片进行处理，则可在 <code>qnimg</code> 标签内增加 <code>normal:yes</code> 参数，则使用原图，不进行图片处理。<br>如果只对当前图片进行处理，则可在 <code>qnimg</code> 标签内增加 <code>extend:?imageView2/2/w/600</code> 样式的配置参数。<br>当 <code>_config.yml</code> 文件中和 <code>qnimg</code> 标签内都定义了 <code>extend</code> 参数，则只会使用 <code>qnimg</code> 标签的 <code>extend</code> 参数。</p>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p><strong>作为一个带命令行功能的插件，漏掉了命令行的使用说明不是好习惯。</strong> 本插件命令行为 <code>hexo qiniu</code> ，所支持的子命令有：</p>
<ul>
<li><code>info</code> (简写 <code>i</code> )</li>
</ul>
<blockquote>
<p>功能：显示插件版本，作者及Github地址信息等</p>
</blockquote>
<ul>
<li><code>sync</code> (简写 <code>s</code> )</li>
</ul>
<blockquote>
<p>功能：同步静态资源到七牛空间</p>
</blockquote>
<ul>
<li><code>sync2</code> (简写 <code>s2</code> )</li>
</ul>
<blockquote>
<p>功能：同步静态资源到七牛空间，且会同步上传那些本地与七牛空间有差异的文件。<br><strong>这个命令会无视 update_exist 配置</strong>。<br>对比规则请看 <code>update_exist</code> 配置参数说明。</p>
</blockquote>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><blockquote>
<p><a href="https://github.com/gyk001/hexo-qiniu-sync" target="_blank" rel="noopener">https://github.com/gyk001/hexo-qiniu-sync</a> <code>hexo-qiniu-sync</code> 的官方说明文档部分内容已过时</p>
<p><a href="https://yuchen-lea.github.io/2016-01-21-use-qiniu-store-file-for-hexo" target="_blank" rel="noopener">https://yuchen-lea.github.io/2016-01-21-use-qiniu-store-file-for-hexo</a></p>
</blockquote>
]]></content>
      <categories>
        <category>建站笔记</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>hexo</tag>
        <tag>七牛云</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-OpenCV学习笔记——图片写入及图片质量</title>
    <url>/posts/20751.html</url>
    <content><![CDATA[<blockquote>
<p>本篇是OpenCV学习系列第二篇，</p>
<p>主要是imwrite()函数写入图片及修改不同的图片质量</p>
</blockquote>
<a id="more"></a>
<p>​        </p>
<p><img src="https://photo.hushhw.cn/images/kite.jpg title:&quot;photo by hushhw&quot;" alt></p>
<p>​           </p>
<p>图片写入在第一篇已经涉及到了，具体代码实现是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C++: bool imwrite(const string&amp; filename, InputArray img, const vector&lt;int&gt;&amp; params=vector&lt;int&gt;() )</span><br><span class="line"></span><br><span class="line">python: cv2.imwrite(filename, img, [params])</span><br></pre></td></tr></table></figure>
<p>前面只涉及到第一个参数是保存的路径及文件名，第二个是图片数据（图像矩阵）。其中，<code>imwrite()</code>有个可选的第三个参数<code>[params]</code>，默认为空：</p>
<ul>
<li><p>对于JPEG格式压缩的图片，可以设置图片质量参数<code>[cv2.IMWRITE_JPEG_QUALITY, num]</code>，该参数的范围是<code>0</code>到<code>100</code>，数字越大质量越好，默认的大小为95，该压缩是有损压缩，以牺牲图片质量为代价。</p>
<p>​    在默认情况下图片显示为<code>cv2.imwrite(images.jpg, img, [cv2.IMWRITE_JPEG_QUALITY])</code>：</p>
<p><img src="https://photo.hushhw.cn/images/image_jpeg_quality_95.jpg" alt></p>
<p>​    但是把参数设置为5的时候，图片被严重压缩<code>cv2.imwrite(images.jpg, img, [cv2.IMWRITE_JPEG_QUALITY])</code>：</p>
<p><img src="https://photo.hushhw.cn/images/image_jpeg_quality_5.jpg" alt></p>
</li>
<li><p>对于PNG格式压缩的图片，可以设置图片质量参数<code>[cv2.IMWRITE_PNG_COMPRESSION]</code>，该参数的范围是<code>0</code>到<code>9</code>，其值越大，压缩尺寸越小，压缩时间越长，默认值为3，该压缩是无损的。</p>
</li>
<li><p>对于PPM，PGM或PBM格式的图片，这个参数表示一个二进制格式标志<code>[CV_IMWRITE_PXM_BINARY]</code>，取值为0或1，而默认值为1。</p>
</li>
</ul>
<p>​       </p>
<blockquote>
<p>本文整理自：</p>
<p>《OpenCV文档》</p>
<p>《OpenCV+TensorFlow 入门人工智能图像处理》系列课程视频</p>
</blockquote>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>计算机视觉</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-OpenCV学习笔记——图片读取、展示和写入</title>
    <url>/posts/12a01be2.html</url>
    <content><![CDATA[<blockquote>
<p>把环境搭建之后，就开始记录学习笔记了，</p>
<p>这是本系列第一篇，</p>
<p>内容都非常基础，只是整理给自己，</p>
<p>基础的东西很久不用就会忘记的。</p>
</blockquote>
<a id="more"></a>
<p>​        </p>
<p><img src="https://photo.hushhw.cn/images/xiaoanphoto.jpg title:图片来自微博@小安" alt></p>
<p>​          </p>
<h3 id="引入OpenCV"><a href="#引入OpenCV" class="headerlink" title="引入OpenCV"></a>引入OpenCV</h3><p>读取图像首先要导入OpenCV包，方法为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br></pre></td></tr></table></figure>
<h3 id="调用API"><a href="#调用API" class="headerlink" title="调用API"></a>调用API</h3><h4 id="1-读取图片"><a href="#1-读取图片" class="headerlink" title="1. 读取图片"></a>1. 读取图片</h4><p>读取图片使用<code>cv2.imread()</code> ，可以按照不同的模式读取，一般最常用到的是读取单通道灰度图，或者直接默认读取多通道。</p>
<blockquote>
<p>Python: retval = cv.imread(filename, [flags])</p>
<p>简单理解，第一个参数为图片名称，第二个是读取图片的格式，主要有以下参数</p>
<ul>
<li>cv2.IMREAD_COLOR：彩色模式，可用数字1代表</li>
<li>cv2.IMREA_GRAYSCALE：灰度图，即数字0</li>
<li>cv2.IMREAD_UNCHANGED</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">'image0.jpg'</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>这里读取图片实际上经历了四个步骤：</p>
<ul>
<li><p>文件的读取</p>
</li>
<li><p>封装格式的解析（如jpg、png格式，都是文件封装格式）</p>
<p>这里我们一般把文件分成两部分来看待，<code>文件头</code>和<code>文件数据</code>，不同的jpg、png有不同的文件头和文件数据。这里描述的文件数据不是图片的原始数据，而是图片被压缩编码后的数据，大部分的文件头则描述的是数据部分的解码信息以及附加信息，解码器可以根据这些附加信息把数据还原成原始数据。</p>
</li>
<li><p>数据解码</p>
</li>
<li><p>数据加载</p>
</li>
</ul>
<h4 id="2-创建窗体"><a href="#2-创建窗体" class="headerlink" title="2. 创建窗体"></a>2. 创建窗体</h4><p>使用imshow()常见一个窗体展示图片，第一个参数为窗体名称，第二个是展示内容</p>
<blockquote>
<p>Python: None = cv.imshow(winname, mat)</p>
</blockquote>
<p>这里创建一个叫”image”的窗体来展示上面的img</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cv2.imshow(&apos;image&apos;, img)</span><br></pre></td></tr></table></figure>
<h4 id="3-图片写入"><a href="#3-图片写入" class="headerlink" title="3. 图片写入"></a>3. 图片写入</h4><p>保存图像很简单，直接用cv2.imwrite即可。</p>
<p>cv2.imwrite(“images.jpg”, img)</p>
<p>第一个参数是保存的路径及文件名，第二个是图片数据（图像矩阵）。</p>
<h3 id="暂停程序"><a href="#暂停程序" class="headerlink" title="暂停程序"></a>暂停程序</h3><p>最后要加<code>cv2.waitKey(0)</code> 来把程序暂停，如果不添最后一句程序会是一闪而过。</p>
<p>cv2.waitKey()函数等待键盘响应，键盘按下之后退出，一般里面的参数都是0，也接受键盘的输入。</p>
<p>下面就做一个简单判断，来执行关闭窗口或保存图片并关闭窗口。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">k = cv2.waitKey(<span class="number">0</span>) &amp; <span class="number">0xFF</span> <span class="comment">#64位的电脑需要加 &amp;0xFF</span></span><br><span class="line"><span class="keyword">if</span> k == <span class="number">27</span>: <span class="comment"># ESC键</span></span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line"><span class="keyword">elif</span> k == ord(<span class="string">'s'</span>):</span><br><span class="line">    cv2.imwrite(<span class="string">'images.jpg'</span>,img)</span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p>完整代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'image0.jpg'</span>,<span class="number">1</span>)</span><br><span class="line">cv2.imshow(<span class="string">'image'</span>,img)</span><br><span class="line">k = cv2.waitKey(<span class="number">0</span>) &amp; <span class="number">0xFF</span> <span class="comment">#64位的电脑需要加 &amp;0xFF</span></span><br><span class="line"><span class="keyword">if</span> k == <span class="number">27</span>: <span class="comment"># ESC键</span></span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line"><span class="keyword">elif</span> k == ord(<span class="string">'s'</span>):</span><br><span class="line">    cv2.imwrite(<span class="string">'images.jpg'</span>,img)</span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>本文整理自：</p>
<p>《OpenCV文档》</p>
<p>《OpenCV+TensorFlow 入门人工智能图像处理》系列课程视频</p>
<p><a href="https://blog.csdn.net/poi7777/article/details/39700163" target="_blank" rel="noopener">https://blog.csdn.net/poi7777/article/details/39700163</a></p>
</blockquote>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>计算机视觉</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>Anaconda+python3+opencv3+TensorFlow的安装</title>
    <url>/posts/23537.html</url>
    <content><![CDATA[<p><img src="https://photo.hushhw.cn/TIM%E6%88%AA%E5%9B%BE20180717224539.png" alt="图片来源官网"></p>
<blockquote>
<p>打算花时间入门一下计算机视觉，</p>
<p>做点东西出来玩一玩，顺便</p>
<p>考虑一下用来做毕设的可能性，</p>
<p>这篇用来记录环境配置。</p>
</blockquote>
<a id="more"></a>
<p><strong>安装环境：</strong>Windows（64 bit）CPU</p>
<p><strong>安装版本：</strong>Anaconda3-4.5.4-Windows-x86_64（Python3.6）</p>
<p>​                   Opencv 3.4.2</p>
<p>后面安装介绍基于此环境和版本</p>
<h2 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h2><h3 id="为什么要装Anaconda"><a href="#为什么要装Anaconda" class="headerlink" title="为什么要装Anaconda"></a>为什么要装Anaconda</h3><p><strong>你可能已经安装了 Python，那么为什么还需要 Anaconda？有以下3个原因：</strong></p>
<p>1）Anaconda 附带了一大批常用数据科学包，它附带了 conda、Python 和 150 多个科学包及其依赖项。因此你可以立即开始处理数据。</p>
<p>2）管理包</p>
<p>​    Anaconda 是在 conda（一个包管理器和环境管理器）上发展出来的。</p>
<p>​    在数据分析中，你会用到很多第三方的包，而conda（包管理器）可以很好的帮助你在计算机上安装和管理这    些包，包括安装、卸载和更新包。</p>
<p>3）管理环境</p>
<p>​    为什么需要管理环境呢？</p>
<p>​    比如你在A项目中用了 Python 2，而新的项目B老大要求使用Python 3，而同时安装两个Python版本可能会造成许多混乱和错误。这时候 conda就可以帮助你为不同的项目建立不同的运行环境。</p>
<p>​    还有很多项目使用的包版本不同，比如不同的pandas版本，不可能同时安装两个 Numpy 版本，你要做的应该是，为每个 Numpy 版本创建一个环境，然后项目的对应环境中工作。这时候conda就可以帮你做到。</p>
<blockquote>
<p>上面这段摘自知乎回答：初学python者自学anaconda的正确姿势是什么？？ - 猴子的回答 - 知乎<br><a href="https://www.zhihu.com/question/58033789/answer/254673663" target="_blank" rel="noopener">https://www.zhihu.com/question/58033789/answer/254673663</a></p>
</blockquote>
<h3 id="安装Anaconda"><a href="#安装Anaconda" class="headerlink" title="安装Anaconda"></a>安装Anaconda</h3><ul>
<li><p>从官网 <a href="https://www.anaconda.com/download/" target="_blank" rel="noopener">https://www.anaconda.com/download/</a> 下载对应版本，如我选择的版本为Anaconda3-4.5.4-Windows-x86_64（Python3.6），目前（2018.07.17）更新到Anaconda3-5.2.0</p>
</li>
<li><p>安装部分没有坑，next即可，切记将Anaconda添加到系统变量路径中，即勾选第一项，否则配置环境变量会很麻烦，能方便就方便吧。</p>
<p><img src="https://photo.hushhw.cn/20171021092759947.png" alt="图片来源水印"></p>
</li>
</ul>
<h3 id="修改镜像"><a href="#修改镜像" class="headerlink" title="修改镜像"></a>修改镜像</h3><ul>
<li><p>通过 conda config 命令生成配置文件</p>
<p>这里，我们使用清华的镜像：<a href="https://link.jianshu.com/?t=https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</a></p>
<p>首先，在CMD命令行输入以下两条命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure>
<p>此时，目录 C:\Users&lt;你的用户名&gt; 下就会生成配置文件.condarc，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">channels:</span><br><span class="line">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">defaults</span><br><span class="line">   show_channel_urls: true</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改配置文件</p>
<p>删除上述配置文件 .condarc 中的第三行，然后保存，最终版本文件如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">channels:</span><br><span class="line">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">   show_channel_urls: true</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看是否生效</p>
<p>通过命令 conda info 查看当前配置信息，内容如下，即修改成功，关注 channel URLs 字段内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;conda info</span><br><span class="line">Current conda install:</span><br><span class="line"></span><br><span class="line">               platform : win-32</span><br><span class="line">          conda version : 4.3.22</span><br><span class="line">       conda is private : False</span><br><span class="line">      conda-env version : 4.3.22</span><br><span class="line">       requests version : 2.12.4</span><br><span class="line">           channel URLs : https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/win-32</span><br><span class="line">                          https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/noarch</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="OpenCV、tensorflow、notebook"><a href="#OpenCV、tensorflow、notebook" class="headerlink" title="OpenCV、tensorflow、notebook"></a>OpenCV、tensorflow、notebook</h2><p>这部分先用图形界面操作会比较直观，打开Anaconda Navigator，按照如图创建虚拟环境：</p>
<p><img src="https://photo.hushhw.cn/TIM%E6%88%AA%E5%9B%BE20180717233907.png" alt></p>
<p>之后打开命令行终端，如图：</p>
<p><img src="https://photo.hushhw.cn/TIM%E6%88%AA%E5%9B%BE20180717234645.png" alt></p>
<p>如果用命令行创建的话，打开Anaconda Prompt（或直接管理员身份运行cmd)输入conda create -n tensorflow即可，然后执行activate tensorflow激活环境。</p>
<p><img src="https://photo.hushhw.cn/20171021095429960.png" alt="图片来源见水印"></p>
<p>这里先排一个坑：检查一下pip版本，输入pip -V</p>
<p><img src="https://photo.hushhw.cn/pip.png" alt></p>
<p>后面在安装的时候如果出现pip版本不够的提示，请升级pip版本，报错信息可能为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">You are using pip version 9.0.3, however version 10.0.1 is available.</span><br><span class="line">You should consider upgrading via the &apos;python -m pip install --upgrade pip&apos; command.</span><br></pre></td></tr></table></figure>
<p>升级执行：</p>
<p><img src="https://photo.hushhw.cn/upgrade%20pip.png" alt></p>
<p>另外还有numpy的版本，可执行pip install numpy 安装</p>
<h3 id="OpenCV安装"><a href="#OpenCV安装" class="headerlink" title="OpenCV安装"></a>OpenCV安装</h3><p>到此镜像站下载opencv <a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/" target="_blank" rel="noopener">http://www.lfd.uci.edu/~gohlke/pythonlibs/</a> </p>
<p>选择最新windows64位的版本opencv，我下载的是<strong>opencv_python-3.4.2-cp36-cp36m-win_amd64.whl</strong>（win32或i386或x86指的是32位操作系统，amd64指的是64位，而不是指amd处理器）<br><strong>将下载所得的whl文件放至anacoda3安装目录下的Scripts文件夹</strong>（anaconda正确安装的话，此文件夹中应有pip.exe）</p>
<p>打开cmd或在上面打开的终端输入  <strong>pip install D:\Anaconda\Scripts\opencv_python-3.4.2-cp36-cp36m-win_amd64.whl(文件路径)</strong> </p>
<p><img src="https://photo.hushhw.cn/opencv.png" alt></p>
<p>初次安装显示Successful installed opencv-python-3.4.2即安装成功。</p>
<p>测试一下：</p>
<p><img src="https://photo.hushhw.cn/opencv2.png" alt></p>
<h3 id="tensorflow安装"><a href="#tensorflow安装" class="headerlink" title="tensorflow安装"></a>tensorflow安装</h3><p>TensorFlow 有两个版本：<strong>CPU</strong> 版本和 <strong>GPU</strong> 版本。GPU 版本需要 <strong>CUDA</strong> 和 <strong>cuDNN</strong> 的支持，CPU 版本不需要。如果你要安装 GPU 版本，<strong>请先确认你的显卡支持 CUDA</strong>。</p>
<p>这里安装的tensorflow是CPU版本的，很多教程都有要求说Python 版本必须是3.5，实际上我们现在安装TensorFlow 从 1.2 开始支持 Python 3.6，之前的官方是不支持的。<br>安装过程和上面一样，执行代码<strong>pip install –upgrade tensorflow</strong> </p>
<p><img src="https://photo.hushhw.cn/tensorflow.png" alt></p>
<p>我这里都安装过了结果如上。</p>
<h3 id="notebook安装及helloworld测试"><a href="#notebook安装及helloworld测试" class="headerlink" title="notebook安装及helloworld测试"></a>notebook安装及helloworld测试</h3><p>在Anaconda Navigator的home页面把虚拟环境切换到tensorflow，点击notebook的按钮安装，安装成功后会变成Lunch如下图：</p>
<p><img src="https://photo.hushhw.cn/notebook.png" alt></p>
<p>点击Lunch在浏览器中运行notebook，如下图新建一个文件helloword.ipynb</p>
<p><img src="https://photo.hushhw.cn/notebook2.png" alt></p>
<p>输入如下代码运行，测试环境：</p>
<p><img src="https://photo.hushhw.cn/helloopencv.png" alt></p>
<blockquote>
<p>本篇博客整理参考自：（感谢大佬们带入坑）</p>
<p><a href="https://blog.csdn.net/qq_28818465/article/details/78441006" target="_blank" rel="noopener">https://blog.csdn.net/qq_28818465/article/details/78441006</a></p>
<p><a href="https://blog.csdn.net/qq_41185868/article/details/80469489" target="_blank" rel="noopener">https://blog.csdn.net/qq_41185868/article/details/80469489</a></p>
<p><a href="https://www.jianshu.com/p/042fd657e2d4" target="_blank" rel="noopener">https://www.jianshu.com/p/042fd657e2d4</a></p>
</blockquote>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>计算机视觉</tag>
        <tag>OpenCV</tag>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>Google 搜索引擎设置搜索结果，在新的标签页打开</title>
    <url>/posts/61ebe669.html</url>
    <content><![CDATA[<p>Google搜索默认是在此页面打开网页，使用起来并不方便，修改方法：</p>
<p>在地址栏输入：<a href="https://www.google.com/preferences" target="_blank" rel="noopener">https://www.google.com/preferences</a> ，修改如下图所示。</p>
<p><img src="https://photo.hushhw.cn/google_tool.png" alt="google"></p>
]]></content>
      <categories>
        <category>日常技巧</category>
      </categories>
      <tags>
        <tag>Google</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-SDK下载安装及配置</title>
    <url>/posts/43678.html</url>
    <content><![CDATA[<p><img src="https://photo.hushhw.cn/sdk01.png" alt></p>
<blockquote>
<p>接着上一篇没有解决的问题继续写，</p>
<p>SDK的安装下载其实不是什么大难题，</p>
<p>只是之前没有去了解，以为很难，</p>
<p>这篇文章会介绍具体的怎么下载使用。</p>
</blockquote>
<a id="more"></a>
<h3 id="下载并安装Android-SDK"><a href="#下载并安装Android-SDK" class="headerlink" title="下载并安装Android SDK"></a><strong>下载并安装Android SDK</strong></h3><p>官网（可翻墙选择）：<a href="http://developer.android.com/sdk/index.html" target="_blank" rel="noopener">http://developer.android.com/sdk/index.html</a></p>
<p>不可翻墙选择：<a href="http://www.androiddevtools.cn/" target="_blank" rel="noopener">http://www.androiddevtools.cn/</a></p>
<p>（下面以第二种方法为例进行下载）</p>
<p>1、下载Android SDK Tools</p>
<p>先找到SDK Tools,下载最新的版本即可。选择zip的，解压缩至目标路径位置即可</p>
<p> <img src="https://photo.hushhw.cn/sdk01.png" alt="img"></p>
<p> <img src="https://photo.hushhw.cn/sdk02.png" alt="img"></p>
<p>2、双击“SDK Manager”，启动SDK Manager</p>
<p>里面具体的内容找到了一张超级厉害的图，可以看看：</p>
<p><img src="https://photo.hushhw.cn/20161115143939558.jpg" alt="来源网络"></p>
<p>①、Tools的勾选图示选项下载即可。</p>
<p> <img src="https://photo.hushhw.cn/20170814174701471.jpg" alt="img"></p>
<p>②、API的任意选择一个，考虑向下兼容原则，可以下载最新的API。</p>
<p>③、Extras的全选</p>
<p> <img src="https://photo.hushhw.cn/20170814174706871.jpg" alt="img"></p>
<p>注：无法下载的会出现以下提示</p>
<p> <img src="https://photo.hushhw.cn/20170814174715941.jpg" alt="img"></p>
<p><strong>Android SDK在线更新镜像服务器：</strong></p>
<p>中国科学院开源协会镜像站地址:</p>
<p>IPV4/IPV6: <a href="http://mirrors.opencas.cn" target="_blank" rel="noopener">http://mirrors.opencas.cn</a> 端口：80</p>
<p>IPV4/IPV6: <a href="http://mirrors.opencas.org" target="_blank" rel="noopener">http://mirrors.opencas.org</a> 端口：80</p>
<p>IPV4/IPV6: <a href="http://mirrors.opencas.ac.cn" target="_blank" rel="noopener">http://mirrors.opencas.ac.cn</a> 端口：80</p>
<p>上海GDG镜像服务器地址:</p>
<p><a href="http://sdk.gdgshanghai.com" target="_blank" rel="noopener">http://sdk.gdgshanghai.com</a> 端口：8000</p>
<p>北京化工大学镜像服务器地址:</p>
<p>IPv4: <a href="http://ubuntu.buct.edu.cn/" target="_blank" rel="noopener">http://ubuntu.buct.edu.cn/</a> 端口：80</p>
<p>IPv4: <a href="http://ubuntu.buct.cn/" target="_blank" rel="noopener">http://ubuntu.buct.cn/</a> 端口：80</p>
<p>IPv6: <a href="http://ubuntu.buct6.edu.cn/" target="_blank" rel="noopener">http://ubuntu.buct6.edu.cn/</a> 端口：80</p>
<p>大连东软信息学院镜像服务器地址:</p>
<p><a href="http://mirrors.neusoft.edu.cn" target="_blank" rel="noopener">http://mirrors.neusoft.edu.cn</a> 端口：80</p>
<p>使用 Android SDK Manager下载sdk时 ，打开主界面，选择「Tools」、「Options」，弹出『Android SDK Manager - Settings』窗口：</p>
<p>在『Android SDK Manager - Settings』窗口中，在「HTTP Proxy Server」和「HTTP Proxy Port」输入框内填入 mirrors.neusoft.edu.cn 和 80，并且选中「Force</p>
<p><a href="https://…sources" target="_blank" rel="noopener">https://…sources</a> to be fetched using <a href="http://…」复选框。" target="_blank" rel="noopener">http://…」复选框。</a></p>
<p>设置完成后单击「Close」按钮关闭重新打开即可。如下图：</p>
<p><img src="https://photo.hushhw.cn/20150725152858881.png" alt="img"></p>
<p>3、设置环境变量</p>
<p>①、新建一个系统环境变量，变量名为ANDROID_SDK_HOME，变量值为你的SDK安装路径</p>
<p> <img src="https://photo.hushhw.cn/20170814174729762.jpg" alt="img"></p>
<p>②把%ANDROID_SDK_HOME%\platform-tools;%ANDROID_SDK_HOME%\tools添加到Path环境变量中。</p>
<p>③检测是否配置成功。打开命令行窗口，输入adb。出现如下图所示内容则配置成功：</p>
<p> <img src="https://photo.hushhw.cn/20170814174734937.jpg" alt="img"></p>
<p>4、常见问题</p>
<p>若sdk manager.exe 打不开，多是由于缺少环境变量造成的，可以先把第三步设置环境变量先完成再去执行第二步。</p>
<blockquote>
<p>本文整理自：</p>
<p><a href="https://blog.csdn.net/qq_21150865/article/details/71105640" target="_blank" rel="noopener">https://blog.csdn.net/qq_21150865/article/details/71105640</a></p>
<p><a href="https://blog.csdn.net/love4399/article/details/77164500" target="_blank" rel="noopener">https://blog.csdn.net/love4399/article/details/77164500</a></p>
<p><a href="https://blog.csdn.net/pipisorry/article/details/20807505" target="_blank" rel="noopener">https://blog.csdn.net/pipisorry/article/details/20807505</a></p>
</blockquote>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity导出导出 Android 工程、应用</title>
    <url>/posts/36070.html</url>
    <content><![CDATA[<blockquote>
<p>虚拟现实实践课程第一天下午又开始了麻烦的配置环境，</p>
<p>又回到了被Android环境支配的恐惧，</p>
<p>但是这一次并不是不熟悉JDK、SDK的一些本地环境配置，</p>
<p>而是因为之前Cocos环境配置的JDK（前段时间装eclipse升级了）、SDK版本太低了，</p>
<p>全班找不到几个可以用的高于23的SDK版本，所以都在升级。</p>
</blockquote>
<a id="more"></a>
<p>​         </p>
<p><img src="https://photo.hushhw.cn/sdk.jpg" alt></p>
<h2 id="Step-1-设置-Android-SDK-和-JDK-路径"><a href="#Step-1-设置-Android-SDK-和-JDK-路径" class="headerlink" title="Step 1. 设置 Android SDK 和 JDK 路径"></a>Step 1. 设置 Android SDK 和 JDK 路径</h2><p>在 Unity 中，点击 Edit &gt; Preferences…，在弹出的 Unity Preferences 对话框中点击 External Tools 选项，将 Android SDK 和 JDK 路径分别设置为已安装 SDK 的根目录。</p>
<p><img src="https://photo.hushhw.cn/images/doc_unity_build_android_1.png" alt></p>
<hr>
<h2 id="Step-2-选择平台"><a href="#Step-2-选择平台" class="headerlink" title="Step 2. 选择平台"></a>Step 2. 选择平台</h2><p>在 Unity 中，点击 File &gt; Build Settings…，在弹出的 Build Settings 对话框中选择 Android 平台，并点击 Switch Platform，点击 Add Current 将当前工程添加到 Scene In Build 窗口中(请确保已被勾选)。</p>
<p><img src="https://photo.hushhw.cn/images/doc_unity_build_android_2.png" alt></p>
<hr>
<h2 id="Step-3-应用设置"><a href="#Step-3-应用设置" class="headerlink" title="Step 3. 应用设置"></a>Step 3. 应用设置</h2><p>在 Build Settings 对话框中点击 Player Settings…，在 Inspector 窗口中找到 Settings for Android，点击 Resolution and Presentation 选项，将 Default Orientation 设置为 Landscape Left。</p>
<p><img src="https://photo.hushhw.cn/images/doc_unity_build_android_3.png" alt></p>
<p>注意：生成的 Android 应用暂时不支持 Auto Rotation，另外有的手机由于手机自身系统原因不支持 Portrait Upside Down 模式。</p>
<p>点击 Other Settings 选项，取消勾选 Auto Graphics API，然后在 Graphics API 处删除多余选项，仅保留 OpenGLES2。</p>
<p><img src="https://photo.hushhw.cn/images/othersettings1.png" alt></p>
<p>然后，在 Bundle Identifier 中填写应用的 apk 包名，并将 Minimum API Level 设置为 Android 4.0 或更高版本。</p>
<p><img src="https://photo.hushhw.cn/images/othersettings2.png" alt></p>
<hr>
<h2 id="Step-4-生成-Android-应用"><a href="#Step-4-生成-Android-应用" class="headerlink" title="Step 4. 生成 Android 应用"></a>Step 4. 生成 Android 应用</h2><p>完成上述操作后，在 Build Settings 对话框中点击 Build ，保存 apk 并开始生成应用。在此过程中，可能会要求您更新 Android SDK 和 JDK ，请按照提示进行更新。</p>
<p><img src="https://photo.hushhw.cn/images/doc_unity_build_android_5.png" alt></p>
<p>导出成功后可以看到 apk 文件。</p>
<p><img src="https://photo.hushhw.cn/images/doc_unity_build_android_6.png" alt></p>
<hr>
<h2 id="Step-5-导出-Android-工程"><a href="#Step-5-导出-Android-工程" class="headerlink" title="Step 5. 导出 Android 工程"></a>Step 5. 导出 Android 工程</h2><p>如果您希望将当前工程导出为 Android 工程文件，则需要在 Step 4 中，勾选 Build Settings 对话框中的 Google Android Project，然后点击 Export。</p>
<p><img src="https://photo.hushhw.cn/images/sdk-unity02.jpg" alt></p>
<p>导出的工程文件如下图所示：</p>
<p><img src="https://photo.hushhw.cn/images/sdk-unity01.jpg" alt></p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>HIAR制作第一个简易的 AR 应用</title>
    <url>/posts/19ad55f3.html</url>
    <content><![CDATA[<blockquote>
<p>虚拟现实实践课程从今天开始开课，</p>
<p>打算用博客记录学习的过程，</p>
<p>因为课程结束后应该会很少制作相关应用，</p>
<p>所以记录系列笔记方便以后捡起来。</p>
</blockquote>
<a id="more"></a>
<p>​         </p>
<p><img src="https://photo.hushhw.cn/timg.jpg" alt></p>
<p>​           </p>
<p>HiAR SDK for Unity 开发文档：<a href="http://www.hiar.com.cn/doc-v1/sdk-unity/overview/" target="_blank" rel="noopener">http://www.hiar.com.cn/doc-v1/sdk-unity/overview/</a></p>
<blockquote>
<p>HiAR SDK for Unity 是 HiAR 开发平台中的一套 AR SDK，可以让开发者轻松地使用 Unity 3D 开发跨平台的 AR 应用和 AR 游戏。</p>
</blockquote>
<h3 id="HIAR制作第一个简易的-AR-应用"><a href="#HIAR制作第一个简易的-AR-应用" class="headerlink" title="HIAR制作第一个简易的 AR 应用"></a>HIAR制作第一个简易的 AR 应用</h3><p>因为HIAR有一套比较完整的AR SDK，所以整个制作过程并没有难度，以下为步骤（HiAR SDK for Unity 开发文档中有更加完整的过程说明）：</p>
<ul>
<li><p>搭建开发环境</p>
<ul>
<li>Unity安装下载</li>
<li>Android SDK 和 JDK安装下载</li>
</ul>
</li>
</ul>
<ul>
<li><p>导入SDK</p>
<ul>
<li>下载HiAR SDK ：下载地址：<a href="http://www.hiar.com.cn/download.html" target="_blank" rel="noopener">http://www.hiar.com.cn/download.html</a></li>
<li>导入HiAR SDK：双击 hiar_sdk_unity-x.x.x.unitypackage 文件，Unity 将加载并显示插件内容，点击 Import 开始导入。您也可以在 Unity 中，点击 Assets &gt; Import Package &gt; Custom Package… 来导入插件。导入完成后，您可以在 Project 窗口中看到以下内容：<br><img src="https://photo.hushhw.cn/2.jpg" alt="img"><br>提示：Unity 插件与一般意义上的插件存在区别，每次在新工程中使用时，都需要重新进行导入。</li>
</ul>
</li>
</ul>
<ul>
<li><p>使用本地识别包</p>
<ul>
<li>创建图集、上传图片、发布图集、下载识别包：在管理后台中，选择或新建一个图集并上传您想要识别的图片。上传新的识别图片之后，系统会自动对图集进行发布操作。在下图中可以看到，mydata 图集中显示“图集发布中…”。发布完成后您可以开始下载识别图片。您也可以在图集管理界面中查看各图集的发布状态。如果您只需要下载图集中的部分图片，请先勾选需要识别的图片，然后点击“下载选中项”按钮。如果您需要下载图集的所有图片，则不勾选任何项目，直接点击“下载所有项”按钮。</li>
<li>导入识别包：双击 mydata.unitypackage 文件，Unity 加载并显示包内容，点击 Import 开始导入。导入完成后，您可以在 <code>Assets/StreamingAssets/HiAR</code> 目录下看到刚才导入的 mydata。导入完成后，您可以在 <code>Assets/StreamingAssets/HiAR</code> 目录下看到刚才导入的 mydata。<img src="https://photo.hushhw.cn/TIM%E6%88%AA%E5%9B%BE20180620145352.png" alt>ImageTarget 在场景中的尺寸时常需要调整，所以我们给 ImageTarget 添加了 Width 和 Height 两个属性，以方便这一操作。</li>
</ul>
</li>
</ul>
<ul>
<li><p>创建 Hello World</p>
<ul>
<li>注册HiAR 平台账户并获取 AppKey 和 Secret：前往<a href="http://portal.hiar.io/" target="_blank" rel="noopener">HiAR 管理后台</a>的应用管理，点击“新建应用”按钮并按照提示要求创建一个新应用。系统会为每个应用分配唯一的 AppKey 和 Secret。进入应用管理界面，您可以在列表中查看到应用对应的 AppKey 和 Secret。<ul>
<li>新建 Unity 工程并导入 SDK：具体步骤见前一个步骤“导入SDK”</li>
<li>创建 HiARCamera：新建的 Unity 工程中，默认会创建一个 Main Camera（如下图），请先将其删除。然后将 <code>Assets/HiAR-Unity/Prefabs</code> 目录下的 HiARCamera 拖至 Hierarchy 窗口中。在 Hierarchy 窗口中选中 HiARCamera，在其对应的 Inspector 窗口中找到 AppKey 和 Secret 选项，并填写信息。</li>
<li>创建 ImageTarget并设置识别图片：将 <code>Assets/HiAR-Unity/Prefabs</code> 目录下的 ImageTarget 拖至 Hierarchy 窗口中。在 Hierarchy 窗口中选中 ImageTarget，在其对应的 Inspector 窗口中找到 HiAR Target Mono Behaviour (Script)，在 Data Set 选项中选择 sample。此时，编辑窗口中将显示一张”苹果“的图片，这是刚刚设置的识别图片。<img src="https://photo.hushhw.cn/TIM%E6%88%AA%E5%9B%BE20180620143856.png" alt="img">sample 是 SDK 中内置的本地识别包，包含两张识别图片，您可以在 Image Target 选项中进行选择。如果您希望添加自己想识别的图片，可以参考前面的导入本地识别包。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>AR 制作与运行：在 Hierarchy 窗口中选中 ImageTarget，右击并在弹出的菜单中选择 3D Object &gt; Cube，识别图片上将显示一个立方体模型。这个模型就是在识别图片上叠加的 AR 内容，您可以适当调整模型的大小以便查看。上述操作完成后，需要在 Unity 环境下运行以查看效果。在运行之前，请确保您的电脑已安装了摄像头。点击运行按钮，摄像头将启动并采集画面；将摄像头对准”苹果“图片，识别成功后将在图片上叠加显示一个立方体模型。</p>
<p>​</p>
</li>
</ul>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>AR</tag>
      </tags>
  </entry>
  <entry>
    <title>【动态规划-递推】HDU 1143 Tri Tiling</title>
    <url>/posts/52367.html</url>
    <content><![CDATA[<blockquote>
<p>In how many ways can you tile a 3xn rectangle with 2x1 dominoes? Here is a sample tiling of a 3x12 rectangle.</p>
<p> <img src="https://photo.hushhw.cn/images/1143-1.jpg" alt></p>
<a id="more"></a>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1143" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1143</a></p>
<p>Input consists of several test cases followed by a line containing -1. Each test case is a line containing an integer 0 ≤ n ≤ 30. </p>
<p>For each test case, output one integer number giving the number of possible tilings. </p>
</blockquote>
<p>​          </p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>递推真的是头疼。</p>
<p>​    首先应该是可以很轻松的知道两点和不太容易知道一点。</p>
<p>​        其一是奇数列的结果都为0，因为奇数列是填不满的。</p>
<p>​        其二是dp[2]=3，2X3时可以有3种情况。</p>
<p>​        其三，不太容易找到的规律，除了2有三种外，之后的偶数列不进行拆分都只有2种。</p>
<p>​    </p>
<p>​        面对4X3的情况，首先可以分割成两个2X3，即dp[2]*dp[2]=9，其次4X3整体考虑有两种情况，所以dp[4]=9+2=11。</p>
<p>​        面对6X3的情况，首先可以分割成三个2X3，即dp[2]^3 = 27,其次可以分割成一个4X3加一个2X3(可以交换位置，所以有两种），得2<em>3</em>2=12，最后对6X3整体考虑有两种，所以dp[6]=27+12+2=41</p>
<p>​    推到这里，我们大致找到规律了，但是没有递推转化式，但是只要我们稍微转换一下思维就可以得到下面的正确解法了。</p>
<p>​        用递推的思想来解决的话，可以这样考虑问题。</p>
<p>​        设dp[n]表示nX3的方块，那么分以下几步考虑：</p>
<p>​        1.  整体不进行划分（指的是不考虑子问题），前面提到了第三点，共2 种情况，这里我们换一个角度相就是将前n列方块和最后0列方块划分考虑，即2*dp[0]；</p>
<p>​        2.  将最后面两列和前面的n-2列分开考虑，此时就是一个子问题：dp[2]<em>dp[n-2] = 3</em>dp[n-2]；</p>
<p>​        3.  继续将最后面的四列和前面的n-4分开考虑，此时就是子问题：dp[4]<em>dp[n-4] = 2</em>dp[n-4];</p>
<p>​        4.  继续将最后面的六列和前面的n-6分开考虑，此时就是子问题：dp[6]<em>dp[n-6] = 2</em>dp[n-6];</p>
<p>​            ……</p>
<p>​        若干次划分后，我们得到dp[n] = 3<em>dp[n-2] + 2</em>(dp[n-4]+dp[n-6]+……+dp[0]);</p>
<p>​        而进行一下简单的推导可得，dp[n-2] = 3<em>dp[n-4] + 2</em>(dp[n-6]+……+dp[0]);</p>
<p>​        将两式相减就可以得到 dp[n] = 4*dp[n-2] - dp[n-4]；</p>
<p>​        其中dp[0]=1;是一个比较容易弄错的点</p>
<h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;  </span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">31</span>+<span class="number">10</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> dp[maxn],n;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;  </span><br><span class="line">    dp[<span class="number">2</span>]=<span class="number">3</span>;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">4</span>;i&lt;=<span class="number">32</span>;i++)  </span><br><span class="line">        dp[i]=<span class="number">4</span>*dp[i<span class="number">-2</span>]-dp[i<span class="number">-4</span>];  </span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)&amp;&amp;n!=<span class="number">-1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>)  <span class="built_in">printf</span>(<span class="string">"0\n"</span>);  </span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[n]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>OJ刷题</category>
      </categories>
      <tags>
        <tag>OJ</tag>
        <tag>hdu</tag>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown中Latex数学公式基本语法</title>
    <url>/posts/10c8125f.html</url>
    <content><![CDATA[<blockquote>
<p>因为不经常要用到Latex数学公式，</p>
<p>每次要用到的时候语法都忘记了，</p>
<p>所以特别自己做了一次整理。</p>
</blockquote>
<a id="more"></a>
<h3 id="1-公式排版"><a href="#1-公式排版" class="headerlink" title="1. 公式排版"></a>1. 公式排版</h3><p>分为两种排版： </p>
<ul>
<li><p>行内公式：用\或者$包裹公式</p>
</li>
<li><p>独立公式：用$$包裹公式</p>
<p>例如:<br><code>\sum_{i=0}^{n}i^2</code> 用不同符号包裹的行内和独立：     $  \sum_{i=0}^{n}i^2 $</p>
<script type="math/tex; mode=display">
\sum_{i=0}^{n}i^2</script><p><code>&quot;\boxed&quot;</code>命令给公式加一个方框<br><code>E = mc^2</code> ：</p>
<script type="math/tex; mode=display">
E = mc^2</script></li>
</ul>
<p><code>\boxed{E=mc^2}</code> ：</p>
<script type="math/tex; mode=display">
\boxed{E=mc^2}</script><h3 id="2-常用总结"><a href="#2-常用总结" class="headerlink" title="2. 常用总结"></a>2. 常用总结</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">符号</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">上标</td>
<td style="text-align:center"><code>^</code></td>
</tr>
<tr>
<td style="text-align:center">下标</td>
<td style="text-align:center"><code>_</code></td>
</tr>
<tr>
<td style="text-align:center">空格</td>
<td style="text-align:center"><code>\quad</code></td>
</tr>
<tr>
<td style="text-align:center">双空格</td>
<td style="text-align:center"><code>\qquad</code></td>
</tr>
<tr>
<td style="text-align:center">大空格</td>
<td style="text-align:center"><code>\</code></td>
</tr>
<tr>
<td style="text-align:center">中空格</td>
<td style="text-align:center"><code>\:</code></td>
</tr>
<tr>
<td style="text-align:center">小空格</td>
<td style="text-align:center"><code>\,</code></td>
</tr>
<tr>
<td style="text-align:center">紧贴</td>
<td style="text-align:center"><code>\!</code></td>
</tr>
<tr>
<td style="text-align:center">根号</td>
<td style="text-align:center"><code>\sqrt[2]{x}</code></td>
</tr>
<tr>
<td style="text-align:center">分数</td>
<td style="text-align:center"><code>\frac{1}{2}</code></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><code>\dfrac</code> 字号为独立公式大小</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><code>\tfrac</code> 字号为行间公式大小</td>
</tr>
</tbody>
</table>
</div>
<h3 id="3-运算符"><a href="#3-运算符" class="headerlink" title="3. 运算符"></a>3. 运算符</h3><p>+ - * / = 直接输入，特殊运算则用以下特殊命令 </p>
<p><code>\pm\</code>=&gt; $ \pm\ $</p>
<p><code>\times\</code>=&gt; $ \times\ ​$</p>
<p><code>\div\</code>=&gt; $ \div\ ​$</p>
<p><code>\cdot\</code>=&gt; $ \cdot\ $</p>
<p><code>\cap\</code>=&gt; $ \cap\ $</p>
<p><code>\cup\</code>=&gt; $ \cup\ $</p>
<p><code>\geq\</code>=&gt; $ \geq\ $</p>
<p><code>\leq\</code>=&gt; $ \leq\ $</p>
<p><code>\neq\</code>=&gt; $ \neq\ $</p>
<p><code>\approx\</code>=&gt; $ \approx\ $</p>
<p><code>\equiv\</code>=&gt; $ \equiv\ $</p>
<p>和、积、极限、积分等运算符在行内公式被压缩以适应行高，可以通过 <code>\limits</code> 和 <code>\nolimits</code> 命令显示制动是否压缩。 </p>
<p><code>\sum\</code>=&gt; $ \sum\ ​$</p>
<p><code>\prod\</code>=&gt; $ \prod\ ​$</p>
<p><code>\lim\</code>=&gt; $ \lim\ ​$</p>
<p><code>\int\</code>=&gt; $ \int\ $</p>
<script type="math/tex; mode=display">
\sum\ \prod\ \lim\ \int\</script><p>​    </p>
<h3 id="4-箭头"><a href="#4-箭头" class="headerlink" title="4. 箭头"></a>4. 箭头</h3><p><code>\leftarrow</code> =&gt; $ \leftarrow $　　　　 　         <code>\rightarrow</code> 表示$ \rightarrow $</p>
<p><code>\leftrightarrow</code>表示　$ \leftrightarrow $　　　     <code>\Leftarrow</code>表示$\Leftarrow$</p>
<p><code>\Rightarrow</code> 表示$\Rightarrow$                    <code>\Leftrightarrow</code>表示$ \Leftrightarrow$</p>
<p><code>\longleftarrow</code>表示 $ \longleftarrow $             <code>\longleftarrow</code>表示$ \longleftarrow $</p>
<p><code>\longleftrightarrow</code>表示$ \longleftrightarrow $         <code>\Longleftarrow</code>表示$ \Longleftarrow $</p>
<p><code>\Longrightarrow</code>表示$\Longrightarrow$             <code>\Longleftrightarrow</code>表示$\Longleftrightarrow$</p>
<p><code>\xleftarrow和\xrightarrow</code>可根据内容自动调整</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\xleftarrow&#123;x+y+z&#125; \quad \xrightarrow[x&lt;y]&#123;x+y+z&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下:</p>
<script type="math/tex; mode=display">
 \xleftarrow{x+y+z} \quad \xrightarrow[x<y]{x+y+z}</script><h3 id="5-省略号"><a href="#5-省略号" class="headerlink" title="5. 省略号"></a>5. 省略号</h3><p>省略号用 <code>\dots \cdots \vdots \ddots</code>表示 ，<code>\dots</code> 和 <code>\cdots</code>的纵向位置不同，前者一般用于有下标的序列</p>
<p><code>x_1, x_2, \dots, x_n\quad 1,2,\cdots,n\quad \vdots\quad \ddots</code></p>
<p>结果如下：</p>
<script type="math/tex; mode=display">
x_1, x_2, \dots, x_n\quad 1,2,\cdots,n\quad \vdots\quad \ddots</script><h3 id="6-多行公式"><a href="#6-多行公式" class="headerlink" title="6. 多行公式"></a>6. 多行公式</h3><h4 id="6-1-长公式"><a href="#6-1-长公式" class="headerlink" title="6.1.  长公式"></a>6.1.  长公式</h4><p>无需对齐可使用<code>multline</code>，需要对齐使用<code>split</code>，用<code>\\和&amp;</code>来分行和设置对齐的位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;multline&#125;</span><br><span class="line">	x = a+b+c+ \\</span><br><span class="line">   		 d+e+f+g</span><br><span class="line">  \end&#123;multline&#125;</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
\begin{multline}
    x = a+b+c+ \\
            d+e+f+g
  \end{multline}</script><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;split&#125;</span><br><span class="line">x = &#123;&#125; &amp; a + b + c +&#123;&#125;\\</span><br><span class="line">	&amp;d + e + f + g</span><br><span class="line">\end&#123;split&#125;</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
\begin{split}
x = {} & a + b + c +{}\\
    &d + e + f + g
\end{split}</script><h4 id="6-2-公式组"><a href="#6-2-公式组" class="headerlink" title="6.2. 公式组"></a>6.2. 公式组</h4><p>不需要对齐的公式组用<code>gather</code>，需要对齐使用<code>align</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;gather&#125;</span><br><span class="line">a = b+c+d\\</span><br><span class="line">x=y+z</span><br><span class="line">\end&#123;gather&#125;</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
\begin{gather}
a = b+c+d\\
x=y+z
\end{gather}</script><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;align&#125;</span><br><span class="line">a &amp;=b+c+d \\</span><br><span class="line">x &amp;=y+z</span><br><span class="line">\end&#123;align&#125;</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
\begin{align}
a &=b+c+d \\
x &=y+z
\end{align}</script><h4 id="6-3-分支公式"><a href="#6-3-分支公式" class="headerlink" title="6.3. 分支公式"></a>6.3. 分支公式</h4><p>分段函数通常用cases</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">y=\begin&#123;cases&#125;</span><br><span class="line">-x,\quad x\leq 0\\</span><br><span class="line">x, \quad x&gt;0</span><br><span class="line">\end&#123;cases&#125;</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
y=\begin{cases}
-x,\quad x\leq 0\\
x, \quad x>0
\end{cases}</script><p>​          </p>
<h3 id="7-常用希腊字母"><a href="#7-常用希腊字母" class="headerlink" title="7. 常用希腊字母"></a>7. 常用希腊字母</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">小写命令</th>
<th style="text-align:center">小写显示</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">\alpha</td>
<td style="text-align:center">α</td>
</tr>
<tr>
<td style="text-align:center">\beta</td>
<td style="text-align:center">β</td>
</tr>
<tr>
<td style="text-align:center">\gamma</td>
<td style="text-align:center">γ</td>
</tr>
<tr>
<td style="text-align:center">\theta</td>
<td style="text-align:center">θ</td>
</tr>
<tr>
<td style="text-align:center">\delta</td>
<td style="text-align:center">δ</td>
</tr>
<tr>
<td style="text-align:center">\epsilon</td>
<td style="text-align:center">ϵ</td>
</tr>
<tr>
<td style="text-align:center">\zeta</td>
<td style="text-align:center">ζ</td>
</tr>
<tr>
<td style="text-align:center">\eta</td>
<td style="text-align:center">η</td>
</tr>
<tr>
<td style="text-align:center">\iota</td>
<td style="text-align:center">ι</td>
</tr>
<tr>
<td style="text-align:center">\kappa</td>
<td style="text-align:center">κ</td>
</tr>
<tr>
<td style="text-align:center">\lambda</td>
<td style="text-align:center">λ</td>
</tr>
<tr>
<td style="text-align:center">\mu</td>
<td style="text-align:center">μ</td>
</tr>
<tr>
<td style="text-align:center">\nu</td>
<td style="text-align:center">ν</td>
</tr>
<tr>
<td style="text-align:center">\pi</td>
<td style="text-align:center">π</td>
</tr>
<tr>
<td style="text-align:center">\rho</td>
<td style="text-align:center">ρ</td>
</tr>
<tr>
<td style="text-align:center">\sigma</td>
<td style="text-align:center">σ</td>
</tr>
<tr>
<td style="text-align:center">\tau</td>
<td style="text-align:center">τ</td>
</tr>
<tr>
<td style="text-align:center">\phi</td>
<td style="text-align:center">ϕ</td>
</tr>
<tr>
<td style="text-align:center">\omega</td>
<td style="text-align:center">ω</td>
</tr>
</tbody>
</table>
</div>
<p><strong>Tips </strong><br>如果使用大写的希腊字母，把命令的首字母变成大写即可，例如 \Gamma 输出的是 $\Gamma​$ 。 </p>
<p>如果使用斜体大写希腊字母，再在大写希腊字母的 LaTeX 命令前加上 var ，例如 <code>\varGamma</code> 生成 $\varGamma$ 。 </p>
<p>​         </p>
<h3 id="8-矩阵"><a href="#8-矩阵" class="headerlink" title="8. 矩阵"></a>8. 矩阵</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X = \left[</span><br><span class="line">	\begin&#123;matrix&#125;</span><br><span class="line">	\cdots &#123;x^&#123;(1)&#125;&#125;^T \cdots \\</span><br><span class="line">	\cdots &#123;x^&#123;(2)&#125;&#125;^T \cdots \\</span><br><span class="line">	\vdots  \\</span><br><span class="line">	\cdots &#123;x^&#123;(m)&#125;&#125;^T \cdots \\</span><br><span class="line">	\end&#123;matrix&#125;</span><br><span class="line">\right]</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<script type="math/tex; mode=display">
X = \left[
    \begin{matrix}
    \cdots {x^{(1)}}^T \cdots \\
    \cdots {x^{(2)}}^T \cdots \\
    \vdots  \\
    \cdots {x^{(m)}}^T \cdots \\
    \end{matrix}
\right]</script>]]></content>
      <categories>
        <category>建站笔记</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>卡特兰数(catalan number)</title>
    <url>/posts/2d0b2197.html</url>
    <content><![CDATA[<blockquote>
<p><strong>卡特兰数</strong> 又称卡塔兰数，卡特兰数是组合数学中一个常出现在各种计数问题中的数列。以比利时的数学家欧仁·查理·卡塔兰 (1814–1894)的名字来命名。</p>
</blockquote>
<a id="more"></a>
<p>​       </p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>令h(0)=1, h(1)=1，catalan数满足递推式：</p>
<script type="math/tex; mode=display">
h(n) = h(0)*h(n-1)+h(1)*h(n-2)+\dots+h(n-1)*h(0) (n>=2)</script><p>例如：$h(2) = h(0)<em>h(1)+h(1)</em>h(0) = 1<em>1+1</em>1 = 2$</p>
<p>​        $h(3) = h(0)<em>h(2)+h(1)</em>h(1)+h(2)<em>h(0) = 1</em>2+1<em>1+2</em>1 = 5$</p>
<p>另类推导式：</p>
<script type="math/tex; mode=display">
h(n) = \frac{h(n-1)*(4*n-2)}{n+1};</script><p>递推关系的解为：</p>
<script type="math/tex; mode=display">
h(n) = \frac{C_{2n}^n}{n+1} (n=0,1,2,\dots)</script><p>递推关系的另类解为：</p>
<script type="math/tex; mode=display">
h(n) = C_{2n}^n - C_{2n}^{n-1} (n=0,1,2,\dots)</script><p>其前几项为 : 1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670, 129644790, 477638700, 1767263190, 6564120420, 24466267020, 91482563640, 343059613650, 1289904147324, 4861946401452, …</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p><strong>括号化</strong> ：矩阵连乘： P=a1×a2×a3×……×an，依据乘法结合律，不改变其顺序，只用括号表示成对的乘积，试问有几种括号化的方案？</p>
<p><strong>出栈次序</strong> ：一个栈(无穷大)的进栈序列为1，2，3，…，n，有多少个不同的出栈序列?</p>
<p><strong>凸多边形三角划分</strong> ：在一个凸多边形中，通过若干条互不相交的对角线，把这个多边形划分成了若干个三角形。任务是键盘上输入凸多边形的边数n，求不同划分的方案数f（n）。比如当n=6时，f（6）=14。</p>
<p>更多应用见：<a href="https://blog.csdn.net/jiejinquanil/article/details/52153045" target="_blank" rel="noopener">https://blog.csdn.net/jiejinquanil/article/details/52153045</a></p>
<p>原始代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">__int64 catalan[<span class="number">40</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">catalan</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(catalan, <span class="number">0</span>, <span class="keyword">sizeof</span>(catalan));</span><br><span class="line">  catalan[<span class="number">0</span>] = catalan[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=<span class="number">35</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++)&#123;</span><br><span class="line">      catalan[i] += catalan[j]*catalan[i-j<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大数代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">catalan</span><span class="params">()</span> <span class="comment">//求卡特兰数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, len, carry, temp;</span><br><span class="line">    a[<span class="number">1</span>][<span class="number">0</span>] = b[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; len; j++) <span class="comment">//乘法</span></span><br><span class="line">        a[i][j] = a[i<span class="number">-1</span>][j]*(<span class="number">4</span>*(i<span class="number">-1</span>)+<span class="number">2</span>);</span><br><span class="line">        carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; len; j++) <span class="comment">//处理相乘结果</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp = a[i][j] + carry;</span><br><span class="line">            a[i][j] = temp % <span class="number">10</span>;</span><br><span class="line">            carry = temp / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(carry) <span class="comment">//进位处理</span></span><br><span class="line">        &#123;</span><br><span class="line">            a[i][len++] = carry % <span class="number">10</span>;</span><br><span class="line">            carry /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = len<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--) <span class="comment">//除法</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp = carry*<span class="number">10</span> + a[i][j];</span><br><span class="line">            a[i][j] = temp/(i+<span class="number">1</span>);</span><br><span class="line">            carry = temp%(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!a[i][len<span class="number">-1</span>]) <span class="comment">//高位零处理</span></span><br><span class="line">        len --;</span><br><span class="line">        b[i] = len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><blockquote>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2067" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=2067</a></p>
<p>小兔的棋盘</p>
<p>Time Limit: 1000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)</p>
<p>Total Submission(s): 12397    Accepted Submission(s): 6201</p>
<p>Problem Description</p>
<p>小兔的叔叔从外面旅游回来给她带来了一个礼物，小兔高兴地跑回自己的房间，拆开一看是一个棋盘，小兔有所失望。</p>
<p>不过没过几天发现了棋盘的好玩之处。</p>
<p>从起点(0，0)走到终点(n,n)的最短路径数是C(2n,n),现在小兔又想如果不穿越对角线(但可接触对角线上的格点)，这样的路径数有多少?</p>
<p>小兔想了很长时间都没想出来，现在想请你帮助小兔解决这个问题，对于你来说应该不难吧!</p>
<p>Input</p>
<p>每次输入一个数n(1&lt;=n&lt;=35)，当n等于－1时结束输入。</p>
<p>Output</p>
<p>对于每个输入数据输出路径数，具体格式看Sample。</p>
<p>Sample Input</p>
<p>1</p>
<p>3</p>
<p>12</p>
<p>-1</p>
<p>Sample Output</p>
<p>1 1 2</p>
<p>2 3 10</p>
<p>3 12 416024</p>
<p>Author</p>
<p>Rabbit</p>
<p>Source</p>
<p>RPG专场练习赛</p>
<p>Recommend</p>
<p>lcy   |   We have carefully selected several similar problems for you:  1133 2068 1267 2069 1134 </p>
<p>/*</p>
<p>题目分析：为什么这个题要用卡特兰数呢？因为它的过程可以抽象成前例的样子，</p>
<p>​         比如说先往下走，在往下走了一步的情况下，就可以往右走一步，这样向下走就等同于进栈，向右走就等同于出栈，有了卡特兰数的知识，这题就相当水了。（别忘了最后要乘2啊，因为只要满足不穿过对角线的话，先往下和先往右都可以的）</p>
<p>输出: 第一个数字是数据的组数，第二个数是输入的数，第三个则是路径数。</p>
<p>*/</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll catalan[<span class="number">40</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">catalans</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(catalan, <span class="number">0</span>, <span class="keyword">sizeof</span>(catalan));</span><br><span class="line">    catalan[<span class="number">0</span>] = catalan[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">35</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;i; j++)&#123;</span><br><span class="line">            catalan[i] += catalan[j] * catalan[i - j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    catalans();</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF &amp;&amp; n!=<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d %lld\n"</span>, t++, n, catalan[n] * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程开发</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>算法笔记</tag>
        <tag>卡特兰数</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 2056 一个人的旅行（最短路径）</title>
    <url>/posts/90250c4.html</url>
    <content><![CDATA[<blockquote>
<p>一个人的旅行</p>
<p>Problem Description</p>
<p>虽然草儿是个路痴（就是在杭电待了一年多，居然还会在校园里迷路的人，汗~),但是草儿仍然很喜欢旅行，</p>
<p>因为在旅途中 会遇见很多人（白马王子，^0^），很多事，还能丰富自己的阅历，还可以看美丽的风景……草儿想去很多地方，</p>
<p>她想要去东京铁塔看夜景，去威尼斯看电影，去阳明山上看海芋，去纽约纯粹看雪景，去巴黎喝咖啡写信，去北京探望孟姜女……</p>
<a id="more"></a>
<p>​           </p>
<p>眼看寒么一大段时间，可不能浪费啊，假就快到了，这一定要给自己好好的放个假，可是也不能荒废了训练啊，</p>
<p>所以草儿决定在要在最短的时间去一个自己想去的地方！</p>
<p>因为草儿的家在一个小镇上，没有火车经过，所以她只能去邻近的城市坐火车（好可怜啊~）。</p>
<p> <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2066" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=2066</a></p>
<p>Input</p>
<p>输入数据有多组，每组的第一行是三个整数T，S和D，表示有T条路，和草儿家相邻的城市的有S个，草儿想去的地方有D个；</p>
<p>接着有T行，每行有三个整数a，b，time,表示a,b城市之间的车程是time小时；(1=&lt;(a,b)&lt;=1000;a,b 之间可能有多条路)</p>
<p>接着的第T+1行有S个数，表示和草儿家相连的城市；</p>
<p>接着的第T+2行有D个数，表示草儿想去地方。</p>
<p>Output</p>
<p>输出草儿能去某个喜欢的城市的最短时间。</p>
<p>Sample Input</p>
<p>6 2 3</p>
<p>1 3 5</p>
<p>1 4 7</p>
<p>2 8 12</p>
<p>3 8 4</p>
<p>4 9 12</p>
<p>9 10 2</p>
<p>1 2</p>
<p>8 9 10</p>
<p>Sample Output</p>
<p>9</p>
<p>Author</p>
<p>Grass</p>
<p>Source</p>
<p>RPG专场练习赛</p>
<p>Recommend</p>
<p>lcy   |   We have carefully selected several similar problems for you:  2544 1874 2112 1217 1548 </p>
<p>/*</p>
<p>思路：</p>
<p>​    题目考察最短路径问题，但是题目中有一些小变化。</p>
<p>​    建表的时候，注意和她的家相邻的点要设为0，然后题目就变成了从0站点到终点的几个点最短距离问题</p>
<p>*/</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dijkstra</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> start[<span class="number">1001</span>], direction[<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(dis, INF, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    dis[x] = <span class="number">0</span>;</span><br><span class="line">    vis[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;=n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[j] &amp;&amp; dis[j] &gt; <span class="built_in">map</span>[x][j] + dis[x])</span><br><span class="line">                dis[j] = <span class="built_in">map</span>[x][j] + dis[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> minn = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;=n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[j] &amp;&amp; dis[j]&lt;minn)&#123;</span><br><span class="line">                minn = dis[j];</span><br><span class="line">                x = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[x] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct node&#123;</span></span><br><span class="line"><span class="comment">    int id;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    friend bool operator &lt;(node a, node b)&#123;</span></span><br><span class="line"><span class="comment">        return a.val &gt; b.val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125; pre, nt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">void dijkstra(int x)&#123;</span></span><br><span class="line"><span class="comment">    memset(vis, 0, sizeof(vis));</span></span><br><span class="line"><span class="comment">    memset(dis, INF, sizeof(dis));</span></span><br><span class="line"><span class="comment">    dis[x] = 0; //初始化dis[0]=0,其它都还是INF</span></span><br><span class="line"><span class="comment">    priority_queue&lt;node&gt; q; //优先队列q，初始存储x点的信息</span></span><br><span class="line"><span class="comment">    pre.id = x; </span></span><br><span class="line"><span class="comment">    pre.val = 0;</span></span><br><span class="line"><span class="comment">    q.push(pre);</span></span><br><span class="line"><span class="comment">    while(!q.empty())&#123;</span></span><br><span class="line"><span class="comment">        pre = q.top();</span></span><br><span class="line"><span class="comment">        q.pop();</span></span><br><span class="line"><span class="comment">        int id = pre.id, val = pre.val;</span></span><br><span class="line"><span class="comment">        vis[id] = 1;</span></span><br><span class="line"><span class="comment">        for (int i = 1; i &lt;= n; i++)&#123; //遍历每一个城市</span></span><br><span class="line"><span class="comment">            if(!vis[i] &amp;&amp; dis[i]&gt;map[id][i] + val)&#123; //如果该城市未被遍历过，并且dis[i]&gt;map[id][i]+val,更新</span></span><br><span class="line"><span class="comment">                dis[i] = map[id][i] + val;</span></span><br><span class="line"><span class="comment">                nt.id = i;</span></span><br><span class="line"><span class="comment">                nt.val = val + map[id][i]; //这里存储的是到初始点的距离</span></span><br><span class="line"><span class="comment">                q.push(nt);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T, S, D;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;T,&amp;S,&amp;D)!=EOF)&#123;</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1001</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">1001</span>; j++)&#123; <span class="comment">//首先建表</span></span><br><span class="line">                <span class="keyword">if</span>(i==j)</span><br><span class="line">                    <span class="built_in">map</span>[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">map</span>[i][j] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a, b, time;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; i++)&#123; <span class="comment">//相连的城市，更新它们的距离</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;time);</span><br><span class="line">            n = max(max(a, b), n); <span class="comment">//最大的城市</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[a][b]&gt;time)</span><br><span class="line">                <span class="built_in">map</span>[a][b] = <span class="built_in">map</span>[b][a] = time;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;S; i++)&#123; <span class="comment">//起始城市更新它们的map距离与0为0</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;start[i]);</span><br><span class="line">            <span class="built_in">map</span>[<span class="number">0</span>][start[i]] = <span class="built_in">map</span>[start[i]][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;D; i++)&#123; <span class="comment">//终点城市</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;direction[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        dijkstra(<span class="number">0</span>); <span class="comment">//起点从0开始</span></span><br><span class="line">        <span class="keyword">int</span> mi = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; D; i++)&#123;</span><br><span class="line">            mi = min(dis[direction[i]], mi);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, mi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//floyd</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> start[<span class="number">1001</span>], direction[<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T, S, D;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;T,&amp;S,&amp;D)!=EOF)&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1001</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">1001</span>; j++)&#123; <span class="comment">//首先建表</span></span><br><span class="line">                <span class="keyword">if</span>(i==j) <span class="built_in">map</span>[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">map</span>[i][j] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a, b, time;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; i++)&#123; <span class="comment">//相连的城市，更新它们的距离</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;time);</span><br><span class="line">            n = max(max(a, b), n); <span class="comment">//最大的城市</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[a][b]&gt;time)</span><br><span class="line">                <span class="built_in">map</span>[a][b] = <span class="built_in">map</span>[b][a] = time;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(start, <span class="number">0</span>, <span class="keyword">sizeof</span>(start));</span><br><span class="line">        <span class="built_in">memset</span>(direction, <span class="number">0</span>, <span class="keyword">sizeof</span>(direction));</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;S; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;temp);</span><br><span class="line">            start[temp] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;D; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;temp);</span><br><span class="line">            direction[temp] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mi = INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)  &#123;  </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)  &#123;  </span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">map</span>[i][k]==INF) </span><br><span class="line">                    <span class="keyword">continue</span>;  </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)  &#123;  </span><br><span class="line">                    <span class="keyword">if</span>(i==j) </span><br><span class="line">                        <span class="keyword">continue</span>;  </span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">map</span>[i][k]+<span class="built_in">map</span>[k][j]&lt;<span class="built_in">map</span>[i][j])  </span><br><span class="line">                        <span class="built_in">map</span>[i][j]=<span class="built_in">map</span>[j][i]=<span class="built_in">map</span>[i][k]+<span class="built_in">map</span>[k][j];  </span><br><span class="line">                    <span class="keyword">if</span>(start[i] &amp;&amp; direction[j] &amp;&amp; mi&gt;<span class="built_in">map</span>[i][j])</span><br><span class="line">                        mi = <span class="built_in">map</span>[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, mi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>OJ刷题</category>
      </categories>
      <tags>
        <tag>OJ</tag>
        <tag>最短路</tag>
        <tag>hdu</tag>
      </tags>
  </entry>
  <entry>
    <title>如何理解 KMP</title>
    <url>/posts/40823.html</url>
    <content><![CDATA[<blockquote>
<p><strong>KMP算法</strong>是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt同时发现，因此人们称它为克努特——莫里斯——普拉特操作（简称KMP算法）。KMP算法的关键是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是实现一个next()函数，函数本身包含了模式串的局部匹配信息。时间复杂度O(m+n)。</p>
</blockquote>
<a id="more"></a>
<p>​       </p>
<h2 id="一：背景"><a href="#一：背景" class="headerlink" title="一：背景"></a>一：背景</h2><p>给定一个主串（以 S 代替）和模式串（以 P 代替），要求找出 P 在 S 中出现的位置，此即串的模式匹配问题。</p>
<p>Knuth-Morris-Pratt 算法（简称 KMP）是解决这一问题的常用算法之一，这个算法是由高德纳（Donald Ervin Knuth）和沃恩·普拉特在1974年构思，同年詹姆斯·H·莫里斯也独立地设计出该算法，最终三人于1977年联合发表。</p>
<p>在继续下面的内容之前，有必要在这里介绍下两个概念：<strong>真前缀</strong> 和 <strong>真后缀</strong>。</p>
<p><img src="https://photo.hushhw.cn/24kmp1.png" alt></p>
<p>由上图所得， “真前缀”指除了自身以外，一个字符串的全部头部组合；”真后缀”指除了自身以外，一个字符串的全部尾部组合。（网上很多博客，应该说是几乎所有的博客，也包括我以前写的，都是“前缀”。严格来说，“真前缀”和“前缀”是不同的，既然不同，还是不要混为一谈的好！）</p>
<h2 id="二：朴素字符串匹配算法"><a href="#二：朴素字符串匹配算法" class="headerlink" title="二：朴素字符串匹配算法"></a>二：朴素字符串匹配算法</h2><p>初遇串的模式匹配问题，我们脑海中的第一反应，就是朴素字符串匹配（即所谓的暴力匹配），代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 字符串下标始于 0 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NaiveStringSearch</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;    <span class="comment">// S 的下标</span></span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;    <span class="comment">// P 的下标</span></span><br><span class="line">	<span class="keyword">int</span> s_len = S.size();</span><br><span class="line">	<span class="keyword">int</span> p_len = P.size();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (i &lt; s_len &amp;&amp; j &lt; p_len)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (S[i] == P[j])  <span class="comment">// 若相等，都前进一步</span></span><br><span class="line">		&#123;</span><br><span class="line">			i++;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>               <span class="comment">// 不相等</span></span><br><span class="line">		&#123;</span><br><span class="line">			i = i - j + <span class="number">1</span>;</span><br><span class="line">			j = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (j == p_len)        <span class="comment">// 匹配成功</span></span><br><span class="line">		<span class="keyword">return</span> i - j;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>暴力匹配的时间复杂度为 $O(nm)$，其中 $n$ 为 S 的长度，$m$ 为 P 的长度。很明显，这样的时间复杂度很难满足我们的需求。</p>
<p>接下来进入正题：时间复杂度为 $Θ(n+m)$ 的 KMP 算法。</p>
<h2 id="三：KMP字符串匹配算法"><a href="#三：KMP字符串匹配算法" class="headerlink" title="三：KMP字符串匹配算法"></a>三：KMP字符串匹配算法</h2><h3 id="3-1-算法流程"><a href="#3-1-算法流程" class="headerlink" title="3.1 算法流程"></a>3.1 算法流程</h3><p>以下摘自阮一峰的<a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">字符串匹配的KMP算法</a>，并作稍微修改。</p>
<p>（1）</p>
<p><img src="https://photo.hushhw.cn/20180402_02.png" alt></p>
<p>首先，主串”BBC ABCDAB ABCDABCDABDE”的第一个字符与模式串”ABCDABD”的第一个字符，进行比较。因为B与A不匹配，所以模式串后移一位。</p>
<p>（2）</p>
<p><img src="https://photo.hushhw.cn/20180402_03.png" alt></p>
<p>因为B与A又不匹配，模式串再往后移。</p>
<p>（3）</p>
<p><img src="https://photo.hushhw.cn/20180402_04.png" alt></p>
<p>就这样，直到主串有一个字符，与模式串的第一个字符相同为止。</p>
<p>（4）</p>
<p><img src="https://photo.hushhw.cn/20180402_05.png" alt></p>
<p>接着比较主串和模式串的下一个字符，还是相同。</p>
<p>（5）</p>
<p><img src="https://photo.hushhw.cn/20180402_06.png" alt></p>
<p>直到主串有一个字符，与模式串对应的字符不相同为止。</p>
<p>（6）</p>
<p><img src="https://photo.hushhw.cn/20180402_07.png" alt></p>
<p>这时，最自然的反应是，将模式串整个后移一位，再从头逐个比较。这样做虽然可行，但是效率很差，因为你要把”搜索位置”移到已经比较过的位置，重比一遍。</p>
<p>（7）</p>
<p><img src="https://photo.hushhw.cn/20180402_08.png" alt></p>
<p>一个基本事实是，当空格与D不匹配时，你其实是已经知道前面六个字符是”ABCDAB”。KMP算法的想法是，设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，而是继续把它向后移，这样就提高了效率。</p>
<p>（8）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">i</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">模式串</td>
<td style="text-align:center">A</td>
<td style="text-align:center">B</td>
<td style="text-align:center">C</td>
<td style="text-align:center">D</td>
<td style="text-align:center">A</td>
<td style="text-align:center">B</td>
<td style="text-align:center">D</td>
<td style="text-align:center">‘\0’</td>
</tr>
<tr>
<td style="text-align:center">next[i]</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
</div>
<p>怎么做到这一点呢？可以针对模式串，设置一个跳转数组<code>int next[]</code>，这个数组是怎么计算出来的，后面再介绍，这里只要会用就可以了。</p>
<p>（9）</p>
<p><img src="https://photo.hushhw.cn/20180402_09.png" alt></p>
<p>已知空格与D不匹配时，前面六个字符”ABCDAB”是匹配的。根据跳转数组可知，不匹配处D的next值为2，因此接下来<strong>从模式串下标为2的位置开始匹配</strong>。</p>
<p>（10）</p>
<p><img src="https://photo.hushhw.cn/20180402_10.png" alt></p>
<p>因为空格与Ｃ不匹配，C处的next值为0，因此接下来模式串从下标为0处开始匹配。</p>
<p>（11）</p>
<p><img src="https://photo.hushhw.cn/20180402_11.png" alt></p>
<p>因为空格与A不匹配，此处next值为-1，表示模式串的第一个字符就不匹配，那么直接往后移一位。</p>
<p>（12）</p>
<p><img src="https://photo.hushhw.cn/20180402_12.png" alt></p>
<p>逐位比较，直到发现C与D不匹配。于是，下一步从下标为2的地方开始匹配。</p>
<p>（13）</p>
<p><img src="https://photo.hushhw.cn/20180402_13.png" alt></p>
<p>逐位比较，直到模式串的最后一位，发现完全匹配，于是搜索完成。</p>
<h3 id="3-2-next数组是如何求出的"><a href="#3-2-next数组是如何求出的" class="headerlink" title="3.2 next数组是如何求出的"></a>3.2 next数组是如何求出的</h3><p>next数组的求解基于“真前缀”和“真后缀”，即<code>next[i]</code>等于<code>P[0]...P[i - 1]</code>最长的相同真前后缀的长度（请暂时忽视i等于0时的情况，下面会有解释）。我们依旧以上述的表格为例，为了方便阅读，我复制在下方了。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">i</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">模式串</td>
<td style="text-align:center">A</td>
<td style="text-align:center">B</td>
<td style="text-align:center">C</td>
<td style="text-align:center">D</td>
<td style="text-align:center">A</td>
<td style="text-align:center">B</td>
<td style="text-align:center">D</td>
<td style="text-align:center">‘\0’</td>
</tr>
<tr>
<td style="text-align:center">next[ i ]</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
</div>
<p>（1）：i = 0，对于模式串的首字符，我们统一为<code>next[0] = -1</code>；<br>（2）：i = 1，前面的字符串为<code>A</code>，其最长相同真前后缀长度为0，即<code>next[1] = 0</code>；<br>（3）：i = 2，前面的字符串为<code>AB</code>，其最长相同真前后缀长度为0，即<code>next[2] = 0</code>；<br>（4）：i = 3，前面的字符串为<code>ABC</code>，其最长相同真前后缀长度为0，即<code>next[3] = 0</code>；<br>（5）：i = 4，前面的字符串为<code>ABCD</code>，其最长相同真前后缀长度为0，即<code>next[4] = 0</code>；<br>（6）：i = 5，前面的字符串为<code>ABCDA</code>，其最长相同真前后缀为<code>A</code>，即<code>next[5] = 1</code>；<br>（7）：i = 6，前面的字符串为<code>ABCDAB</code>，其最长相同真前后缀为<code>AB</code>，即<code>next[6] = 2</code>；<br>（8）：i = 7，前面的字符串为<code>ABCDABD</code>，其最长相同真前后缀长度为0，即<code>next[7] = 0</code>。</p>
<p>那么，为什么根据最长相同真前后缀的长度就可以实现在不匹配情况下的跳转呢？举个代表性的例子：假如<code>i = 6</code>时不匹配，此时我们是知道其位置前的字符串为<code>ABCDAB</code>，仔细观察这个字符串，首尾都有一个<code>AB</code>，既然在<code>i = 6</code>处的D不匹配，我们为何不直接把<code>i = 2</code>处的C拿过来继续比较呢，因为都有一个<code>AB</code>啊，而这个<code>AB</code>就是<code>ABCDAB</code>的最长相同真前后缀，其长度2正好是跳转的下标位置。</p>
<p>有的读者可能存在疑问，若在<code>i = 5</code>时匹配失败，按照我讲解的思路，此时应该把<code>i = 1</code>处的字符拿过来继续比较，但是这两个位置的字符是一样的啊，都是<code>B</code>，既然一样，拿过来比较不就是无用功了么？其实不是我讲解的有问题，也不是这个算法有问题，而是这个算法还未优化，关于这个问题在下面会详细说明，不过建议读者不要在这里纠结，跳过这个，下面你自然会恍然大悟。</p>
<p>思路如此简单，接下来就是代码实现了，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* P 为模式串，下标从 0 开始 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNext</span><span class="params">(<span class="built_in">string</span> P, <span class="keyword">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p_len = P.size();</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;   <span class="comment">// P 的下标</span></span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">-1</span>;  </span><br><span class="line">	next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (i &lt; p_len)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (j == <span class="number">-1</span> || P[i] == P[j])</span><br><span class="line">		&#123;</span><br><span class="line">			i++;</span><br><span class="line">			j++;</span><br><span class="line">			next[i] = j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			j = next[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一脸懵逼，是不是。。。上述代码就是用来求解模式串中每个位置的<code>next[]</code>值。</p>
<p>下面具体分析，我把代码分为两部分来讲：</p>
<p><strong>（1）：i和j的作用是什么？</strong></p>
<p>i和j就像是两个”指针“，一前一后，通过移动它们来找到最长的相同真前后缀。</p>
<p><strong>（2）：if…else…语句里做了什么？</strong></p>
<p><img src="https://photo.hushhw.cn/20180402_14.png" alt></p>
<p>假设i和j的位置如上图，由<code>next[i] = j</code>得，也就是对于位置i来说，<strong>区段[0, i - 1]的最长相同真前后缀分别是[0, j - 1]和[i - j, i - 1]，即这两区段内容相同</strong>。</p>
<p>按照算法流程，<code>if (P[i] == P[j])</code>，则<code>i++; j++; next[i] = j;</code>；若不等，则<code>j = next[j]</code>，见下图：</p>
<p><img src="https://photo.hushhw.cn/20180402_15.png" alt></p>
<p><code>next[j]</code>代表[0, j - 1]区段中最长相同真前后缀的长度。如图，用左侧两个椭圆来表示这个最长相同真前后缀，即这两个椭圆代表的区段内容相同；同理，右侧也有相同的两个椭圆。所以else语句就是利用第一个椭圆和第四个椭圆内容相同来加快得到[0, i - 1]区段的相同真前后缀的长度。</p>
<p>细心的朋友会问if语句中<code>j == -1</code>存在的意义是何？第一，程序刚运行时，j是被初始为-1，直接进行<code>P[i] == P[j]</code>判断无疑会边界溢出；第二，else语句中<code>j = next[j]</code>，j是不断后退的，若j在后退中被赋值为-1（也就是<code>j = next[0]</code>），在<code>P[i] == P[j]</code>判断也会边界溢出。综上两点，其意义就是为了特殊边界判断。</p>
<h2 id="四：完整代码"><a href="#四：完整代码" class="headerlink" title="四：完整代码"></a>四：完整代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* P 为模式串，下标从 0 开始 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNext</span><span class="params">(<span class="built_in">string</span> P, <span class="keyword">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p_len = P.size();</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;   <span class="comment">// P 的下标</span></span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">-1</span>;  </span><br><span class="line">	next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (i &lt; p_len)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (j == <span class="number">-1</span> || P[i] == P[j])</span><br><span class="line">		&#123;</span><br><span class="line">			i++;</span><br><span class="line">			j++;</span><br><span class="line">			next[i] = j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			j = next[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在 S 中找到 P 第一次出现的位置 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> P, <span class="keyword">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GetNext(P, next);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;  <span class="comment">// S 的下标</span></span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;  <span class="comment">// P 的下标</span></span><br><span class="line">	<span class="keyword">int</span> s_len = S.size();</span><br><span class="line">	<span class="keyword">int</span> p_len = P.size();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (i &lt; s_len &amp;&amp; j &lt; p_len)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (j == <span class="number">-1</span> || S[i] == P[j])  <span class="comment">// P 的第一个字符不匹配或 S[i] == P[j]</span></span><br><span class="line">		&#123;</span><br><span class="line">			i++;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			j = next[j];  <span class="comment">// 当前字符匹配失败，进行跳转</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (j == p_len)  <span class="comment">// 匹配成功</span></span><br><span class="line">		<span class="keyword">return</span> i - j;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> next[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; KMP(<span class="string">"bbc abcdab abcdabcdabde"</span>, <span class="string">"abcdabd"</span>, next) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 15</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五：算法复杂度分析"><a href="#五：算法复杂度分析" class="headerlink" title="五：算法复杂度分析"></a>五：算法复杂度分析</h2><p>在<code>GetNext()</code>和<code>KMP()</code>中，我们观察<code>i</code> 的移动，一直往前不回溯，所以它们所耗的时间都是线性的，两者相加为$Θ(m+n)$。</p>
<p>KMP算法的时间复杂度还是很稳定的。</p>
<ul>
<li>平均时间复杂度为$Θ(m+n)$。</li>
<li>最好时间复杂度为$O(m+(n-m))=O(n)$。它发生在主串和模式串字符都不相同的情况下，例如，主串为<code>abcdefghijk</code>，模式串为<code>+-*/</code>。</li>
<li>最差时间复杂度为$O(m+n)$。它发生在主串和模式串都为相同的字符的情况下，例如，主串为<code>aaaaaaaaaaaaaaaaaaaaa</code>，模式串为<code>aaaa</code>。</li>
</ul>
<h2 id="六：KMP优化"><a href="#六：KMP优化" class="headerlink" title="六：KMP优化"></a>六：KMP优化</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">i</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">模式串</td>
<td style="text-align:center">A</td>
<td style="text-align:center">B</td>
<td style="text-align:center">C</td>
<td style="text-align:center">D</td>
<td style="text-align:center">A</td>
<td style="text-align:center">B</td>
<td style="text-align:center">D</td>
<td style="text-align:center">‘\0’</td>
</tr>
<tr>
<td style="text-align:center">next[ i ]</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
</div>
<p>以3.2的表格为例（已复制在上方），若在<code>i = 5</code>时匹配失败，按照3.2的代码，此时应该把<code>i = 1</code>处的字符拿过来继续比较，但是这两个位置的字符是一样的，都是<code>B</code>，既然一样，拿过来比较不就是无用功了么？这我在3.2已经解释过，之所以会这样是因为KMP不够完美。那怎么改写代码就可以解决这个问题呢？很简单。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* P 为模式串，下标从 0 开始 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNextval</span><span class="params">(<span class="built_in">string</span> P, <span class="keyword">int</span> nextval[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p_len = P.size();</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;   <span class="comment">// P 的下标</span></span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">-1</span>;  </span><br><span class="line">	nextval[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (i &lt; p_len)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (j == <span class="number">-1</span> || P[i] == P[j])</span><br><span class="line">		&#123;</span><br><span class="line">			i++;</span><br><span class="line">			j++;</span><br><span class="line">          </span><br><span class="line">			<span class="keyword">if</span> (P[i] != P[j])</span><br><span class="line">			    nextval[i] = j;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			    nextval[i] = nextval[j];  <span class="comment">// 既然相同就继续往前找真前缀</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			j = nextval[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在此也给各位读者提个醒，KMP算法严格来说分为KMP算法（未优化版）和KMP算法（优化版），所以建议读者在表述KMP算法时，最好告知你的版本，因为两者在某些情况下区别很大，这里简单说下。</p>
<p><strong>KMP算法（未优化版）：</strong> next数组表示最长的相同真前后缀的长度，我们不仅可以利用next来解决模式串的匹配问题，也可以用来解决类似字符串重复问题等等，这类问题大家可以在各大OJ找到，这里不作过多表述。</p>
<p><strong>KMP算法（优化版）：</strong> 根据代码很容易知道（名称也改为了nextval），优化后的next仅仅表示相同真前后缀的长度，但<strong>不一定是最长</strong>（我个人称之为“最优相同真前后缀”）。此时我们利用优化后的next可以在模式串匹配问题中以更快的速度得到我们的答案（相较于未优化版），但是上述所说的字符串重复问题，优化版本则束手无策。</p>
<p>所以，该采用哪个版本，取决于你在现实中遇到的实际问题。</p>
<h2 id="七：参考文献"><a href="#七：参考文献" class="headerlink" title="七：参考文献"></a>七：参考文献</h2><ul>
<li>严蔚敏. 数据结构（C语言版）</li>
<li>阮一峰. <a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">字符串匹配的KMP算法</a></li>
</ul>
<blockquote>
<p>本文转载自：<a href="https://subetter.com/articles/2018/04/how-to-understand-kmp.html" target="_blank" rel="noopener">https://subetter.com/articles/2018/04/how-to-understand-kmp.html</a></p>
<p>作者：刘毅</p>
</blockquote>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>算法笔记</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>匈牙利算法（二分图）</title>
    <url>/posts/d0f1bbc6.html</url>
    <content><![CDATA[<blockquote>
<p>匈牙利算法是由匈牙利数学家Edmonds于1965年提出，因而得名。匈牙利算法是基于Hall定理中充分性证明的思想，它是部图匹配最常见的算法，该算法的核心就是寻找增广路径，它是一种用增广路径求二分图最大匹配的算法。</p>
</blockquote>
<a id="more"></a>
<p>​      </p>
<p><strong>二分图</strong> ：是图论中的一种特殊模型。若能将无向图G=(V,E)的顶点V划分为两个交集为空的顶点集，并且任意边的两个端点都分别属于两个集合，则称图G为一个二分图。</p>
<p><img src="https://photo.hushhw.cn/892758-20160610155729418-59307900.png" alt="img"></p>
<p><strong>匹配</strong>：在图论中，一个「匹配」（matching）是一个边的集合，其中任意两条边都没有公共顶点。例如，图 3、图 4 中红色的边就是图 2 的匹配。</p>
<p><img src="https://photo.hushhw.cn/images/7cc829d3gw1f89lnvfc6pj20g8057wfd.jpg" alt="img"></p>
<p>我们定义<strong>匹配点</strong>、<strong>匹配边</strong>、<strong>未匹配点</strong>、<strong>非匹配边</strong>，它们的含义非常显然。例如图 3 中 1、4、5、7 为匹配点，其他顶点为未匹配点；1-5、4-7为匹配边，其他边为非匹配边。</p>
<p><strong>最大匹配</strong>：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。图 4 是一个最大匹配，它包含 4 条匹配边。</p>
<p><strong>完美匹配</strong>：如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。图 4 是一个完美匹配。显然，完美匹配一定是最大匹配（完美匹配的任何一个点都已经匹配，添加一条新的匹配边一定会与已有的匹配边冲突）。但并非每个图都存在完美匹配。</p>
<p>基本概念讲完了。求解最大匹配问题的一个算法是<strong>匈牙利算法</strong>，下面讲的概念都为这个算法服务。</p>
<p><img src="https://photo.hushhw.cn/images/7cc829d3gw1f89lnzbetkj204j04u74f.jpg" alt="img"></p>
<p><strong>交替路</strong>：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边…形成的路径叫交替路。</p>
<p><strong>增广路</strong>：从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替路称为增广路（agumenting path）。例如，图 5 中的一条增广路如图 6 所示（图中的匹配点均用红色标出）：</p>
<p><img src="https://photo.hushhw.cn/images/7cc829d3gw1f89lo04o2wj207y01y3yi.jpg" alt="img"></p>
<p>增广路有一个重要特点：非匹配边比匹配边多一条。因此，研究增广路的意义是<strong>改进匹配</strong>。只要把增广路中的匹配边和非匹配边的身份交换即可。由于中间的匹配节点不存在其他相连的匹配边，所以这样做不会破坏匹配的性质。交换后，图中的匹配边数目比原来多了 1 条。</p>
<p>我们可以通过不停地找增广路来增加匹配中的匹配边和匹配点。找不到增广路时，达到最大匹配（这是增广路定理）。匈牙利算法正是这么做的。</p>
<p>一个比较有趣且易懂的过程可以参考这篇博文：<a href="https://blog.csdn.net/dark_scope/article/details/8880547" target="_blank" rel="noopener">https://blog.csdn.net/dark_scope/article/details/8880547</a></p>
<blockquote>
<p>过山车</p>
<p>Time Limit: 1000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)</p>
<p>Total Submission(s): 27673    Accepted Submission(s): 11954</p>
<p>Problem Description</p>
<p>RPG girls今天和大家一起去游乐场玩，终于可以坐上梦寐以求的过山车了。</p>
<p>可是，过山车的每一排只有两个座位，而且还有条不成文的规矩，就是每个女生必须找个个男生做partner和她同坐。</p>
<p>但是，每个女孩都有各自的想法，举个例子把，Rabbit只愿意和XHD或PQK做partner，Grass只愿意和linle或LL做partner，</p>
<p>PrincessSnow愿意和水域浪子或伪酷儿做partner。</p>
<p>考虑到经费问题，boss刘决定只让找到partner的人去坐过山车，其他的人，嘿嘿，就站在下面看着吧。</p>
<p>聪明的Acmer，你可以帮忙算算最多有多少对组合可以坐上过山车吗？</p>
<p>Input</p>
<p>输入数据的第一行是三个整数K , M , N，分别表示可能的组合数目，女生的人数，男生的人数。0&lt;K&lt;=1000</p>
<p>1&lt;=N 和M&lt;=500.接下来的K行，每行有两个数，分别表示女生Ai愿意和男生Bj做partner。最后一个0结束输入。</p>
<p>Output</p>
<p>对于每组数据，输出一个整数，表示可以坐上过山车的最多组合数。</p>
<p>Sample Input</p>
<p>6 3 3</p>
<p>1 1</p>
<p>1 2</p>
<p>1 3</p>
<p>2 1</p>
<p>2 3</p>
<p>3 1</p>
<p>0</p>
<p>Sample Output</p>
<p>3</p>
<p>Author</p>
<p>PrincessSnow</p>
<p>Source</p>
<p>RPG专场练习赛</p>
<p>Recommend</p>
<p>lcy   |   We have carefully selected several similar problems for you:  1068 1083 2444 1281 1150 </p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> line[<span class="number">510</span>][<span class="number">510</span>]; <span class="comment">//记录i和j有关系</span></span><br><span class="line"><span class="keyword">int</span> boy[<span class="number">510</span>];</span><br><span class="line"><span class="keyword">int</span> used[<span class="number">510</span>];  <span class="comment">//用于记录是否已经被匹配</span></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++)&#123;   <span class="comment">//遍历所有被选者</span></span><br><span class="line">        <span class="keyword">if</span>(line[x][i]==<span class="number">1</span> &amp;&amp; used[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//如果x对i有好感且在一个递归选取阶段没有被选取</span></span><br><span class="line">            used[i] = <span class="number">1</span>; <span class="comment">//标记已被选取</span></span><br><span class="line">            <span class="keyword">if</span>(boy[i]==<span class="number">0</span> || Find(boy[i]))&#123;</span><br><span class="line">                <span class="comment">//如果被选者没有归属或他的归属可以调换</span></span><br><span class="line">                boy[i] = x; <span class="comment">//将归属定为x</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, k, x, y, sum;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k)!=EOF &amp;&amp; k)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="built_in">memset</span>(line, <span class="number">0</span>, <span class="keyword">sizeof</span>(line));</span><br><span class="line">        <span class="built_in">memset</span>(boy, <span class="number">0</span>, <span class="keyword">sizeof</span>(boy));</span><br><span class="line">        <span class="built_in">memset</span>(used, <span class="number">0</span>, <span class="keyword">sizeof</span>(used));</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;x, &amp;y);</span><br><span class="line">            line[x][y] = <span class="number">1</span>; <span class="comment">//表示x希望与y有关系</span></span><br><span class="line">        &#125;</span><br><span class="line">        sum = <span class="number">0</span>; <span class="comment">//记录能组合的对数</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="built_in">memset</span>(used, <span class="number">0</span>, <span class="keyword">sizeof</span>(used)); <span class="comment">//每次都要清0</span></span><br><span class="line">            <span class="keyword">if</span>(Find(i))</span><br><span class="line">                sum++; <span class="comment">//找到一对就记录</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程开发</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>算法笔记</tag>
        <tag>匈牙利算法</tag>
      </tags>
  </entry>
  <entry>
    <title>欧拉函数（Euler&#39;s totient function）</title>
    <url>/posts/836c5604.html</url>
    <content><![CDATA[<blockquote>
<p> 在数论，对正整数n，欧拉函数是小于n的正整数中与n互质的数的数目(φ(1)=1)。此函数以其首名研究者欧拉命名(Euler’so totient function)，它又称为Euler’s totient function、φ函数、欧拉商数等。</p>
</blockquote>
<a id="more"></a>
<p>​      </p>
<h3 id="欧拉函数的定义："><a href="#欧拉函数的定义：" class="headerlink" title="欧拉函数的定义："></a>欧拉函数的定义：</h3><p>​    <strong>对正整数n，欧拉函数是小于n且和n互质的正整数(包括1)的个数</strong>。</p>
<p>​    例如Euler(8)=4，因为1,3,5,7均和8互质,下面用E(n)表示欧拉函数的值。</p>
<p>​    在数论中，对于正整数N,少于或等于N ([1,N]),且与N互质的正整数(包括1)的个数，记作φ(n)。</p>
<p>​    φ函数的值：​</p>
<script type="math/tex; mode=display">
φ(x)=x(1- \frac 1{p(1)})(1- \frac1{p(2)})(1-\frac1{p(3)})(1-\frac1{p(4)})…..(1-\frac1{p(n)})</script><p>​    其中p(1),p(2)…p(n)为x的所有质因数;</p>
<p>​    φ(1)=1(唯一和1互质的数，且小于等于1)。注意：每种质因数只有一个。</p>
<p>​     例如:</p>
<p>​         φ(10)=10×(1-1/2)×(1-1/5)=4; 分别为：1 3 7 9</p>
<p>​         φ(30)=30×(1-1/2)×(1-1/3)×(1-1/5)=8;</p>
<p>​         φ(49)=49×(1-1/7)=42;</p>
<h3 id="欧拉函数的性质："><a href="#欧拉函数的性质：" class="headerlink" title="欧拉函数的性质："></a>欧拉函数的性质：</h3><ol>
<li><p>对于素数p，φ(p) = p-1，对于两个素数p,q，φ(pq) = pq-1。</p>
<p>欧拉函数是积性函数，但不是完全积性函数。即φ(mn)=φ(m)*φ(n)，只有(n,m)=1时成立。</p>
</li>
<li><p>对于一个正整数N的素数幂分解$N = {P_1}^{q^1}<em>{P_2}^{q^2}</em>…*{P_n}^{q^n}$。</p>
<p>$φ(x)=x(1- \frac 1{p(1)})(1- \frac1{p(2)})(1-\frac1{p(3)})(1-\frac1{p(4)})…..(1-\frac1{p(n)})$</p>
</li>
<li><p>除了N=2，φ(N)都是偶数。</p>
</li>
<li><p>设N为正整数，$\sumφ(d) = N(d|N)$。</p>
</li>
</ol>
<p>根据性质2，我们可以在(sqrt(n))的时间内求一个数的欧拉函数值。</p>
<p>延伸：一个数的所有质因子之和是euler(n)*n/2。</p>
<p>欧拉函数模板</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接求小于或等于n,且与n互质的个数:</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">Euler</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret=x;</span><br><span class="line">    <span class="keyword">int</span> n=(<span class="keyword">int</span>)<span class="built_in">sqrt</span>(x*<span class="number">1.0</span>);</span><br><span class="line">    <span class="comment">//如果判断条件改为i*i&lt;=n,这里的i*i就会做sqrt(n)次,每次循环都要算一次，养成好习惯 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">     <span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">        ret=ret/i*(i<span class="number">-1</span>);<span class="comment">//先进行除法防止溢出(ret=ret*(1-1/p(i)))</span></span><br><span class="line">        <span class="keyword">while</span>(n%i==<span class="number">0</span>)</span><br><span class="line">          n/=i;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1</span>)</span><br><span class="line">          ret=ret/n*(n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">//筛选模板:求[1,n]之间每个数的质因数的个数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> size 1000001</span></span><br><span class="line"><span class="keyword">int</span> euler[size];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="built_in">memset</span>(euler,<span class="number">0</span>,<span class="keyword">sizeof</span>(euler));</span><br><span class="line">     euler[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;size;i++)</span><br><span class="line">       <span class="keyword">if</span>(!euler[i])</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;size;j+=i)&#123;</span><br><span class="line">              <span class="keyword">if</span>(!euler[j])</span><br><span class="line">               euler[j]=j;</span><br><span class="line">               euler[j]=euler[j]/i*(i<span class="number">-1</span>);<span class="comment">//先进行除法是为了防止中间数据的溢出</span></span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>找新朋友</p>
<p>Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)</p>
<p>Total Submission(s): 4409 Accepted Submission(s): 1999</p>
<p>Problem Description</p>
<p>新年快到了，“猪头帮协会”准备搞一个聚会，已经知道现有会员N人，把会员从1到N编号，</p>
<p>其中会长的号码是N号，凡是和会长是老朋友的，那么该会员的号码肯定和N有大于1的公约数，否则都是新朋友，</p>
<p>现在会长想知道究竟有几个新朋友？请你编程序帮会长计算出来。</p>
<p>Input</p>
<p>第一行是测试数据的组数CN（Case number，1&lt;CN&lt;10000），接着有CN行正整数N（1&lt;n&lt;32768），表示会员人数。</p>
<p>Output</p>
<p>对于每一个N，输出一行新朋友的人数，这样共有CN行输出。</p>
<p>Sample Input</p>
<p>2</p>
<p>25608</p>
<p>24027</p>
<p>Sample Output</p>
<p>7680</p>
<p>16016</p>
<p>Author</p>
<p>SmallBeer(CML)</p>
<p>Source</p>
<p>杭电ACM集训队训练赛（VII）</p>
<p>Recommend</p>
<p>lcy</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">euler</span><span class="params">( <span class="keyword">int</span> x )</span>  </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> res = x;  </span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">2</span>; i*i &lt;= x; i ++ )  </span><br><span class="line">        <span class="keyword">if</span>( x%i == <span class="number">0</span> )  &#123;  </span><br><span class="line">            res =res/i*(i<span class="number">-1</span>);  </span><br><span class="line">            <span class="keyword">while</span>(x%i==<span class="number">0</span>) x/=i;  </span><br><span class="line">        &#125;  </span><br><span class="line">    <span class="keyword">if</span>( x &gt; <span class="number">1</span> ) res = res/x*(x<span class="number">-1</span>);  </span><br><span class="line">    <span class="keyword">return</span> res;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> T;  </span><br><span class="line">    <span class="built_in">scanf</span> ( <span class="string">"%d"</span>, &amp;T );  </span><br><span class="line">    <span class="keyword">while</span>( T-- )  &#123;  </span><br><span class="line">        <span class="keyword">int</span> n;  </span><br><span class="line">        <span class="built_in">scanf</span> ( <span class="string">"%d"</span>, &amp;n );  </span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">"%d\n"</span>, euler(n) );  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程开发</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>算法笔记</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>优先队列(priority_queue)用法及心得</title>
    <url>/posts/179.html</url>
    <content><![CDATA[<blockquote>
<p> 普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除。在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高级先出 （first in, largest out）的行为特征。通常采用堆数据结构来实现。</p>
</blockquote>
<a id="more"></a>
<p>​        </p>
<h2 id="优先队列的头文件-amp-amp-声明"><a href="#优先队列的头文件-amp-amp-声明" class="headerlink" title="优先队列的头文件&amp;&amp;声明"></a>优先队列的头文件&amp;&amp;声明</h2><p>首先，你需要</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt; //如果要用到后面的greater&lt;int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure>
<p>这两个头文件。</p>
<p>其次，一个优先队列声明的基本格式是：<br><strong>priority_queue&lt;结构类型&gt; 队列名;</strong><br>比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">priority_queue &lt;<span class="keyword">int</span>&gt; i;</span><br><span class="line">priority_queue &lt;<span class="keyword">double</span>&gt; d;</span><br></pre></td></tr></table></figure>
<p>不过，我们最为常用的是这几种：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">priority_queue &lt;node&gt; q;</span><br><span class="line"><span class="comment">//node是一个结构体</span></span><br><span class="line"><span class="comment">//结构体里重载了‘&lt;’小于符号</span></span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"><span class="comment">//不需要#include&lt;vector&gt;头文件</span></span><br><span class="line"><span class="comment">//注意后面两个“&gt;”不要写在一起，“&gt;&gt;”是右移运算符</span></span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt; &gt;q;</span><br></pre></td></tr></table></figure>
<p>我们将在下文来讲讲这几种声明方式的不同。</p>
<h2 id="优先队列的基本操作"><a href="#优先队列的基本操作" class="headerlink" title="优先队列的基本操作"></a>优先队列的基本操作</h2><p>与队列的基本操作如出一辙。 </p>
<p>以一个名为q的优先队列为例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">q.size();//返回q里元素个数</span><br><span class="line">q.empty();//返回q是否为空，空则返回1，否则返回0</span><br><span class="line">q.push(k);//在q的末尾插入k</span><br><span class="line">q.pop();//删掉q的第一个元素</span><br><span class="line">q.top();//返回q的第一个元素</span><br></pre></td></tr></table></figure>
<h2 id="优先队列的特性"><a href="#优先队列的特性" class="headerlink" title="优先队列的特性"></a>优先队列的特性</h2><p><strong>自动排序</strong><br>怎么个排法呢？<br>在这里介绍一下：</p>
<h3 id="默认的优先队列（非结构体结构）"><a href="#默认的优先队列（非结构体结构）" class="headerlink" title="默认的优先队列（非结构体结构）"></a>默认的优先队列（非结构体结构）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">priority_queue &lt;int&gt; q;</span><br></pre></td></tr></table></figure>
<p>这样的优先队列是怎样的？让我们写程序验证一下。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[]=&#123;<span class="number">10</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">6</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) q.push(a[i]);</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,q.top()); <span class="comment">//14 12 10 8 6</span></span><br><span class="line">		q.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序大意就是在这个优先队列里依次插入10、8、12、14、6，再输出。<br>结果是什么呢？<br><code>14 12 10 8 6</code><br>也就是说，它是按从大到小排序的！</p>
<h3 id="默认的优先队列（结构体，重载小于）"><a href="#默认的优先队列（结构体，重载小于）" class="headerlink" title="默认的优先队列（结构体，重载小于）"></a>默认的优先队列（结构体，重载小于）</h3><p>先看看这个结构体是什么。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">	node(<span class="keyword">int</span> xx, <span class="keyword">int</span> yy)&#123;</span><br><span class="line">		x=xx;</span><br><span class="line">		y=yy;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp; a) <span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x &lt; a.x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个node结构体有两个成员，x和y，它的小于规则是x小者小。<br>再来看看验证程序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">	node(<span class="keyword">int</span> xx, <span class="keyword">int</span> yy)&#123;</span><br><span class="line">		x=xx;</span><br><span class="line">		y=yy;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp; a) <span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x &lt; a.x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	priority_queue &lt;node&gt; q;</span><br><span class="line">	q.push(node(<span class="number">10</span>, <span class="number">100</span>));</span><br><span class="line">	q.push(node(<span class="number">12</span>,<span class="number">60</span>));</span><br><span class="line">	q.push(node(<span class="number">14</span>,<span class="number">40</span>));</span><br><span class="line">	q.push(node(<span class="number">6</span>,<span class="number">80</span>));</span><br><span class="line">	q.push(node(<span class="number">8</span>,<span class="number">20</span>));</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"(%d,%d) "</span>,q.top().x,q.top().y); <span class="comment">//(14,40) (12,60) (10,100) (8,20) (6,80)</span></span><br><span class="line">		q.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序大意就是插入(10,100),(12,60),(14,40),(6,20),(8,20)这五个node。<br>再来看看它的输出：<br><code>(14,40) (12,60) (10,100) (8,20) (6,80)</code></p>
<p>它也是按照<strong>重载后的小于规则</strong>，从大到小排序的。</p>
<h3 id="less和greater优先队列"><a href="#less和greater优先队列" class="headerlink" title="less和greater优先队列"></a>less和greater优先队列</h3><p>还是以int为例，先来声明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">priority_queue &lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt; &gt; p;</span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt; q;</span><br></pre></td></tr></table></figure>
<p>话不多说，上程序和结果：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt; //因为用了greater&lt;int&gt;() </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	priority_queue &lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt; &gt; p;</span><br><span class="line">	priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">5</span>]=&#123;<span class="number">10</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">		p.push(a[i]),q.push(a[i]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"less&lt;int&gt;:"</span>);</span><br><span class="line">	<span class="keyword">while</span>(!p.empty())</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,p.top()),p.pop();  </span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\ngreater&lt;int&gt;:"</span>);</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,q.top()),q.pop();</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：<br><code>less&lt;int&gt;:14 12 10 8 6 greater&lt;int&gt;:6 8 10 12 14</code></p>
<p>所以，我们可以知道，<strong>less是从大到小，greater是从小到大</strong>。</p>
<h3 id="作个总结"><a href="#作个总结" class="headerlink" title="作个总结"></a>作个总结</h3><p>为了<del>装13</del>方便，在平时，建议大家写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt;q;</span><br><span class="line">priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q;12</span><br></pre></td></tr></table></figure>
<p>平时如果用从大到小不用后面的<code>vector&lt;int&gt;,less&lt;int&gt;</code>，可能到时候要改成从小到大，你反而会搞忘怎么写<code>greater&lt;int&gt;</code>，反而得不偿失。</p>
<blockquote>
<p>本文转载自：<a href="https://blog.csdn.net/c20182030/article/details/70757660" target="_blank" rel="noopener">https://blog.csdn.net/c20182030/article/details/70757660</a></p>
</blockquote>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>01分数规划</title>
    <url>/posts/16895.html</url>
    <content><![CDATA[<blockquote>
<p><strong>wyh的物品</strong></p>
<p>时间限制：C/C++ 5秒，其他语言10秒<br>空间限制：C/C++ 262144K，其他语言524288K<br>64bit IO Format: %lld</p>
<p>题目描述<br>wyh学长现在手里有n个物品，这n个物品的重量和价值都告诉你，然后现在让你从中选取k个，问你在所有可能选取的方案中，最大的单位价值为多少（单位价值为选取的k个物品的总价值和总重量的比值）</p>
<a id="more"></a>
<p>链接：<a href="https://www.nowcoder.com/acm/contest/93/I" target="_blank" rel="noopener">https://www.nowcoder.com/acm/contest/93/I</a><br>来源：牛客网</p>
<p>输入描述:<br>输入第一行一个整数T(1&lt;=T&lt;=10)<br>接下来有T组测试数据，对于每组测试数据，第一行输入两个数n和k(1&lt;=k&lt;=n&lt;=100000)<br>接下来有n行，每行两个是a和b，代表这个物品的重量和价值</p>
<p>输出描述:<br>对于每组测试数据，输出对应答案，结果保留两位小数</p>
<p>示例1<br>输入<br>1<br>3 2<br>2 2<br>5 3<br>2 1</p>
<p>输出<br>0.75</p>
<p>说明<br>对于样例来说，我们选择第一个物品和第三个物品，达到最优目的</p>
</blockquote>
<p>做法:<br>二分，对于每一个答案C，有 s[i] = w[i]-c*v[i]<br>排序，取最大前k个，如果大于等于0则可行，否则不可行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> n,k; <span class="comment">//n件物品取k件</span></span><br><span class="line"><span class="keyword">int</span> wi[maxn],vi[maxn];<span class="comment">//物品的重量和价值</span></span><br><span class="line"><span class="keyword">double</span> y[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">		y[i]=vi[i]-x*wi[i];</span><br><span class="line">	sort(y,y+n);</span><br><span class="line">	<span class="keyword">double</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++)&#123;</span><br><span class="line">		sum += y[n-i<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum&gt;=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;wi[i],&amp;vi[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">double</span> left=<span class="number">0</span>, right=maxn;</span><br><span class="line">		<span class="keyword">while</span>(right-left&gt;<span class="number">1e-6</span>)&#123;</span><br><span class="line">			<span class="keyword">double</span> mid = (right+left)/<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span>(cmp(mid)) left=mid;</span><br><span class="line">			<span class="keyword">else</span> right = mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>, right);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>OJ刷题</category>
      </categories>
      <tags>
        <tag>算法笔记</tag>
        <tag>01分数规划</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组和归并排序求逆序数</title>
    <url>/posts/e5d88cfb.html</url>
    <content><![CDATA[<blockquote>
<p>整理解决逆序数问题的方法</p>
<p>树状数组+归并排序求逆序数</p>
</blockquote>
<a id="more"></a>
<p>​        </p>
<h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><p>树状数组，具体的说是 离散化+树状数组。</p>
<p>算法的大体流程就是：</p>
<ol>
<li>先对输入的数组离散化，使得各个元素比较接近，而不是离散的</li>
<li>接着，运用树状数组的标准操作来累计数组的逆序数。</li>
</ol>
<p>算法详细解释：</p>
<ol>
<li>解释为什么要有离散的这么一个过程？</li>
</ol>
<p>刚开始以为999.999.999这么一个数字，对于int存储类型来说是足够了。还有只有500000个数字，何必要离散化呢？刚开始一直想不通，后来明白了，后面在运用树状数组操作的时候，用到的树状数组C[i]是建立在一个有点像位存储的数组的基础之上的，不是单纯的建立在输入数组之上。</p>
<p>比如输入一个9 1 0 5 4，那么C[i]树状数组的建立是在，</p>
<p>​    下标 0 1 2 3 4 5 6 7 8 9</p>
<p>​    数组 1 1 0 0 1 1 0 0 0 1</p>
<p>现在由于999999999这个数字相对于500000这个数字来说是很大的，所以如果用数组位存储的话，那么需要999999999的空间来存储输入的数据。这样是很浪费空间的，题目也是不允许的，所以这里想通过离散化操作，使得离散化的结果可以更加的密集。</p>
<ol>
<li>怎么对这个输入的数组进行离散操作？</li>
</ol>
<p>离散化是一种常用的技巧，有时数据范围太大，可以用来放缩到我们能处理的范围；因为其中需排序的数的范围0—-999 999 999；显然数组不肯能这么大；而N的最大范围是500 000；故给出的数一定可以与1.。。。N建立一个一一映射；</p>
<p>   ①当然用map可以建立，效率可能低点；</p>
<p>   ②这里用一个结构体</p>
<p>   struct Node</p>
<p>   {</p>
<p>​      int v,ord;</p>
<p>   }p[510000];和一个数组a[510000];</p>
<p>   其中v就是原输入的值，ord是下标；然后对结构体按v从小到大排序；此时，v和结构体的下标就是一个一一对应关系，而且满足原来的大小关系；</p>
<p>   for(i=1;i&lt;=N;i++) a[p[i].ord]=i;</p>
<p>然后a数组就存储了原来所有的大小信息；比如 9 1 0 5 4 ———- 离散后aa数组就是 5 2 1 4 3；具体的过程可以自己用笔写写就好了。</p>
<ol>
<li>离散之后，怎么使用离散后的结果数组来进行树状数组操作，计算出逆序数？</li>
</ol>
<p>如果数据不是很大， 可以一个个插入到树状数组中，每插入一个数， 统计比他小的数的个数，对应的逆序为 i- getsum( aa[i] )，其中 i 为当前已经插入的数的个数，getsum( aa[i] ）为比 aa[i] 小的数的个数，i- sum( aa[i] ) 即比 aa[i] 大的个数， 即逆序的个数。</p>
<p>但如果数据比较大，就必须采用离散化方法。</p>
<p>假设输入的数组是9 1 0 5 4， 离散后的结果aa[] = {5,2,1,4,3};</p>
<p>在离散结果中间结果的基础上，那么其计算逆序数的过程是这么一个过程。</p>
<ol>
<li>输入5，   调用upDate(5, 1),把第5位设置为1</li>
</ol>
<p>1 2 3 4 5</p>
<p>0 0 0 0 1</p>
<p>计算1-5上比5小的数字存在么？ 这里用到了树状数组的getSum（5） = 1操作，现在用输入的下标1 - getSum(5) = 0 就可以得到对于5的逆序数为0。</p>
<ol>
<li>输入2， 调用upDate(2, 1),把第2位设置为1</li>
</ol>
<p>1 2 3 4 5</p>
<p>0 1 0 0 1</p>
<p>计算1-2上比2小的数字存在么？ 这里用到了树状数组的getSum（2） = 1操作，现在用输入的下标2 - getSum(2) = 1 就可以得到对于2的逆序数为1。</p>
<ol>
<li>输入1， 调用upDate(1, 1),把第1位设置为1</li>
</ol>
<p>1 2 3 4 5</p>
<p>1 1 0 0 1</p>
<p>计算1-1上比1小的数字存在么？ 这里用到了树状数组的getSum（1） = 1操作，现在用输入的下标 3 - getSum(1) = 2 就可以得到对于1的逆序数为2。</p>
<ol>
<li>输入4， 调用upDate(4, 1),把第5位设置为1</li>
</ol>
<p>1 2 3 4 5</p>
<p>1 1 0 1 1</p>
<p>计算1-4上比4小的数字存在么？ 这里用到了树状数组的getSum（4） = 3操作，现在用输入的下标4 - getSum(4) = 1 就可以得到对于4的逆序数为1。</p>
<ol>
<li>输入3， 调用upDate(3, 1),把第3位设置为1</li>
</ol>
<p>1 2 3 4 5</p>
<p>1 1 1 1 1</p>
<p>计算1-3上比3小的数字存在么？ 这里用到了树状数组的getSum（3） = 3操作，现在用输入的下标5 - getSum(3) = 2 就可以得到对于3的逆序数为2。</p>
<ol>
<li>0+1+2+1+2 = 6 这就是最后的逆序数</li>
</ol>
<p>分析一下时间复杂度，首先用到快速排序，时间复杂度为O(NlogN),</p>
<p>后面是循环插入每一个数字，每次插入一个数字，分别调用一次upData()和getSum()</p>
<p>外循环N, upData()和getSum()时间O(logN) =&gt; 时间复杂度还是O(NlogN).</p>
<p>最后总的还是O(NlogN).</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">500005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> aa[maxn];	<span class="comment">//离散后的数组</span></span><br><span class="line"><span class="keyword">int</span> c[maxn];	<span class="comment">//树状数组</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	<span class="keyword">int</span> order;</span><br><span class="line">&#125;in[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">	<span class="comment">//求出2^p(其中p: x 的二进制表示数中， 右向左数第一个1的位置)</span></span><br><span class="line">	<span class="comment">//如6的二进制表示为110，向左数第零个为0，第一个为1，则p=1，故Lowbit(6) = 2^1 = 2。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node a, Node b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.v&lt;b.v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=t; i&lt;=n; i+=lowbit(i))</span><br><span class="line">		c[i]+=value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=x; i&gt;=<span class="number">1</span>; i-=lowbit(i))</span><br><span class="line">		temp+=c[i];</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)==<span class="number">1</span> &amp;&amp; n)&#123;</span><br><span class="line">		<span class="comment">//离散化</span></span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;in[i].v);</span><br><span class="line">			in[i].order=i;</span><br><span class="line">		&#125;</span><br><span class="line">		sort(in+<span class="number">1</span>, in+n+<span class="number">1</span>, cmp);</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">			aa[in[i].order] = i;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//树状数组求逆序</span></span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span>(c));</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">			update(aa[i],<span class="number">1</span>);</span><br><span class="line">			ans += i-getsum(aa[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>对于一个数组{5，3，7，4，6，2，1，8}，如果我们以中间（或者左中）为界限将其分成两个数组，只要知道这两个数组中的逆序对数和两边的数所组成的逆序对数就是它所有的逆序对数了。而数组划分的递归结束点在两个数组都只有一个元素的时候，因此两数组中的逆序对数可以要去求分裂的两数组中的逆序对数可以这样去做：先将两数组按升序排序，若前一个数组的第一个元素比后一个的大，则说明前一组的后面所有都要比后一组的第一个元素大，这样将较小的第一个元素去掉后，继续比较两个数组的第一个元素可以把所有的逆序对找到。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right,<span class="keyword">int</span> temp[],<span class="keyword">long</span> <span class="keyword">long</span> *count)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">0</span>,i,j;</span><br><span class="line">	i = left; j = mid+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>((i&lt;=mid) &amp;&amp; (j&lt;=right))&#123;</span><br><span class="line">		<span class="keyword">if</span>(arr[i] &lt;= arr[j])&#123;</span><br><span class="line">			temp[k++] = arr[i++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			temp[k++] = arr[j++];</span><br><span class="line">			<span class="comment">//ans+=e1-p1+1;</span></span><br><span class="line">			(*count) = (*count) + mid - i + <span class="number">1</span>;</span><br><span class="line">			<span class="comment">//在归并排序的过程中，可以一步步来计算逆序数的值，由于归并排序的过程一直都是升序在排序，所以如果a[i]&gt;a[j]的话，那么a[i]后面的数一定都大于a[j]，加上后面的数的个数；</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=mid)</span><br><span class="line">		temp[k++] = arr[i++];</span><br><span class="line">	<span class="keyword">while</span>(j&lt;=right)</span><br><span class="line">		temp[k++] = arr[j++];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">		arr[left+i] = temp[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> temp[],<span class="keyword">long</span> <span class="keyword">long</span> *count)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(left&lt;right)&#123; <span class="comment">// 递归出口</span></span><br><span class="line">		<span class="keyword">int</span> mid = (left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		mergeSort(arr,left,mid,temp,count);</span><br><span class="line">		mergeSort(arr,mid+<span class="number">1</span>,right,temp,count);</span><br><span class="line">		merge(arr,left,mid,right,temp,count);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">	<span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> *temp = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">	mergeSort(a,<span class="number">0</span>,m<span class="number">-1</span>,temp,&amp;count);</span><br><span class="line">	<span class="keyword">delete</span> []a;</span><br><span class="line">	<span class="keyword">delete</span> []temp;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;count;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>本文参考整理自：</p>
<p><a href="http://www.360doc.com/content/12/0925/21/9615799_238155264.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/12/0925/21/9615799_238155264.shtml</a></p>
</blockquote>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>算法笔记</tag>
        <tag>树状数组</tag>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title>LQOJ刷题总结</title>
    <url>/posts/dd160cb.html</url>
    <content><![CDATA[<blockquote>
<p>LQOJ</p>
<p>Record my code in LQOJ</p>
</blockquote>
<a id="more"></a>
<p>​         </p>
<h3 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h3><ol>
<li><a href="https://github.com/hushhw/LQOJ/blob/master/BASIC/BASIC-29%20%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95.cpp" target="_blank" rel="noopener">高精度加法</a>  <code>BASIC-29</code> <code>高精度加法</code> </li>
<li><a href="https://github.com/hushhw/LQOJ/blob/master/BASIC/BASIC-30%20%E9%98%B6%E4%B9%98%E8%AE%A1%E7%AE%97.cpp" target="_blank" rel="noopener">阶乘计算</a> <code>BASIC-30</code>  <code>高精度乘法</code></li>
</ol>
<h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><ol>
<li><a href="https://github.com/hushhw/LQOJ/blob/master/BASIC/BASIC-27%202n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98.cpp" target="_blank" rel="noopener">2n皇后问题</a> <code>BASIC-27</code> <code>八皇后问题</code> <code>搜索</code></li>
</ol>
<h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><ol>
<li><a href="https://github.com/hushhw/LQOJ/blob/master/BASIC/BASIC-19%20%E5%AE%8C%E7%BE%8E%E7%9A%84%E4%BB%A3%E4%BB%B7.cpp" target="_blank" rel="noopener">完美的代价</a> <code>BASIC-19</code></li>
<li><a href="https://github.com/hushhw/LQOJ/blob/master/ALGO/ALGO-002%20%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0(%E8%B4%AA%E5%BF%83" target="_blank" rel="noopener">最大最小公倍数</a>.cpp) <code>ALGO-2</code> </li>
</ol>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><ol>
<li><a href="https://github.com/hushhw/LQOJ/blob/master/ALGO/ALGO-003%20K%E5%A5%BD%E6%95%B0.cpp" target="_blank" rel="noopener">K好数</a> <code>ALGO-3</code> <code>数位dp</code></li>
<li><a href="https://github.com/hushhw/LQOJ/blob/master/ALGO/ALGO-004%20%E7%BB%93%E7%82%B9%E9%80%89%E6%8B%A9.cpp" target="_blank" rel="noopener">结点选择</a> <code>ALGO-4</code> <code>树形dp</code></li>
</ol>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul>
<li>图论<ul>
<li><a href="https://github.com/hushhw/LQOJ/blob/master/ALGO/ALGO-005%20%E6%9C%80%E7%9F%AD%E8%B7%AF.cpp" target="_blank" rel="noopener">最短路</a> <code>ALGO-5</code> <code>SPFA算法</code></li>
</ul>
</li>
<li>矩阵<ul>
<li><a href="https://github.com/hushhw/LQOJ/blob/master/BASIC/BASIC-17%20%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95.cpp" target="_blank" rel="noopener">矩阵乘法</a> <code>BASIC-17</code> <code>矩阵</code></li>
</ul>
</li>
<li>树&amp;二叉树</li>
</ul>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>OJ刷题</category>
      </categories>
      <tags>
        <tag>OJ</tag>
        <tag>刷题</tag>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title>最小生成树算法</title>
    <url>/posts/45316.html</url>
    <content><![CDATA[<blockquote>
<p><strong>最小生成树</strong>是一副连通加权无向图中一棵权值最小的生成树。</p>
<ul>
<li>Kruskal算法</li>
<li>Prim算法</li>
</ul>
</blockquote>
<a id="more"></a>
<p>关于图的几个概念定义：</p>
<ul>
<li><strong>连通图</strong>：在无向图中，若任意两个顶点vi与vj都有路径相通，则称该无向图为连通图。</li>
<li><strong>强连通图</strong>：在有向图中，若任意两个顶点vi与vj都有路径相通，则称该有向图为强连通图。</li>
<li><strong>连通网</strong>：在连通图中，若图的边具有一定的意义，每一条边都对应着一个数，称为权；权代表着连接连个顶点的代价，称这种连通图叫做连通网。</li>
<li><strong>生成树</strong>：一个连通图的生成树是指一个连通子图，它含有图中全部n个顶点，但只有足以构成一棵树的n-1条边。一颗有n个顶点的生成树有且仅有n-1条边，如果生成树中再添加一条边，则必定成环。</li>
<li><p><strong>最小生成树</strong>：在连通网的所有生成树中，所有边的代价和最小的生成树，称为最小生成树。</p>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-01-12_20-38-29.png" alt></p>
</li>
</ul>
<p>下面介绍两种求最小生成树算法</p>
<h2 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h2><p>此算法可以称为“加边法”，初始最小生成树边数为0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里。 </p>
<ol>
<li>把图中的所有边按代价从小到大排序； </li>
<li>把图中的n个顶点看成独立的n棵树组成的森林； </li>
<li>按权值从小到大选择边，所选的边连接的两个顶点ui,vi,应属于两颗不同的树，则成为最小生成树的一条边，并将这两颗树合并作为一颗树。 </li>
<li>重复(3),直到所有顶点都在一颗树内或者有n-1条边为止。</li>
</ol>
<p>实际上代码中就是并查集思想</p>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-01-12_20-38-52.png" alt></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> from,to,val;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge &amp;x)<span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> val &lt; x.val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;e[MAXN * MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[MAXN],len=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	r=x;</span><br><span class="line">	<span class="keyword">while</span>(r!=pre[r]) <span class="comment">//如果不是根，就去找</span></span><br><span class="line">		r=pre[r];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//路径压缩</span></span><br><span class="line">	<span class="keyword">int</span> i=x;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="keyword">while</span>(i!=r)&#123;	<span class="comment">//如果当前查找的结点x不是根</span></span><br><span class="line">		j=pre[i];	<span class="comment">//用j临时存储</span></span><br><span class="line">		pre[i]=r;	<span class="comment">//更新x的pre前导点直接指向r(前面已经搜过，r即根)</span></span><br><span class="line">		i=j;		<span class="comment">//让i指向其前导点，在下一次循环里面就会更新其前导点指向根</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) fa[i] = i;</span><br><span class="line">    sort(e,e+len);</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> rootx=find(e[i].from);<span class="comment">//分别查找根</span></span><br><span class="line">        <span class="keyword">int</span> rooty=find(e[i].to);</span><br><span class="line">        <span class="keyword">if</span>(rootx==rooty) <span class="keyword">continue</span>;</span><br><span class="line">        fa[rootx]=rooty; <span class="comment">//没有连接就更新连在一起</span></span><br><span class="line">        ans += e[i].val;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h2><p>Prim算法是一种产生最小生成树的算法。该算法于<code>1930</code>年由捷克数学家沃伊捷赫·亚尔尼克（英语：<code>Vojtěch Jarník</code>）发现；并在<code>1957</code>年由美国计算机科学家罗伯特·普里姆（英语：<code>Robert C. Prim</code>）独立发现；<code>1959</code>年，艾兹格·迪科斯彻再次发现了该算法。</p>
<p><code>Prim</code>算法从任意一个顶点开始，每次选择一个与当前顶点集最近的一个顶点，并将两顶点之间的边加入到树中。<code>Prim</code>算法在找当前最近顶点时使用到了贪婪算法。</p>
<p>算法描述：</p>
<ol>
<li>在一个加权连通图中，顶点集合<code>V</code>，边集合为<code>E</code></li>
<li>任意选出一个点作为初始顶点,标记为<code>visit</code>,计算所有与之相连接的点的距离，选择距离最短的，标记<code>visit</code>.</li>
<li>重复以下操作，直到所有点都被标记为<code>visit</code>：</li>
</ol>
<p>在剩下的点中，计算与已标记<code>visit</code>点距离最小的点，标记<code>visit</code>,证明加入了最小生成树。</p>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-01-12_20-39-16.png" alt></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> dis[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) dis[i] = INF;</span><br><span class="line"><span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">dis[cur]=<span class="number">0</span>;vis[cur]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        <span class="keyword">if</span>(!vis[j] &amp;&amp; dis[j] &gt; <span class="built_in">map</span>[cur][j])</span><br><span class="line">             dis[j] = <span class="built_in">map</span>[cur][j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mini = INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            <span class="keyword">if</span>(!vis[j] &amp;&amp; dis[j] &lt; mini)</span><br><span class="line">                mini = dis[cur = j];</span><br><span class="line">        vis[cur] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) ans+=dis[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>本文参考整理自：<br><a href="http://blog.csdn.net/luoshixian099/article/details/51908175" target="_blank" rel="noopener">勿在浮沙筑高台</a></p>
<p><a href="https://www.hrwhisper.me/algorithm-graph-dijkstra-spfa-bellmanford-prim-kruskal/#_MST" target="_blank" rel="noopener">https://www.hrwhisper.me/algorithm-graph-dijkstra-spfa-bellmanford-prim-kruskal/#_MST</a></p>
</blockquote>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>算法笔记</tag>
        <tag>图论</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路径</title>
    <url>/posts/19511.html</url>
    <content><![CDATA[<blockquote>
<p><strong>最短路径</strong>问题是图论研究中的一个经典算法问题，旨在寻找图（由结点和路径组成的）中两结点之间的最短路径。</p>
<ul>
<li>dijkstra</li>
<li>SPFA</li>
<li>floyd</li>
</ul>
</blockquote>
<a id="more"></a>
<p>​          </p>
<h2 id="dijkstra-单源最短路径"><a href="#dijkstra-单源最短路径" class="headerlink" title="dijkstra(单源最短路径)"></a>dijkstra(单源最短路径)</h2><p>Dijkstra单源最短路算法，即计算从起点出发到每个点的最短路。Dijkstra常常作为其他算法的预处理。</p>
<ul>
<li>使用邻接矩阵的时间复杂度为O(n^2)</li>
<li>用邻接表+优先队列（堆）的时间复杂度为O((m+n)logn)近似为O(mlogn)</li>
</ul>
<p>这个算法只能计算单元最短路，而且不能计算负权值，这个算法是贪心的思想， dis数组用来储存起始点到其他点的最短路，但开始时却是存的起始点到其他点的初始路程。通过n-1遍的遍历找最短。<br>比如1到3的最短路就是比较dis[3]与dis[2]+e[2][3]，如果大于的话就更新dis[3]位dis[2]+e[2][3]，这个专业术语叫松弛，这种算法的核心思想就是通过边来松弛一号顶点到其他定点的路程，这也就能解释为什么要遍历n-1遍了。<br>book数组用来标记，被标记的是已经找过的最短路，没被标记的没有被找过的最短路，当全部找过以后算法结束，也就是说dis数组中的数是起始点到其他所有点的最短路 。</p>
<p>以下为以 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1874" target="_blank" rel="noopener">HDU 1874 畅通工程续</a> 完整代码：</p>
<ol>
<li>dijkstra+邻接矩阵</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">200</span>+<span class="number">10</span>;  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[MAXN][MAXN];	<span class="comment">//e用来记录数组</span></span><br><span class="line"><span class="keyword">int</span> dis[MAXN];		<span class="comment">//dis用来记录初始点到个点的位置</span></span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];		<span class="comment">//标记是否被访问</span></span><br><span class="line"><span class="keyword">int</span> n,m;		<span class="comment">//n表示顶点个数，m表示边的条数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));<span class="comment">//初始化判断数组</span></span><br><span class="line">	<span class="keyword">int</span> cur=s;</span><br><span class="line">	dis[cur]=<span class="number">0</span>;</span><br><span class="line">	vis[cur]=<span class="number">1</span>; <span class="comment">//把起点标记为已访问</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Dijkstra算法核心语句</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!vis[j] &amp;&amp; dis[j] &gt; dis[cur] + <span class="built_in">map</span>[cur][j])&#123;  <span class="comment">//更新cur到j的距离</span></span><br><span class="line">				dis[j]=dis[cur] + <span class="built_in">map</span>[cur][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> mini=inf;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!vis[j] &amp;&amp; dis[j]&lt;mini)&#123;		<span class="comment">//更新当前未访问的最小的dis[cur]</span></span><br><span class="line">				mini=dis[j];</span><br><span class="line">				cur = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		vis[cur]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m))&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">			dis[i]=inf;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">				<span class="built_in">map</span>[i][j]=inf;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> from,to,val;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++)&#123;	<span class="comment">//读入边</span></span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;from,&amp;to,&amp;val);</span><br><span class="line">			<span class="built_in">map</span>[from][to] = <span class="built_in">map</span>[to][from] = val;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> s,t;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;s,&amp;t); <span class="comment">//输入起点和终点</span></span><br><span class="line">		dijkstra(s);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(dis[t]==inf)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dis[t]);</span><br><span class="line">	&#125;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>dijkstra+优先队列</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">200</span>+<span class="number">10</span>;  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[MAXN],len;		<span class="comment">//记录数组</span></span><br><span class="line"><span class="keyword">int</span> dis[MAXN];		<span class="comment">//dis用来记录初始点到个点的位置</span></span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];		<span class="comment">//标记是否被访问</span></span><br><span class="line"><span class="keyword">int</span> n,m;			<span class="comment">//n表示顶点个数，m表示边的条数</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, val, next;</span><br><span class="line">&#125;e[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">	e[len].to=to;</span><br><span class="line">	e[len].val=val;</span><br><span class="line">	e[len].next=head[from];</span><br><span class="line">	head[from]=len++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> val, id;</span><br><span class="line">	point(<span class="keyword">int</span> id,<span class="keyword">int</span> val):id(id),val(val)&#123;&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> point &amp;x)<span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val&gt;x.val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));	<span class="comment">//初始化判断数组</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">		dis[i] = inf;</span><br><span class="line">	priority_queue&lt;point&gt; q;</span><br><span class="line">	q.push(point(s,<span class="number">0</span>));</span><br><span class="line">	dis[s]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		<span class="keyword">int</span> cur=q.top().id;</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">if</span>(vis[cur]) <span class="keyword">continue</span>;</span><br><span class="line">		vis[cur]=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=head[cur]; i!=<span class="number">-1</span>; i=e[i].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> id=e[i].to;</span><br><span class="line">			<span class="keyword">if</span>(!vis[id] &amp;&amp; dis[cur]+e[i].val &lt; dis[id])&#123;</span><br><span class="line">				dis[id]=dis[cur]+e[i].val;</span><br><span class="line">				q.push(point(id, dis[id]));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m))&#123;</span><br><span class="line">		len=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> from, to, val;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;from,&amp;to,&amp;val);</span><br><span class="line">			add(from, to, val);</span><br><span class="line">			add(to, from, val);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> s,t;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;s,&amp;t); <span class="comment">//输入起点和终点</span></span><br><span class="line">		dijkstra(s);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(dis[t]==inf)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dis[t]);</span><br><span class="line">	&#125;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h2><p>SPFA 是 bellman-ford 算法的队列实现版本（貌似也改进了点）</p>
<p>SPFA 的实现如下：</p>
<p>用数组 dis 记录更新后的状态，cnt 记录更新的次数，队列 q 记录更新过的顶点，算法依次从 q 中取出顶点 v，按照 dis(k)[u]=min{dis(k-1)[v]+e(v,u)} 的递归式更新。在计算过程中，一旦发现顶点 K 有 cnt[k]&gt;n，说明有一个从顶点 K 出发的负权圈，此时没有最短路，应终止算法。否则，队列为空的时候，算法得到G的各顶点的最短路径长度。</p>
<p> 下面举一个实例来说明SFFA算法是怎样进行的：<br><img src="https://photo.hushhw.cn/images/s9-4-1.jpg" alt><br><img src="https://photo.hushhw.cn/images/s9-4-2.jpg" alt></p>
<p>1.邻接矩阵的SPFA <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1874" target="_blank" rel="noopener">HDU 1874 畅通工程续</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">200</span>+<span class="number">10</span>;  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[MAXN][MAXN];		<span class="comment">//记录数组</span></span><br><span class="line"><span class="keyword">int</span> dis[MAXN];		<span class="comment">//dis用来记录初始点到个点的位置</span></span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];		<span class="comment">//标记是否被访问</span></span><br><span class="line"><span class="keyword">int</span> n,m;			<span class="comment">//n表示顶点个数，m表示边的条数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">		dis[i]=inf;</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">	vis[s]=<span class="number">1</span>;</span><br><span class="line">	dis[s]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	q.push(s);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		<span class="keyword">int</span> cur=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		vis[cur]=<span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(dis[i] &gt; dis[cur] + <span class="built_in">map</span>[cur][i])&#123;</span><br><span class="line">				dis[i] = dis[cur] + <span class="built_in">map</span>[cur][i];</span><br><span class="line">				<span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">					q.push(i);</span><br><span class="line">					vis[i]=<span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m))&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">				<span class="built_in">map</span>[i][j]=inf;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> from,to,val;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++)&#123;	<span class="comment">//读入边</span></span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;from,&amp;to,&amp;val);</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">map</span>[from][to]&gt;val)</span><br><span class="line">				<span class="built_in">map</span>[from][to] = <span class="built_in">map</span>[to][from] = val;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> s,t;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;s,&amp;t); <span class="comment">//输入起点和终点</span></span><br><span class="line">		SPFA(s);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(dis[t]==inf)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dis[t]);</span><br><span class="line">	&#125;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>邻接表的SPFA（推荐）<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1874" target="_blank" rel="noopener">HDU 1874 畅通工程续</a></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">const int inf=0x3f3f3f3f;</span><br><span class="line">const int MAXN=200+10;  </span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int head[MAXN],len;	</span><br><span class="line">int dis[MAXN];		//dis用来记录初始点到个点的位置</span><br><span class="line">bool vis[MAXN];		//标记是否被访问</span><br><span class="line">int n,m;			//n表示顶点个数，m表示边的条数</span><br><span class="line"></span><br><span class="line">struct edge&#123;</span><br><span class="line">	int to, val, next;</span><br><span class="line">&#125;e[MAXN];</span><br><span class="line"></span><br><span class="line">void add(int from, int to, int val)&#123;</span><br><span class="line">	e[len].to=to;</span><br><span class="line">	e[len].val=val;</span><br><span class="line">	e[len].next=head[from];</span><br><span class="line">	head[from]=len++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void SPFA(int s)&#123;</span><br><span class="line">	memset(vis, 0, sizeof(vis));	//初始化判断数组</span><br><span class="line">	for(int i=0; i&lt;n; i++)</span><br><span class="line">		dis[i] = inf;</span><br><span class="line"></span><br><span class="line">	queue&lt;int&gt; q;</span><br><span class="line">	q.push(s);</span><br><span class="line">	vis[s]=true;</span><br><span class="line">	dis[s]=0;</span><br><span class="line"></span><br><span class="line">	while(!q.empty())&#123;</span><br><span class="line">		int cur=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		vis[cur]=false;</span><br><span class="line">		for(int i=head[cur]; i!=-1; i=e[i].next)&#123;</span><br><span class="line">			int id=e[i].to;</span><br><span class="line">			if(dis[id] &gt; dis[cur]+e[i].val)&#123;</span><br><span class="line">				dis[id] = dis[cur]+e[i].val;</span><br><span class="line">				if(!vis[id])&#123;</span><br><span class="line">					vis[id]=true;</span><br><span class="line">					q.push(id);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))&#123;</span><br><span class="line">		len=0;</span><br><span class="line">		memset(head, -1, sizeof(head));</span><br><span class="line"></span><br><span class="line">		for(int i=0; i&lt;m; i++)&#123;</span><br><span class="line">			int from, to, val;</span><br><span class="line">			scanf(&quot;%d%d%d&quot;,&amp;from,&amp;to,&amp;val);</span><br><span class="line">			add(from, to, val);</span><br><span class="line">			add(to, from, val);</span><br><span class="line">		&#125;</span><br><span class="line">		int s,t;</span><br><span class="line">		scanf(&quot;%d%d&quot;,&amp;s,&amp;t); //输入起点和终点</span><br><span class="line">		SPFA(s);</span><br><span class="line"></span><br><span class="line">		if(dis[t]==inf)</span><br><span class="line">			printf(&quot;-1\n&quot;);</span><br><span class="line">		else</span><br><span class="line">			printf(&quot;%d\n&quot;,dis[t]);</span><br><span class="line">	&#125;</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="floyd"><a href="#floyd" class="headerlink" title="floyd"></a>floyd</h2><p><strong>Floyd-Warshall算法</strong>（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包。Floyd-Warshall 算法的时间复杂度为$O(N^3)$，空间复杂度为$O(N^2)$。</p>
<p>这是一个dp（动态规划的过程）<br>dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);<br>即从顶点i到j且经过顶点k的最短路径长度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">200</span>+<span class="number">10</span>;  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> n,m;			<span class="comment">//n表示顶点个数，m表示边的条数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;n; k++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">				dis[i][j]=min(dis[i][j], dis[i][k]+dis[k][j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m))&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">				dis[i][j]=inf;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> from, to, val;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;from,&amp;to,&amp;val);</span><br><span class="line">			<span class="keyword">if</span>(dis[from][to] &gt; val)  </span><br><span class="line">				dis[to][from]=dis[from][to]=val; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> s,t;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;s,&amp;t); <span class="comment">//输入起点和终点</span></span><br><span class="line">		<span class="keyword">if</span>(s==t)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		floyd();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(dis[s][t]==inf)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dis[s][t]);</span><br><span class="line">	&#125;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>本文整理自：</p>
<p><a href="http://blog.csdn.net/acm_1361677193/article/details/48211319" target="_blank" rel="noopener">http://blog.csdn.net/acm_1361677193/article/details/48211319</a></p>
<p><a href="http://blog.csdn.net/xunalove/article/details/70045815" target="_blank" rel="noopener">http://blog.csdn.net/xunalove/article/details/70045815</a></p>
</blockquote>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>算法笔记</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>数位dp总结</title>
    <url>/posts/36418.html</url>
    <content><![CDATA[<blockquote>
<p>“在信息学竞赛中，有一类与数位相关的区间统计问题。这类问题往往具有比较浓厚的数学味道，无法暴力求解，需要在数位上进行地推等操作。”——刘聪《浅谈数位类统计问题》</p>
</blockquote>
<p>这类问题往往需要一些预处理，这里就要用到数位dp。</p>
<p>数位DP是解决把一个数字区间里所有数字按位拆分再进行计算或计数的问题的动态规划算法。</p>
<a id="more"></a>
<p>​          </p>
<h2 id="基本思想与方法"><a href="#基本思想与方法" class="headerlink" title="基本思想与方法"></a>基本思想与方法</h2><p>题目中经常需要统计区间[l, r]的满足题意的数的个数，这往往可以转换成求[0,r] - [0,l)的问题。对于求区间[0,n]有一个通用的方法：</p>
<p>​    对于一个小于n的数，肯定是从高位到低位出现某一位&lt;n的那一位，比如n=58(n为十进制)，x=49时，此时x的十位小于n，x=51时，此时x的个位小于n。</p>
<p>有了这个性质，我们可以从高位到低位枚举第一次&lt;n对应位是哪一位。这样之前的位确定了，之后的位就不受n的限制即从00…0~99…9，可以先预处理，然后这时就可以直接统计答案。</p>
<p>预处理f数组。$F[i, st]$代表的是位数为i，状态为st的方案数。这里的st根据题目需要确定。如i=4，$F[i, st]$也就是0000~9999的符合条件的数的个数。</p>
<p>决策第i位是多少（0~9），F[i, st] = F[i, st] + F[i-1, st’]，st’为相对应的状态。</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="【Hdu2089-吉利数】"><a href="#【Hdu2089-吉利数】" class="headerlink" title="【Hdu2089 吉利数】"></a>【Hdu2089 吉利数】</h3><blockquote>
<p>题意：</p>
<p>区间[l,r]内数字的数位不含62且不含4的数的个数，0&lt;l&lt;=r&lt;1000000</p>
<p>如62315包含62，所以不合法</p>
</blockquote>
<p>参照前面提到的思路，先预处理一个f数组，然后统计[0, m] - [0, n)。</p>
<p>f[i, j]表示开头为j 的i 位数中不包含”62”或”4”的数有多少个。如f[2, 6]包含60，61，63，65，66，67，68，69。我们这里再举个栗子f[3, 0]：表示从1~100中满足条件的个数、（这里就不枚举了、、、）【0,99】</p>
<p>那么f[3, 1]呢？表示从100~200中满足条件的个数【100,199】</p>
<p>具体看代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">7</span>; i++)&#123;		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">10</span>; j++)&#123;	<span class="comment">//枚举第i位数上的数字</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">10</span>; k++)&#123;<span class="comment">//枚举第i-1为数上的数字</span></span><br><span class="line">				<span class="keyword">if</span>(j!=<span class="number">4</span> &amp;&amp; !(j==<span class="number">6</span> &amp;&amp; k==<span class="number">2</span>))<span class="comment">//满足条件</span></span><br><span class="line">					dp[i][j] += dp[i<span class="number">-1</span>][k];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">7</span>; i++)&#123;		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">10</span>; j++)&#123;	<span class="comment">//枚举第i位数上的数字</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">10</span>; k++)&#123;<span class="comment">//枚举第i-1为数上的数字</span></span><br><span class="line">				<span class="keyword">if</span>(j!=<span class="number">4</span> &amp;&amp; !(j==<span class="number">6</span> &amp;&amp; k==<span class="number">2</span>))<span class="comment">//满足条件</span></span><br><span class="line">					dp[i][j] += dp[i<span class="number">-1</span>][k];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	init();</span><br><span class="line">	<span class="keyword">int</span> digit[<span class="number">10</span>];			<span class="comment">//存储每位数字</span></span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">1</span>;			<span class="comment">//位数</span></span><br><span class="line">	<span class="keyword">while</span>(n)&#123;</span><br><span class="line">		digit[len++]=n%<span class="number">10</span>;</span><br><span class="line">		n /= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;				<span class="comment">//记录满足条件的结果</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=len; i&gt;=<span class="number">1</span>; i--)&#123;	<span class="comment">//从最高为开始遍历</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;digit[i]; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(j!=<span class="number">4</span> &amp;&amp; !(digit[i+<span class="number">1</span>]==<span class="number">6</span> &amp;&amp; j==<span class="number">2</span>))</span><br><span class="line">				ans += dp[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(digit[i]==<span class="number">4</span> || (digit[i+<span class="number">1</span>]==<span class="number">6</span> &amp;&amp; digit[i]==<span class="number">2</span>)) <span class="comment">////第i位已经不满足条件，则i位以后都不可能满足条件，结束循环  </span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l,r;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r)&#123;</span><br><span class="line">		<span class="keyword">if</span>(l+r==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;solve(r+<span class="number">1</span>)-solve(l)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外一种方法：<code>记忆化的数位dp</code></p>
<p>通常而言，有四个参数必须 dp( pos, flag, limit )<br>pos表示当前<strong>正在</strong>枚举的数位。<br>flag标志已经枚举的前缀是否某种性质（前面的数位和，是否含有某个数，前一个枚举的数等等。。），当然flag可以有多个。<br>limit表示当前是否为上限，有时还会记录是否有前导0。<br>相较而言，记忆化搜索更容易编写，需要维护的细节更少。</p>
<p>​         </p>
<p>回到这题上面来，数位上不能有4也不能有连续的62，没有4的话在枚举的时候判断一下，不枚举4就可以保证状态合法了，所以这个约束没有记忆化的必要，而对于62的话，涉及到两位，当前一位是6或者不是6这两种不同情况我计数是不相同的，所以要用状态来记录不同的方案数。</p>
<p>dp[pos][sta]表示当前第pos位，前一位是否是6的状态，这里sta只需要去0和1两种状态就可以了，不是6的情况可视为同种，不会影响计数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">10</span>][<span class="number">2</span>]; <span class="comment">//dp[i][j]表示，当前第i位，前一位是否是6的状态</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> l,r,tot;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pos表示当前位置，pre表示前一个数，sta表示当前状态，也就是之前是否为6</span></span><br><span class="line"><span class="comment">//lim表示当前是否是有限制的，比如967，当我们第一个数选择9时，第二个数就只能选择0-6了</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> pre, <span class="keyword">int</span> sta, <span class="keyword">int</span> lim)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cur=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(pos==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//如果执行到0了，当前构成的数可行</span></span><br><span class="line">	<span class="keyword">if</span>(!lim &amp;&amp; dp[pos][sta]!=<span class="number">-1</span>) <span class="keyword">return</span> dp[pos][sta];</span><br><span class="line">	<span class="keyword">int</span> up = lim? a[pos]:<span class="number">9</span>; <span class="comment">//是否有限制判断</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=up; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">4</span> || (pre==<span class="number">6</span> &amp;&amp; i==<span class="number">2</span>)) <span class="comment">//如果当前数字为4，或者前一个数字为6，当前位2，排除</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		cur += dfs(pos<span class="number">-1</span>, i, i==<span class="number">6</span>, lim&amp;&amp;i==a[pos]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!lim) dp[pos][sta]=cur;</span><br><span class="line">	<span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	tot = <span class="number">0</span>;	<span class="comment">//tot用来记录位数</span></span><br><span class="line">	<span class="keyword">while</span>(x)&#123;</span><br><span class="line">		a[++tot]=x%<span class="number">10</span>;</span><br><span class="line">		x /= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dfs(tot,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r)&amp;&amp;(l+r))&#123;</span><br><span class="line">		<span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, solve(r)-solve(l<span class="number">-1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>算法笔记</tag>
        <tag>动态规划</tag>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title>博弈论总结</title>
    <url>/posts/ca813fce.html</url>
    <content><![CDATA[<blockquote>
<p>今天开始总结博弈这块的知识点，博弈论真的是一门非常神奇的学科。</p>
<p>博弈是信息学和数学试题中常会出现的一种类型，算法灵活多变是其最大特点，而其中有一类试题更是完全无法用常见的博弈树来进行解答。 </p>
<p><strong>寻找必败态</strong>即为针对此类试题给出一种解题思路。</p>
</blockquote>
<a id="more"></a>
<p>​          </p>
<p>常见的几种博弈：</p>
<h2 id="巴什博弈（Bash-Game）"><a href="#巴什博弈（Bash-Game）" class="headerlink" title="巴什博弈（Bash Game）"></a>巴什博弈（Bash Game）</h2><blockquote>
<p>问题模型：只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取m个。最后取光者得胜。</p>
</blockquote>
<p>显然，如果n=m+1，那么由于一次最多只能取m个，所以，无论先取者拿走多少个，后取者都能够一次拿走剩余的物品，后者取胜。因此我们发现了如何取胜的法则：</p>
<script type="math/tex; mode=display">
如果n=(m+1)r+s，（r为任意自然数，s≤m)</script><p>那么先取者要拿走s个物品，如果后取者拿走k（≤m)个，那么先取者再拿走m+1-k个，结果剩下(m+1)(r-1)个，以后保持这样的取法，那么先取者肯定获胜。</p>
<!--more-->
<p>总之，要保持给对手留下(m+1)的倍数，那么最后就能获胜。</p>
<script type="math/tex; mode=display">
取石子（一)\\
时间限制：3000 ms   |   内存限制：65535 KB \\
难度：2\\</script><p>描述<br>​    一天，TT在寝室闲着无聊，和同寝的人玩起了取石子游戏，而由于条件有限，他/她们是用旺仔小馒头当作石子。游戏的规则是这样的。设有一堆石子，数量为N（1&lt;=N&lt;=1000000），两个人轮番取出其中的若干个，每次最多取M（1&lt;=M&lt;=1000000），最先把石子取完者胜利。我们知道，TT和他/她的室友都十分的聪明，那么如果是TT先取，他/她会取得游戏的胜利么？ </p>
<p>输入<br>​    第一行是一个正整数n表示有n组测试数据<br>​    输入有不到1000组数据，每组数据一行，有两个数N和M,之间用空格分隔。 </p>
<p>输出<br>​    对于每组数据，输出一行。如果先取的TT可以赢得游戏，则输出“Win”，否则输出“Lose”（引号不用输出） </p>
<p>样例输入 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1000 1</span><br><span class="line">1 100</span><br></pre></td></tr></table></figure>
<p>样例输出 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Lose</span><br><span class="line"></span><br><span class="line">Win</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 巴什博弈</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> N, num, limit;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">	<span class="keyword">while</span>(N--)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;num, &amp;limit);</span><br><span class="line">		<span class="keyword">if</span>(num%(limit+<span class="number">1</span>)!=<span class="number">0</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Win\n"</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Lose\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>巴什博弈变形： </p>
<script type="math/tex; mode=display">
取石子（七） \\
时间限制：1000 ms  |  内存限制：65535 KB \\
难度：1</script><p>描述<br>​    Yougth和Hrdv玩一个游戏，拿出n个石子摆成一圈，Yougth和Hrdv分别从其中取石子，谁先取完者胜，每次可以从中取一个或者相邻两个，Hrdv先取，输出胜利着的名字。 </p>
<p>输入<br>​    输入包括多组测试数据。<br>​    每组测试数据一个n，数据保证int范围内。 </p>
<p>输出<br>​    输出胜利者的名字。 </p>
<p>样例输入 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>样例输出 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hrdv</span><br><span class="line">Yougth</span><br></pre></td></tr></table></figure>
<p>解题思路：假设石子数等于5，如果先者先取一个，那么后者拿走两个，将剩下的两个石子分成两堆，后者赢。如果先者先取二个，那么后者取一个使剩下的两个石子分成两堆，后者赢。假设石子数等于6，如果先者先取一个，那么后者拿走一个，将剩下的石子分成两段，每段两个，如果先者再拿两个，那么后者赢，如果先者再拿一个，那么后者再取另一堆中的一个，这样剩下的两个石子被分成两堆， 后者赢。         如果先者先取两个，那么后者也取两个使剩下的两个石子分成两堆，后者赢。所以当先者取走后，后者取走一个或者两个，将剩下的石子分成对称的两段，以此类推，那么如果石子数大于2后者一定赢。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">	<span class="keyword">int</span> n;  </span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF)  </span><br><span class="line">	&#123;  </span><br><span class="line">		<span class="keyword">if</span>(n &gt; <span class="number">2</span>)  </span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Yougth\n"</span>);  </span><br><span class="line">		<span class="keyword">else</span>  </span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Hrdv\n"</span>);  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="威佐夫博弈（Wythoff-Game）"><a href="#威佐夫博弈（Wythoff-Game）" class="headerlink" title="威佐夫博弈（Wythoff Game）"></a>威佐夫博弈（Wythoff Game）</h2><blockquote>
<p>问题模型：有两堆各若干个物品，两个人轮流从某一堆或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜。</p>
</blockquote>
<p>我们用（ak，bk）（ak ≤ bk ,k=0，1，2，…,n)表示两堆物品的数量并称其为局势，如果甲面对（0，0），那么甲已经输了，这种局势我们称为奇异局势。前几个奇异局势是：（0，0）、（1，2）、（3，5）、（4，7）、（6，10）、（8，13）、（9，15）、（11，18）、（12，20）。 可以看出,a0=b0=0,ak是未在前面出现过的最小自然数,而 bk= ak + k，奇异局势有如下三条性质： </p>
<ul>
<li>任何自然数都包含在一个且仅有一个奇异局势中。 </li>
<li>任意操作都可将奇异局势变为非奇异局势。 </li>
<li>采用适当的方法，可以将非奇异局势变为奇异局势。</li>
</ul>
<p>从如上性质可知，两个人如果都采用正确操作，那么面对非奇异局势，先拿者必胜；反之，则后拿者取胜。<br> 那么任给一个局势（a，b），怎样判断它是不是奇异局势呢？我们有如下公式： </p>
<script type="math/tex; mode=display">
a_k =[\frac {k(1+√5)}2]，b_k= a_k + k（k=0，1，2，...,n 方括号表示取整函数)</script><script type="math/tex; mode=display">
取石子 (四） \\
时间限制：1000 ms  |  内存限制：65535 KB \\
难度：4</script><p>描述<br>​    有两堆石子，数量任意，可以不同。游戏开始由两个人轮流取石子。游戏规定，每次有两种不同的取法，一是可以在任意的一堆中取走任意多的石子；二是可以在两堆中同时取走相同数量的石子。最后把石子全部取完者为胜者。现在给出初始的两堆石子的数目，如果轮到你先取，假设双方都采取最好的策略，问最后你是胜者还是败者。 </p>
<p>输入<br>​    输入包含若干行，表示若干种石子的初始情况，其中每一行包含两个非负整数a和b，表示两堆石子的数目，a和b都不大于1,000,000,000。 </p>
<p>输出<br>​    输出对应也有若干行，每行包含一个数字1或0，如果最后你是胜者，则为1，反之，则为0。 </p>
<p>样例输入 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 1</span><br><span class="line">8 4</span><br><span class="line">4 7</span><br></pre></td></tr></table></figure>
<p>样例输出 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m,n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n)&#123;</span><br><span class="line">		<span class="keyword">if</span>(m&gt;n)</span><br><span class="line">			swap(m,n);</span><br><span class="line">		<span class="keyword">int</span> k = n-m;</span><br><span class="line">		<span class="keyword">int</span> data = <span class="built_in">floor</span>(k*(<span class="number">1.0</span>+<span class="built_in">sqrt</span>(<span class="number">5.0</span>))/<span class="number">2.0</span>);</span><br><span class="line">		<span class="keyword">if</span>(data==m)</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
Wythoff Game \\
时间限制：1000 ms  |  内存限制：65535 KB \\
难度：1</script><p>描述<br>​    最近ZKC同学在学博弈，学到了一个伟大的博弈问题—威佐夫博弈。<br>​    相信大家都学过了吧？没学过？没问题。我将要为你讲述一下这个伟大的博弈问题。 有两堆石子，数量任意，可以不同。游戏开始由两个人轮流取石子。 游戏规定，每次有两种不同的取法：<br>一是可以在任意的一堆中取走任意多的石子； 二是可以在两堆中同时取走相同数量的石子。 最后把石子全部取完者为胜者。<br>​    我们今天要做的是求前n个必败态。<br>​    什么是必败态？比如我们把（a，b）称为一种状态，a，b分别为两堆石子中所剩的数目。如果a=0，b=0，我们说该种状态为必败态，因为我不能再进行游戏，即使是可以进行，那也是必败的，你知道，游戏的我们都是非常聪明的。（0,0）（1,2）（3,5）…都是必败态，我们今天要做的就是求前n个必败态。不会？好吧！<br>​    我再告诉你：假设第n个必败态为（a，b）a为前n-1个必败态中没有出现的最小自然数，b=a+n。这下大家应该明白了吧。好吧，我们的任务就的要前n个必败态。规定第0个必败态为（0,0）。 </p>
<p>输入<br>​    多组数据。<br>​    输入为一个数n（0&lt;=n&lt;=100000）。 </p>
<p>输出<br>​    按照要求求出前n个必败态。输出格式看下面样例。<br>样例输入 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>样例输出 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(0,0)(1,2)(3,5)(4,7)</span><br><span class="line">(0,0)(1,2)</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> a,b;</span><br><span class="line">&#125;N;</span><br><span class="line"></span><br><span class="line">N res[<span class="number">100001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	res[<span class="number">0</span>].a = <span class="number">0</span>;</span><br><span class="line">	res[<span class="number">0</span>].b = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">100001</span>; i++)&#123;</span><br><span class="line">		res[i].a = (<span class="number">1</span>+<span class="built_in">sqrt</span>(<span class="number">5</span>))*i/<span class="number">2</span>;</span><br><span class="line">		res[i].b = res[i].a+i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"(%d,%d)"</span>, res[i].a, res[i].b);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="尼姆博弈（Nimm-Game）"><a href="#尼姆博弈（Nimm-Game）" class="headerlink" title="尼姆博弈（Nimm Game）"></a>尼姆博弈（Nimm Game）</h2><blockquote>
<p>问题模型：有三堆各若干个物品，两个人轮流从某一堆取任意多的物品，规定每次至少取一个，多者不限，最后取光者得胜。</p>
</blockquote>
<p>用（a，b，c）表示某种局势，显证（0，0，0）是第一种奇异局势，无论谁面对奇异局势，都必然失败。第二种奇异局势是（0，n，n），只要与对手拿走一样多的物品，最后都将导致（0，0，0）。搞定这个问题需要把必败态的规律找出：(a,b,c)是必败态等价于a^b^c=0(^表示异或运算）。</p>
<script type="math/tex; mode=display">
取石子（二） \\
时间限制：3000 ms  |  内存限制：65535 KB \\
难度：5</script><p>描述<br>​    小王喜欢与同事玩一些小游戏，今天他们选择了玩取石子。 游戏规则如下：共有N堆石子，已知每堆中石子的数量，并且规定好每堆石子最多可以取的石子数（最少取1颗）。 </p>
<p>​    两个人轮流取子，每次只能选择N堆石子中的一堆，取一定数量的石子(最少取一个），并且取的石子数量不能多于该堆石子规定好的最多取子数，等哪个人无法取子时就表示此人输掉了游戏。 </p>
<p>​    假设每次都是小王先取石子，并且游戏双方都绝对聪明，现在给你石子的堆数、每堆石子的数量和每堆石子规定的单次取子上限，请判断出小王能否获胜。 </p>
<p>输入<br>​    第一行是一个整数T表示测试数据的组数(T&lt;100)<br>​    每组测试数据的第一行是一个整数N(1&lt;N&lt;100),表示共有N堆石子，随后的N行每行表示一堆石子，这N行中每行有两个数整数m,n表示该堆石子共有m个石子，该堆石子每次最多取n个。(0&lt;=m,n&lt;=2^31) </p>
<p>输出<br>​    对于每组测试数据，输出Win表示小王可以获胜，输出Lose表示小王必然会败。 </p>
<p>样例输入 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1 </span><br><span class="line">1000 1</span><br><span class="line">2</span><br><span class="line">1 1</span><br><span class="line">1 1</span><br></pre></td></tr></table></figure>
<p>样例输出 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Lose</span><br><span class="line">Lose</span><br></pre></td></tr></table></figure>
<p> 提示<br>​    注意下面一组测试数据 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 </span><br><span class="line">1 1</span><br><span class="line">2 2</span><br></pre></td></tr></table></figure>
<p>​    正确的结果应该是<code>Win</code><br>​    因为小王会先从第二堆石子中取一个石子，使状态变为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 1</span><br><span class="line"> 1 2</span><br></pre></td></tr></table></figure>
<p>​    这种状态下，无论对方怎么取，小王都能获胜。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		<span class="keyword">int</span> m,n,g,sum=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;g;</span><br><span class="line">		<span class="keyword">while</span>(g--)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n;</span><br><span class="line">			sum ^= m%(n+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;(sum? <span class="string">"Win"</span>:<span class="string">"Lose"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
取石子（三）\\
时间限制：1000 ms  |  内存限制：1000 KB\\
难度：6</script><p>描述<br>​    小王喜欢与同事玩一些小游戏，今天他们选择了玩取石子。游戏规则如下：共有N堆石子，已知每堆中石子的数量，两个人轮流取子，每次只能选择N堆石子中的一堆，取一定数量的石子（最少取一个），取过子之后，还可以将该堆石子中剩下的任意多个石子中随意选取几个放到其它的任意一堆或几堆上。等哪个人无法取子时就表示此人输掉了游戏。注意，一堆石子没有子之后，就不能再往此处放石子了。<br>​    假设每次都是小王先取石子，并且游戏双方都绝对聪明，现在给你石子的堆数、每堆石子的数量，请判断出小王能否获胜。<br>​    例如：如果最开始有4堆石子，石子个数分别为3 1 4 2，而小王想决定要先拿走第三堆石子中的两个石子（石子堆状态变为3 1 2 2），然后他可以使石子堆达到的状态有以下几种：<br>​    3 1 2 2（不再移动石子）<br>​    4 1 1 2（移动到第一堆一个）<br>​    3 2 1 2（移动到第二堆一个）<br>​    3 1 1 3（移动到第四堆一个）<br>​    5 1 0 2（全部移动到第一堆）<br>​    3 3 0 2（全部移动到第二堆）<br>​    3 1 0 4（全部移动到最后）</p>
<p>输入<br>​    可能有多组测试数据(测试数据组数不超过1000)<br>​    每组测试数据的第一行是一个整数，表示N(1&lt;=N&lt;=10)<br>​    第二行是N个整数分别表示该堆石子中石子的数量。（每堆石子数目不超过100）<br>​    当输入的N为0时，表示输入结束</p>
<p>输出<br>​    对于每组测试数据，输出Win表示小王可以获胜，输出Lose表示小王必然会败。</p>
<p>样例输入<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2 1 3</span><br><span class="line">2</span><br><span class="line">1 1</span><br><span class="line">0</span><br></pre></td></tr></table></figure></p>
<p>样例输出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Win</span><br><span class="line">Lose</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, ans, a;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n), n)&#123;</span><br><span class="line">		<span class="keyword">while</span>(n--)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">			++arr[a];</span><br><span class="line">		&#125;</span><br><span class="line">		ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1001</span>; ++i)</span><br><span class="line">			<span class="keyword">if</span>(arr[i] &amp; <span class="number">1</span>)&#123;</span><br><span class="line">				ans = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="built_in">printf</span>(ans ? <span class="string">"Win\n"</span> : <span class="string">"Lose\n"</span>);</span><br><span class="line">		<span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="keyword">sizeof</span>(arr));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程开发</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>算法笔记</tag>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/posts/61237.html</url>
    <content><![CDATA[<blockquote>
<p> 之前也有总结排序部分，但是总是忘记</p>
<p> 这段时间在整理算法笔记，所以借机再整理一份。</p>
<p> 主要整理的是八大内部排序，分析代码，时间复杂度等</p>
</blockquote>
<a id="more"></a>
<p>​         </p>
<p>排序分类见图：<br><img src="https://photo.hushhw.cn/images/algorithm_9_2.png" alt></p>
<p>各排序算法基本性能：<br><img src="https://photo.hushhw.cn/images/algorithm_9_3.png" alt></p>
<h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h2><h3 id="1-1-冒泡排序算法思想及代码实现"><a href="#1-1-冒泡排序算法思想及代码实现" class="headerlink" title="1.1 冒泡排序算法思想及代码实现"></a>1.1 冒泡排序算法思想及代码实现</h3><p>冒泡排序是一种交换排序，基本算法思想是重复访问要排序的数列，每趟排序过程中通过两两比较相邻元素，按一定顺序交换，直到没有在需要交换即数列排序完成。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">bubbleSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">list</span>.empty())&#123;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	result = <span class="built_in">list</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; result.size()<span class="number">-1</span>; ++i)&#123;		<span class="comment">//外层循环仅标记趟数</span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"第"</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">"趟排序:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j &lt; result.size()<span class="number">-1</span>; j++)&#123;	<span class="comment">//内层循环进行相邻数据交换</span></span><br><span class="line">			<span class="keyword">if</span>(result[j+<span class="number">1</span>] &lt; result[j])&#123;</span><br><span class="line">				swap(result[j+<span class="number">1</span>], result[j]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"排序中:"</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>; s&lt;result.size(); s++)&#123;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;result[s]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"排序结果:"</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>; s &lt; result.size(); s++)&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;result[s]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[] = &#123; <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span> &#125;;</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">test</span><span class="params">(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]))</span></span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"排序前"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.size(); i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; test[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">	result = bubbleSort(test);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"排序后"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; result[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-冒泡排序算法性能"><a href="#1-2-冒泡排序算法性能" class="headerlink" title="1.2 冒泡排序算法性能"></a>1.2 冒泡排序算法性能</h3><p>若文件的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数C和记录移动次数M均达到最小值：Cmin = N - 1, Mmin = 0。所以，<strong>冒泡排序最好时间复杂度为O(N)</strong>。<br>若初始文件是反序的，需要进行 N -1 趟排序。每趟排序要进行 N - i 次关键字的比较(1 ≤ i ≤ N - 1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：<br>$C<em>{max} = N(N-1)/2 = O(N^2)$<br>$M</em>{max} = 3N(N-1)/2 = O(N^2)$<br>冒泡排序的最坏时间复杂度为$O(N^2)$。<br>因此，冒泡排序的平均时间复杂度为$O(N^2)$。<br>总结起来，其实就是一句话：当数据越接近正序时，冒泡排序性能越好。</p>
<p>冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以相同元素的前后顺序并没有改变，所以冒泡排序是一种<strong>稳定排序算法</strong>。</p>
<h3 id="1-3-冒泡排序优化"><a href="#1-3-冒泡排序优化" class="headerlink" title="1.3 冒泡排序优化"></a>1.3 冒泡排序优化</h3><p>在上述代码中测试的数据会发现，早在第三趟就已经完成排序，但是还是执行了后面的四五六趟排序。对冒泡排序常见的改进方法是加入<strong>标志性变量exchange</strong>，用于标志某一趟排序过程中是否有数据交换。如果进行<strong>某一趟排序时并没有进行数据交换，则说明所有数据已经有序</strong>，可立即结束排序，避免不必要的比较过程。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">bubbleSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">list</span>.empty())&#123;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	result = <span class="built_in">list</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; result.size()<span class="number">-1</span>; ++i)&#123;		<span class="comment">//外层循环仅标记趟数</span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"第"</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">"趟排序:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="comment">/*----------冒泡排序优化代码1-----------*/</span></span><br><span class="line">		<span class="keyword">bool</span> bChanged = <span class="literal">false</span>;	<span class="comment">//交换标记</span></span><br><span class="line">		<span class="comment">/*----------冒泡排序优化代码1-----------*/</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j &lt; result.size()<span class="number">-1</span>; j++)&#123;	<span class="comment">//内层循环进行相邻数据交换</span></span><br><span class="line">			<span class="keyword">if</span>(result[j+<span class="number">1</span>] &lt; result[j])&#123;</span><br><span class="line">				swap(result[j+<span class="number">1</span>], result[j]);</span><br><span class="line">				<span class="comment">/*----------冒泡排序优化代码2-----------*/</span></span><br><span class="line">				bChanged = <span class="literal">true</span>;</span><br><span class="line">				<span class="comment">/*----------冒泡排序优化代码2-----------*/</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"排序中:"</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>; s&lt;result.size(); s++)&#123;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;result[s]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*----------冒泡排序优化代码3-----------*/</span></span><br><span class="line">		<span class="keyword">if</span>(bChanged == <span class="literal">false</span>)	<span class="comment">//如果标志为false,说明本轮遍历没有进行数据交换，即说明已经有序</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">/*----------冒泡排序优化代码3-----------*/</span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"排序结果:"</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>; s &lt; result.size(); s++)&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;result[s]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[] = &#123; <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span> &#125;;</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">test</span><span class="params">(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]))</span></span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"排序前"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.size(); i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; test[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">	result = bubbleSort(test);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"排序后"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; result[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-快速排序"><a href="#2-快速排序" class="headerlink" title="2. 快速排序"></a>2. 快速排序</h2><h3 id="2-1-快速排序算法思想及代码实现"><a href="#2-1-快速排序算法思想及代码实现" class="headerlink" title="2.1 快速排序算法思想及代码实现"></a>2.1 快速排序算法思想及代码实现</h3><p>快速排序也是一种交换排序。快速排序由C. A. R. Hoare在1962年提出。</p>
<p>它的基本思想是：通过一趟排序将要排序的数据<strong>分割</strong>成独立的两部分：<strong>分割点左边都是比它小的数，右边都是比它大的数</strong>。然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<p>算法步骤：</p>
<ul>
<li>选取主元</li>
<li>小于等于主元的放左边，大于等于主元的放右边</li>
<li>分别对左右边递归，即重复（1）、（2）步</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">division</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">list</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> base = <span class="built_in">list</span>[left];</span><br><span class="line">	<span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">		<span class="keyword">while</span>(left &lt; right &amp;&amp; <span class="built_in">list</span>[right]&gt;=base)<span class="comment">//从序号右端开始向左遍历，直到找到小于base的数</span></span><br><span class="line">			right--;</span><br><span class="line">		<span class="built_in">list</span>[left] = <span class="built_in">list</span>[right];	<span class="comment">//找到比base小的元素，将这个元素放到最左边的位置</span></span><br><span class="line">		<span class="keyword">while</span>(left &lt; right &amp;&amp; <span class="built_in">list</span>[left]&lt;=base) <span class="comment">//从序号左端开始向右遍历，直到找到大于base的数</span></span><br><span class="line">			left++;</span><br><span class="line">		<span class="built_in">list</span>[right] = <span class="built_in">list</span>[left];	<span class="comment">//找到比base大的元素，将这个元素放到最右边的位置</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">list</span>[left] = base;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"每一轮："</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>.size(); i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">list</span>[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">list</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(left &lt; right)&#123;	<span class="comment">//左下标一定小于右下标，否则越界</span></span><br><span class="line">		<span class="keyword">int</span> base = division(<span class="built_in">list</span>, left, right);<span class="comment">//对数组进行分割，去除下次分割的基准标号</span></span><br><span class="line">		QuickSort(<span class="built_in">list</span>, left, base<span class="number">-1</span>);<span class="comment">//左</span></span><br><span class="line">		QuickSort(<span class="built_in">list</span>, base+<span class="number">1</span>, right);<span class="comment">//右</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[] = &#123; <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">test</span><span class="params">(arr, arr + <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]))</span></span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"排序前"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.size(); i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; test[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result = test;</span><br><span class="line"></span><br><span class="line">	QuickSort(result, <span class="number">0</span>, result.size() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"排序后"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; result[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-快速排序算法性能"><a href="#2-2-快速排序算法性能" class="headerlink" title="2.2 快速排序算法性能"></a>2.2 快速排序算法性能</h3><p>时间复杂度上：</p>
<p>最好的情况，每次我们运行一次分区，我们会把一个数组分为两个几近相等的片段。这个意思就是每次递归调用处理一半大小的数组。则会有关系式：</p>
<script type="math/tex; mode=display">
T(n)=2T(\frac n 2)+O(n)</script><p>解出 $T_{best}(n)=O(nlogn)$。</p>
<p>最坏的情况，在分割后，两子数组总是拥有各为 1 和 n-1 长度的数组，则递归关系式变为：</p>
<script type="math/tex; mode=display">
T(n)=T(n−1)+O(n)+O(1)=T(n−1)+O(n)</script><p>解出 $T_{worst}(n)=O(n^2)$。</p>
<p>空间复杂度上：</p>
<p>快速排序在每次分割的过程中，需要 1 个空间存储基准值。而快速排序的大概需要Nlog2N次的分割处理，所以占用空间也是 Nlog2N 个。</p>
<p>算法稳定性上：</p>
<p>在快速排序中，相等元素可能会因为分区而交换顺序，所以它是不稳定的算法。</p>
<h3 id="2-3-快速排序细节优化"><a href="#2-3-快速排序细节优化" class="headerlink" title="2.3 快速排序细节优化"></a>2.3 快速排序细节优化</h3><p>我们知道主元的大小直接决定快排的效率，因为数组的划分需要依靠主元，理想状态下，给定的主元正好可以把数组分为长度相等的两个子数组，但找到并确定这样的主元还需要耗费额外的时间，如此一来，得不偿失。</p>
<p>快速排序算法有三种选择主元的方法：</p>
<ol>
<li>取序列中的第一个或最后一个元素作为主元<em>（前面实现的就是这种）</em></li>
<li>取序列中任意一个元素作为主元</li>
<li>选取左，中，右三个元素的 “中值” 为主元</li>
</ol>
<h2 id="3-直接插入排序"><a href="#3-直接插入排序" class="headerlink" title="3. 直接插入排序"></a>3. 直接插入排序</h2><h3 id="3-1-插入排序算法思想及代码实现"><a href="#3-1-插入排序算法思想及代码实现" class="headerlink" title="3.1 插入排序算法思想及代码实现"></a>3.1 插入排序算法思想及代码实现</h3><p>每一趟将一个待排序的记录，按照其关键字的大小插入到有序队列的合适位置里，直到全部插入完成。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">insertSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">list</span>.empty())&#123;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	result = <span class="built_in">list</span>;</span><br><span class="line">	<span class="comment">// 第1个数肯定是有序的，从第2个数开始遍历，依次插入有序序列</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line">		<span class="comment">// 取出第i个数，和前i-1个数比较后，插入合适位置</span></span><br><span class="line">		<span class="keyword">int</span> temp = result[i];</span><br><span class="line">		<span class="comment">// 因为前i-1个数都是从小到大的有序序列，所以只要当前比较的数(res[j])比temp大，就把这个数后移一位</span></span><br><span class="line">		<span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (j; j &gt;= <span class="number">0</span> &amp;&amp; result[j] &gt; temp; j--)&#123;</span><br><span class="line">			result[j + <span class="number">1</span>] = result[j];</span><br><span class="line">		&#125;</span><br><span class="line">		result[j + <span class="number">1</span>] = temp;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"第"</span>&lt;&lt;i&lt;&lt;<span class="string">"轮:"</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; result[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[] = &#123; <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span> &#125;;</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">test</span><span class="params">(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]))</span></span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"排序前"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.size(); i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; test[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">	result = insertSort(test);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"排序后"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; result[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-插入排序算法性能"><a href="#3-2-插入排序算法性能" class="headerlink" title="3.2 插入排序算法性能"></a>3.2 插入排序算法性能</h3><p>那么它的算法复杂度如下（参考<a href="https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F#.E7.AE.97.E6.B3.95.E5.A4.8D.E6.9D.82.E5.BA.A6" target="_blank" rel="noopener">维基百科</a>）：</p>
<ul>
<li>时间复杂度<ul>
<li>最好情况，序列是升序排列，在这种情况下，只需进行 $n-1$ 比较，即 $T_{best}(n)=O(n)$；</li>
<li>最坏情况，序列是降序排列，那么此时需要进行的比较共有 $\frac 12n(n−1)$ 次，即 $T_{worse}(n)=O(n^2)$；</li>
<li>平均情况，为 $T_{avg}(n)=O(n^2)$。</li>
</ul>
</li>
<li>空间复杂度<ul>
<li>由程序很容易得我们在排序过程中，需要一个临时变量存储要插入的值，所以空间复杂度为 S(n)=O(1)。</li>
</ul>
</li>
</ul>
<p>它的算法稳定性：直接插入排序的过程中，不需要改变相等数值元素的位置，所以它是<strong>稳定的</strong>算法。</p>
<h2 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4. 希尔排序"></a>4. 希尔排序</h2><h3 id="4-1-希尔排序算法思想及代码实现"><a href="#4-1-希尔排序算法思想及代码实现" class="headerlink" title="4.1 希尔排序算法思想及代码实现"></a>4.1 希尔排序算法思想及代码实现</h3><p>希尔(Shell)排序又称为<strong>缩小增量排序</strong>，它是一种<strong>插入排序</strong>。它<strong>是直接插入排序算法的一种威力加强版</strong>。该方法因DL．Shell于1959年提出而得名。</p>
<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：（以下摘自<a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">维基百科</a>）</p>
<ul>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到<a href="https://zh.wikipedia.org/w/index.php?title=%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">线性排序</a>的效率</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</li>
</ul>
<p>希尔排序的<strong>基本思想</strong>是：</p>
<p>把记录按<strong>步长</strong> gap 分组，对每组记录采用<strong>直接插入排序</strong>方法进行排序。<br>随着<strong>步长逐渐减小</strong>，所分成的组包含的记录越来越多，当步长的值减小到 <strong>1</strong> 时，整个数据合成为一组，构成一组有序记录，则完成排序。</p>
<p>举例：假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样：</p>
<p><code>13 14 94 33 82</code><br><code>25 59 94 65 23</code><br><code>45 27 73 25 39</code><br><code>10</code></p>
<p>然后我们对每列进行排序：</p>
<p><code>10 14 73 25 23</code><br><code>13 27 94 33 39</code><br><code>25 59 94 65 82</code><br><code>45</code></p>
<p>将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ].这时10已经移至正确位置了，然后再以3为步长进行排序：</p>
<p><code>10 14 73</code><br><code>25 23 13</code><br><code>27 94 33</code><br><code>39 25 59</code><br><code>94 65 82</code><br><code>45</code></p>
<p>排序之后变为：</p>
<p><code>10 14 13</code><br><code>25 23 33</code><br><code>27 25 59</code><br><code>39 65 73</code><br><code>45 94 82</code><br><code>94</code></p>
<p>最后以1步长进行排序（此时就是简单的插入排序了）。</p>
<p>可想而知，步长的选择是希尔排序的重要部分。算法最开始以一定的步长进行排序，然后会继续以更小的步长进行排序，最终算法以步长为 1 进行排序。当步长为 1 时，算法变为直接插入排序，这就保证了数据一定会被全部排序。</p>
<p>下面以$\frac n{2^i}$作为步长为例进行讲解。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ShellSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">	result = <span class="built_in">list</span>;</span><br><span class="line">	<span class="keyword">int</span> n = result.size();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> gap = n &gt;&gt; <span class="number">1</span>; gap &gt; <span class="number">0</span>; gap &gt;&gt;= <span class="number">1</span>)&#123;	<span class="comment">//对n进行二分除二处理</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=gap; i&lt;n; i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> temp = result[i];	<span class="comment">//记录i所在的数</span></span><br><span class="line">			<span class="keyword">int</span> j;</span><br><span class="line">			<span class="keyword">for</span>(j = i-gap; j&gt;=<span class="number">0</span> &amp;&amp; result[j]&gt;temp; j -= gap)&#123;<span class="comment">//把相距为gap的i,j所在数字比较，相当于隔行判断</span></span><br><span class="line">				result[j+gap] = result[j];</span><br><span class="line">			&#125;</span><br><span class="line">			result[j+gap] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[] = &#123; <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span> &#125;;</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">test</span><span class="params">(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]))</span></span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"排序前"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.size(); i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; test[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">	result = ShellSort(test);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"排序后"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; result[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-希尔排序算法性能"><a href="#4-2-希尔排序算法性能" class="headerlink" title="4.2 希尔排序算法性能"></a>4.2 希尔排序算法性能</h3><p>那么它的算法复杂度如下（参考<a href="https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F#.E7.AE.97.E6.B3.95.E5.A4.8D.E6.9D.82.E5.BA.A6" target="_blank" rel="noopener">维基百科</a>）：</p>
<p>步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。</p>
<p>算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为1进行排序。当步长为1时，算法变为插入排序，这就保证了数据一定会被排序。<br>Donald Shell 最初建议步长选择为N/2并且对步长取半直到步长达到1。虽然这样取可以比O(N2)类的算法（插入排序）更好，但这样仍然有减少平均时间和最差时间的余地。可能希尔排序最重要的地方在于当用较小步长排序后，以前用的较大步长仍然是有序的。比如，如果一个数列以步长5进行了排序然后再以步长3进行排序，那么该数列不仅是以步长3有序，而且是以步长5有序。如果不是这样，那么算法在迭代过程中会打乱以前的顺序，那就</p>
<p>不会以如此短的时间完成排序了。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">步长序列</th>
<th style="text-align:center">最坏情况下复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$\frac n{2^i}$</td>
<td style="text-align:center">$O(n^2)$</td>
</tr>
<tr>
<td style="text-align:center">$2^i-1$</td>
<td style="text-align:center">$O(n^{\frac 32})$</td>
</tr>
<tr>
<td style="text-align:center">$2^i3^i$</td>
<td style="text-align:center">$O(nlog^2n)$</td>
</tr>
</tbody>
</table>
</div>
<p>已知的最好步长序列是由Sedgewick提出的(1, 5, 19, 41, 109,…)，该序列的项来自$9<em>4^i-9</em>2^i$和$2^{i+2}*(2^{i+2}-3)+1$这两个算式。这项研究也表明“比较在希尔排序中是最主要的操作，而不是交换。”用这样步长序列的希尔排序比插入排序和堆排序都要快，甚至在小数组中比快速排序还快，但是在涉及大量数据时希尔排序还是比快速排序慢。</p>
<p>它的算法稳定性：希尔排序中相等数据可能会交换位置，所以希尔排序是<strong>不稳定</strong>的算法。</p>
<h3 id="4-3-希尔排序和直接插入排序比较"><a href="#4-3-希尔排序和直接插入排序比较" class="headerlink" title="4.3 希尔排序和直接插入排序比较"></a>4.3 希尔排序和直接插入排序比较</h3><p>直接插入排序是<strong>稳定的</strong>；而希尔排序是<strong>不稳定</strong>的。</p>
<p>直接插入排序更适合于原始记录基本<strong>有序</strong>的集合。</p>
<p>希尔排序的比较次数和移动次数都要比直接插入排序少，当N越大时，效果越明显。   </p>
<p>在希尔排序中，增量序列gap的取法必须满足：<strong>最后一个步长必须是1</strong>。</p>
<p>直接插入排序也<strong>适用于链式存储结构</strong>；希尔排序<strong>不适用于链式结构</strong>。</p>
<h2 id="5-简单选择排序"><a href="#5-简单选择排序" class="headerlink" title="5. 简单选择排序"></a>5. 简单选择排序</h2><h3 id="5-1-简单选择排序算法思想及代码实现"><a href="#5-1-简单选择排序算法思想及代码实现" class="headerlink" title="5.1 简单选择排序算法思想及代码实现"></a>5.1 简单选择排序算法思想及代码实现</h3><p>简单选择排序是一种<strong>选择排序</strong>。</p>
<p><strong>选择排序</strong>：每趟从待排序的记录中选出关键字最小的记录，顺序放在已排序的记录序列末尾，直到全部排序结束为止。</p>
<p>简单排序很简单，它的大致处理流程为：</p>
<ul>
<li>从待排序序列中，找到关键字最小的元素；</li>
<li>如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；</li>
<li>从余下的 N - 1 个元素中，找出关键字最小的元素，重复(1)、(2)步，直到排序结束。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">SelectSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">	result = <span class="built_in">list</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;result.size(); i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> index = i;		<span class="comment">//标记第一个位置</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;result.size(); j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(result[index] &gt; result[j])</span><br><span class="line">				index = j;	<span class="comment">//如果比index位置上的数字小，就标记该数字</span></span><br><span class="line">		&#125;</span><br><span class="line">		swap(result[i], result[index]);	<span class="comment">//循环结束后把标记的最小数字所在位置index和i位置交换</span></span><br><span class="line">		</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"第"</span> &lt;&lt; i + <span class="number">1</span>&lt;&lt; <span class="string">"趟:\t"</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; result[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[] = &#123; <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span> &#125;;</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">test</span><span class="params">(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]))</span></span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"排序前"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.size(); i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; test[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">	result = SelectSort(test);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"排序后"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; result[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-2-简单选择排序算法性能"><a href="#5-2-简单选择排序算法性能" class="headerlink" title="5.2 简单选择排序算法性能"></a>5.2 简单选择排序算法性能</h3><p>那么它的算法复杂度如下：</p>
<ul>
<li><p>时间复杂度</p>
<p>简单选择排序的比较次数与序列的初始排序无关。 假设待排序的序列有 N 个元素，则比较次数总是$\frac {N (N - 1) }2$。</p>
<p>简单排序的时间复杂度为 $O(N^2)$。</p>
</li>
<li><p>空间复杂度</p>
<ul>
<li>由程序很容易得我们在排序过程中，需要一个临时变量存储要插入的值，所以空间复杂度为 S(n)=O(1)。</li>
</ul>
</li>
</ul>
<h2 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6. 堆排序"></a>6. 堆排序</h2><h3 id="6-1-堆排序算法思想及代码实现"><a href="#6-1-堆排序算法思想及代码实现" class="headerlink" title="6.1 堆排序算法思想及代码实现"></a>6.1 堆排序算法思想及代码实现</h3><p>堆排序是利用堆的性质进行的一种选择排序。下面先讨论一下堆。</p>
<p>堆实际上是一棵完全二叉树，其满足性质：任何一结点大于等于或者小于等于其左右子树结点。</p>
<p>堆分为大顶堆和小顶堆，满足 “任何一结点大于等于其左右子树结点” 的称为大顶堆，满足 “任何一结点小于等于其左右子树结点” 的称为小顶堆。由上述性质可知：大顶堆的堆顶肯定是最大的，小顶堆的堆顶是最小的。</p>
<p>堆排序可以归纳出两个操作：</p>
<ul>
<li>根据初始数组去<strong>构造初始堆</strong>（构建一个完全二叉树，保证所有的父结点都比它的孩子结点数值大）。</li>
<li>每次<strong>交换第一个和最后一个元素，输出最后一个元素</strong>（最大值），然后把剩下元素<strong>重新调整</strong>为大根堆。</li>
</ul>
<p>要解决的问题可以在代码中理解：</p>
<ul>
<li>如何确定最后一个非叶子结点？</li>
</ul>
<p>其实这是有一个公式的，设二叉树结点总数为 n，则最后一个非叶子结点是第$\frac n2$个。</p>
<ul>
<li>数组当中如何确定当前结点的左右孩子位置？</li>
</ul>
<p>设当前结点下标是 i，则其左孩子的下标是 2i，右孩子的下标是 2i+1。请注意：这是建立在数组下标从 1 开始的情况。若数组下标从 0 开始，则其左右孩子下标还各需多加一个 1。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">list</span>, <span class="keyword">int</span> start, <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> parent = start;			<span class="comment">//父节点</span></span><br><span class="line">	<span class="keyword">int</span> child = <span class="number">2</span> * parent + <span class="number">1</span>;	<span class="comment">// 先获得左孩子</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (child &lt;= length)&#123;	</span><br><span class="line">		<span class="comment">// 如果有右子节点，并且右子节点的值大于左子节点，则选取右子节点，否则选取左节点</span></span><br><span class="line">		<span class="keyword">if</span> (child + <span class="number">1</span> &lt;= length &amp;&amp; <span class="built_in">list</span>[child] &lt; <span class="built_in">list</span>[child + <span class="number">1</span>])&#123;</span><br><span class="line">			child++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果父节点大于孩子节点则代表调整完毕，直接跳出函数</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">list</span>[parent] &gt; <span class="built_in">list</span>[child])&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123; <span class="comment">//否则交换父子内容再继续子节点和孙节点比较</span></span><br><span class="line">			swap(<span class="built_in">list</span>[parent], <span class="built_in">list</span>[child]);</span><br><span class="line">			parent = child;<span class="comment">//父更新为子节点位置</span></span><br><span class="line">			child = parent*<span class="number">2</span>+<span class="number">1</span>;<span class="comment">//子节点更新为孙节点位置</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">HeadSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> length = <span class="built_in">list</span>.size();</span><br><span class="line">	<span class="comment">// 循环建立初始堆，i从最后一个父节点开始</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = length/<span class="number">2</span><span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">		HeapAdjust(<span class="built_in">list</span>, i, length<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>.size(); i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">list</span>[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 进行n-1次循环，完成排序</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">		<span class="comment">// 最后一个元素和第一元素进行交换</span></span><br><span class="line">		swap(<span class="built_in">list</span>[<span class="number">0</span>], <span class="built_in">list</span>[i]);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 筛选 R[0] 结点，得到i-1个结点的堆</span></span><br><span class="line">		HeapAdjust(<span class="built_in">list</span>, <span class="number">0</span>, i<span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"第"</span> &lt;&lt; length - i &lt;&lt; <span class="string">"趟排序:"</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>.size(); i++)&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="built_in">list</span>[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[] = &#123; <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span> &#125;;</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">test</span><span class="params">(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]))</span></span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"排序前:"</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.size(); i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; test[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">	result = HeadSort(test);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"排序后:"</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; result[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-2-堆排序算法性能"><a href="#6-2-堆排序算法性能" class="headerlink" title="6.2 堆排序算法性能"></a>6.2 堆排序算法性能</h3><p>堆的存储表示是<strong>顺序的</strong>。因为堆所对应的二叉树为完全二叉树，而完全二叉树通常采用顺序存储方式。</p>
<p>当想得到一个序列中第<strong>k</strong>个最小的元素之前的部分排序序列，最好采用堆排序。</p>
<p>时间复杂度为 $O(nlogn)$，证明如下。</p>
<p>首先计算建堆的时间，也就是下面的代码，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 循环建立初始堆，i从最后一个父节点开始</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = length/<span class="number">2</span><span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">		HeapAdjust(<span class="built_in">list</span>, i, length<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>n 个结点，从第 0 层至第 $log_2n$ 层。对于第$i$层的$2^i$个点如果需要往下走$log_2n−i$步，那么把走的所有步相加得， </p>
<script type="math/tex; mode=display">
T(n) = \sum _{i=0}^{i=log_2n}{2^i(log_2n-i)}= 2n-log_2n-2<2n=O(n)</script><p>接下来就是排序的时间，即下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">	<span class="comment">// 最后一个元素和第一元素进行交换</span></span><br><span class="line">	swap(<span class="built_in">list</span>[<span class="number">0</span>], <span class="built_in">list</span>[i]);</span><br><span class="line">	<span class="comment">// 筛选 R[0] 结点，得到i-1个结点的堆</span></span><br><span class="line">	HeapAdjust(<span class="built_in">list</span>, <span class="number">0</span>, i<span class="number">-1</span>);</span><br></pre></td></tr></table></figure>
<p>HeapAdjust() 耗时$logn$，共$n$次，故排序时间为$O(nlogn)$。</p>
<p>综上所述，堆排序时间复杂度为$T(n)=O(n)+O(nlogn)=O(nlogn)$。</p>
<p>算法稳定度：</p>
<p>堆排序是一种<strong>不稳定</strong>的排序方法。</p>
<p>因为在堆的调整过程中，关键字进行比较和交换所走的是该结点到叶子结点的一条路径，因此对于相同的关键字就可能出现排在后面的关键字被交换到前面来的情况。</p>
<h2 id="7-归并排序"><a href="#7-归并排序" class="headerlink" title="7. 归并排序"></a>7. 归并排序</h2><h3 id="7-1-归并排序算法思想及代码实现"><a href="#7-1-归并排序算法思想及代码实现" class="headerlink" title="7.1 归并排序算法思想及代码实现"></a>7.1 归并排序算法思想及代码实现</h3><p>归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用<strong>分治法（Divide and Conquer）</strong>的一个非常典型的应用。</p>
<p>将待排序序列R[0…n-1]看成是n个长度为1的有序序列，将相邻的有序表成对归并，得到n/2个长度为2的有序表；将这些有序序列再次归并，得到n/4个长度为4的有序序列；如此反复进行下去，最后得到一个长度为n的有序序列。</p>
<p>综上可知：</p>
<p>归并排序其实要做两件事：</p>
<p>（1）“分解”——将序列每次<strong>折半划分</strong>。</p>
<p>（2）“合并”——将划分后的序列段<strong>两两合并后排序</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;input, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=left;</span><br><span class="line">	<span class="keyword">int</span> j=mid+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=right)&#123;</span><br><span class="line">		<span class="keyword">if</span>(input[i]&lt;=input[j])&#123;</span><br><span class="line">			temp[k++] = input[i++];</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			temp[k++] = input[j++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=mid)</span><br><span class="line">		temp[k++]=input[i++];</span><br><span class="line">	<span class="keyword">while</span>(j&lt;=right)</span><br><span class="line">		temp[k++]=input[j++];</span><br><span class="line">	k=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">		input[left++] = temp[k++];</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;input[left<span class="number">-1</span>]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;input, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">		<span class="keyword">int</span> mid = (left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		MergeSort(input, left, mid, temp);</span><br><span class="line">		MergeSort(input, mid+<span class="number">1</span>, right, temp);</span><br><span class="line">		Merge(input, left, mid ,right, temp);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[] = &#123; <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">test</span><span class="params">(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]))</span></span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"排序前:"</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.size(); i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; test[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result = test;</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">temp</span><span class="params">(result.size())</span></span>;<span class="comment">// 在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间</span></span><br><span class="line">	MergeSort(result, <span class="number">0</span>, result.size()<span class="number">-1</span>, temp);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"排序后:"</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; result[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-2-归并排序算法性能"><a href="#7-2-归并排序算法性能" class="headerlink" title="7.2 归并排序算法性能"></a>7.2 归并排序算法性能</h3><p>归并排序的时间复杂度分析：MergeSort()函数用于数组划分，Merge()函数用于合并。</p>
<ul>
<li>合并函数Merge()的时间复杂度为$O(n)$，因为代码中有2个长度为n的循环（非嵌套）</li>
<li>划分函数MergeSort()中，简单的分析一下元素长度为n的归并排序所消耗的时间为T(n)：调用MergeSort()函数划分两部分，那每一小部分所花销的时间则是$T[\frac n2]$</li>
</ul>
<p>最后两部分合并:（用迭代法进行推导）</p>
<script type="math/tex; mode=display">
\begin{align}
T[n]& = 2T[\frac n2]+O(n)
\\令：n=\frac n2\quad &=2(2T[\frac n4]+\frac n2)+n
\\&=2^2T[\frac n{2^2}]+2n
\\令：n=\frac n{2^2}\quad&=2^2(2T[\frac n{2^3}]+\frac n{2^2})+2n
\\&=2^3T[\frac n{2^3}]+3n
\\&……
\\令：n=\frac n{2^{m-1}}\quad&=2^mT[1]+mn
\\经过m次递归后，&当最后平分的不能再平分
\\到最后得到T[1]时，&说明这个公式已经迭代完了（T[1]是常量了）
\\得到：T[\frac n{2^m}]=T[1]\quad &==>\ n=2^m\quad ==>\ m=logn
\\T[n]&=2^mT[1]+mn\qquad 其中m=logn；
\\T[n]&=2^{logn}T[1]+nlogn
\\&=nT[1]+nlogn
\\&=n+nlogn
\end{align}</script><p>综上所述：归并排序时间复杂度为：$O(nlogn)$。</p>
<p>因为不管元素在什么情况下都要做这些步骤，所以花销的时间是不变的，所以该算法的最优时间复杂度和最差时间复杂度及平均时间复杂度都是一样的为：$O(nlogn)$。</p>
<p>归并排序的空间复杂度：</p>
<p>归并的空间复杂度就是那个临时的数组和递归时压入栈的数据占用的空间：n+logn；所以空间复杂度为: O(n)</p>
<p>归并排序的算法稳定度：</p>
<p>在归并排序中，相等的元素的顺序不会改变，所以它是<strong>稳定的</strong>算法。</p>
<h2 id="8-基数排序"><a href="#8-基数排序" class="headerlink" title="8. 基数排序"></a>8. 基数排序</h2><h3 id="8-1-基数排序算法思想及代码实现"><a href="#8-1-基数排序算法思想及代码实现" class="headerlink" title="8.1 基数排序算法思想及代码实现"></a>8.1 基数排序算法思想及代码实现</h3><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p>
<p>算法步骤：</p>
<ul>
<li>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。</li>
<li>从最低位开始，依次进行一次排序。</li>
<li>这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</li>
</ul>
<p>基数排序的方式可以采用 LSD（Least significant digital）或 MSD（Most significant digital），LSD 的排序方式由键值的最右边开始，而 MSD 则相反，由键值的最左边开始。</p>
<p>不妨通过一个具体的实例来展示一下基数排序是如何进行的。 设有一个初始序列为: R {50, 123, 543, 187, 49, 30, 0, 2, 11, 100}。</p>
<p>我们知道，任何一个阿拉伯数，它的各个位数上的基数都是以 0~9 来表示的，所以我们不妨把 0~9 视为 10 个桶。</p>
<p>我们先根据序列的个位数的数字来进行分类，将其分到指定的桶中。例如：R[0] = 50，个位数上是 0，将这个数存入编号为 0 的桶中。</p>
<p><img src="https://61mon.com/images/illustrations/Sort/10.png" alt="img"></p>
<p>分类后，我们在从各个桶中，将这些数按照从编号 0 到编号 9 的顺序依次将所有数取出来。这时，得到的序列就是个位数上呈递增趋势的序列。</p>
<p>按照个位数排序： {50, 30, 0, 100, 11, 2, 123, 543, 187, 49}。</p>
<p>接下来，可以对十位数、百位数也按照这种方法进行排序，最后就能得到排序完成的序列。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求出数组中最大数的位数的函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxBit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 数组最大值</span></span><br><span class="line">	<span class="keyword">int</span> max_data = input[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; input.size(); i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (input[i] &gt; max_data)&#123;</span><br><span class="line">			max_data = input[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"max_data:"</span>&lt;&lt;max_data&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 数组最大值的位数</span></span><br><span class="line">	<span class="keyword">int</span> bits_num = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (max_data)&#123;</span><br><span class="line">		bits_num++;</span><br><span class="line">		max_data /= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"bits_num:"</span>&lt;&lt;bits_num&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> bits_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">RadixSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">bucket</span><span class="params">(n)</span></span>;	<span class="comment">//存储排序过程中的数据</span></span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">10</span>)</span></span>;	<span class="comment">//位计数器，从第0个元素到第9个元素依次用来记录当前比较位是0的有多少个...是9的有多少个数</span></span><br><span class="line">	<span class="keyword">int</span> bits_num = MaxBit(input); <span class="comment">//求出数组中最大数的位数的函数</span></span><br><span class="line">	<span class="keyword">int</span> radix = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 从低位往高位循环</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">1</span>; d &lt;= bits_num; d++)&#123; </span><br><span class="line">		<span class="comment">// 计数器清0</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">			count[i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">// 统计各个桶中的个数</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> k=(input[i]/radix)%<span class="number">10</span>;<span class="comment">//取每个数字的末尾</span></span><br><span class="line">			count[k]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"before:"</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;count[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"after:   "</span>;</span><br><span class="line">		<span class="comment">//索引重分配</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">			count[i] += count[i - <span class="number">1</span>];<span class="comment">//count[i]表示第i个桶的右边界索引</span></span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;count[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//放入临时数组，从右到左扫描，保证排序稳定性</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">			<span class="keyword">int</span> k = (input[i]/radix)%<span class="number">10</span>;</span><br><span class="line">			bucket[count[k] - <span class="number">1</span>] = input[i];</span><br><span class="line">			count[k]--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"input:"</span>;</span><br><span class="line">		<span class="comment">// 临时数组复制到 input 中</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">			input[i] = bucket[i];</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;input[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		radix *= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> input;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[] = &#123; <span class="number">50</span>, <span class="number">123</span>, <span class="number">543</span>, <span class="number">187</span>, <span class="number">49</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">100</span> &#125;;</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">test</span><span class="params">(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]))</span></span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"排序前:"</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.size(); i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; test[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result = test;</span><br><span class="line">	result = RadixSort(result, result.size());</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"排序后:"</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; result[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-2-基数排序算法性能"><a href="#8-2-基数排序算法性能" class="headerlink" title="8.2 基数排序算法性能"></a>8.2 基数排序算法性能</h3><p>基数排序的时间复杂度是$O(k⋅n)$，其中$n$是排序元素个数，$k$是最大的数字位数。</p>
<p>空间复杂度是使用了两个临时的数组：10 + length；所以空间复杂度：$O(n)$</p>
<p>在基数排序过程中，每次都是将当前位数上相同数值的元素统一“装桶”，并不需要交换位置。所以基数排序是<strong>稳定</strong>的算法。</p>
<blockquote>
<p>本文参考整理自：</p>
<p><a href="http://cuijiahua.com/blog/2018/01/alogrithm_9.html" target="_blank" rel="noopener">http://cuijiahua.com/blog/2018/01/alogrithm_9.html</a></p>
<p><a href="https://61mon.com/index.php/archives/193/" target="_blank" rel="noopener">https://61mon.com/index.php/archives/193/</a></p>
<p><a href="http://www.cnblogs.com/jingmoxukong/p/4311237.html" target="_blank" rel="noopener">http://www.cnblogs.com/jingmoxukong/p/4311237.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>算法笔记</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集的使用及实现</title>
    <url>/posts/f4151f32.html</url>
    <content><![CDATA[<blockquote>
<p>并查集是一种用来管理元素分组情况的数据结构。并查集可以高效地进行如下操作。不过需要注意并查集虽然可以进行合并操作，但是无法进行分割操作。</p>
<ul>
<li>查询元素a和元素b是否属于同一组。</li>
<li>合并元素a和元素b所在的组。</li>
</ul>
</blockquote>
<p>详见这篇博文：<a href="http://blog.csdn.net/niushuai666/article/details/6662911" target="_blank" rel="noopener">超有爱的并查集</a></p>
<p>​          </p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>并查集由三部分组成：一个数组和两个函数</p>
<ul>
<li>数组pre[]，用来存储前导点</li>
<li>find()函数，用于寻找前导点</li>
<li>join()函数，用于合并线路</li>
</ul>
<p>具体代码实现：</p>
<ol>
<li><p>初始化pre[]数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> pre[<span class="number">1000</span>];</span><br><span class="line"><span class="comment">//初始化pre数组，让他们的前导点都记录为自己，即自己为根节点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123; </span><br><span class="line">	pre[i]=i; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>find()函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> r=x;</span><br><span class="line">  <span class="keyword">while</span>(pre[r]!=r)<span class="comment">//如果r的上级不是自己</span></span><br><span class="line">	r=pre[r];<span class="comment">//那么r等于它的前导点，继续寻找，直到找到根节点</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//下面这段起到路径压缩的作用</span></span><br><span class="line">  <span class="keyword">int</span> i=x; <span class="keyword">int</span> j;</span><br><span class="line">  <span class="keyword">while</span>(i!=r)&#123;<span class="comment">//如果当前查找的不是根结点（pre指向自己）</span></span><br><span class="line">	j=pre[i];<span class="comment">//在改变上级之前用临时变量j记录下他的值</span></span><br><span class="line">	pre[i]=r;<span class="comment">//更新前导点直接指向根节点</span></span><br><span class="line">	i=j;<span class="comment">//让i指向其前导点，在下一次循环里面就会更新其前导点指向根节点</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>join()函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> p1,<span class="keyword">int</span> p2)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> f1,f2;</span><br><span class="line">  f1 = find(p1);</span><br><span class="line">  f2 = find(p2); <span class="comment">//分别查找根节点</span></span><br><span class="line">  <span class="comment">//如果是不连通的，那么把这两个分支连起来</span></span><br><span class="line">  <span class="keyword">if</span>(f1!=f2)&#123;</span><br><span class="line">  	pre[f1]=f2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>​           </p>
<h3 id="具体代码实例"><a href="#具体代码实例" class="headerlink" title="具体代码实例"></a>具体代码实例</h3><p>【hdu1232】畅通工程</p>
<blockquote>
<p>畅通工程<br><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1232" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1232</a><br>Time Limit: 4000/2000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)<br>Total Submission(s): 61184    Accepted Submission(s): 32757</p>
<p>Problem Description<br>某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。<br>省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？ </p>
<p>Input<br>测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( &lt; 1000 )和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。<br>注意:两个城市之间可以有多条道路相通,也就是说<br>3 3<br>1 2<br>1 2<br>2 1<br>这种输入也是合法的<br>当N为0时，输入结束，该用例不被处理。 </p>
<p>Output<br>对每个测试用例，在1行里输出最少还需要建设的道路数目。 </p>
<p>Sample Input<br>4 2<br>1 3<br>4 3<br>3 3<br>1 2<br>1 3<br>2 3<br>5 2<br>1 2<br>3 5<br>999 0<br>0</p>
<p>Sample Output<br>1<br>0<br>2<br>998</p>
</blockquote>
<p>分析：见代码注释部分</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pre[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">int</span> total;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r=x;</span><br><span class="line">	<span class="keyword">while</span>(pre[r]!=r)	<span class="comment">//如果r的上级不是自己</span></span><br><span class="line">		r=pre[r];		<span class="comment">//那么r等于它的前导点，继续寻找，直到找到根节点</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//下面这段起到路径压缩的作用</span></span><br><span class="line">	<span class="keyword">int</span> i=x; <span class="keyword">int</span> j;</span><br><span class="line">	<span class="keyword">while</span>(i!=r)			<span class="comment">//如果当前查找的城镇不是根结点（pre指向自己）</span></span><br><span class="line">	&#123;</span><br><span class="line">		j=pre[i];		<span class="comment">//j为该城镇的前导点</span></span><br><span class="line">		pre[i]=r;		<span class="comment">//更新该城镇的前导点直接指向根节点</span></span><br><span class="line">		i=j;			<span class="comment">//让i指向其前导点，在下一次循环里面就会更新其前导点指向根节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> p1,<span class="keyword">int</span> p2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> f1,f2;</span><br><span class="line">	f1 = find(p1);</span><br><span class="line">	f2 = find(p2); <span class="comment">//分别查找两个城镇的根节点</span></span><br><span class="line">	<span class="comment">//如果是不连通的，那么把这两个分支连起来</span></span><br><span class="line">	<span class="comment">//分支的总数就减少了1，还需建的路也就减了1</span></span><br><span class="line">	<span class="keyword">if</span>(f1!=f2)</span><br><span class="line">	&#123;</span><br><span class="line">		pre[f2 ]=f1;</span><br><span class="line">		total--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>  n,m,p1,p2;</span><br><span class="line">	<span class="keyword">while</span>((~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)) &amp;&amp; n)&#123;</span><br><span class="line">		total = n<span class="number">-1</span>; <span class="comment">//最差的情况下，总共要修n-1条路</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123; <span class="comment">//初始化pre数组，让他们的前导点都记录为自己，即自己为根节点</span></span><br><span class="line">			pre[i]=i; </span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">		<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;p1&gt;&gt;p2; <span class="comment">//输入相连的连个城镇</span></span><br><span class="line">			join(p1,p2);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,total); <span class="comment">//最后输出还要修的路条数</span></span><br><span class="line">	&#125;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【2018年全国多校算法寒假训练营练习比赛（第四场）】Call to your teacher</p>
<blockquote>
<p>链接：<a href="https://www.nowcoder.net/acm/contest/76/F" target="_blank" rel="noopener">https://www.nowcoder.net/acm/contest/76/F</a><br>来源：牛客网</p>
<p>题目描述<br>从实验室出来后，你忽然发现你居然把自己的电脑落在了实验室里，但是实验室的老师已经把大门锁上了。更糟的是，你没有那个老师的电话号码。你开始给你知道的所有人打电话，询问他们有没有老师的电话，如果没有，他们也会问自己的同学来询问电话号码。那么，你能联系到老师并且拿到电脑吗。<br>输入描述:<br>存在多组测试样例<br>每组样例的第一行分别是两个整数n(1&lt;n&lt;=50)，m(1&lt;m&lt;=2000)，n是在题目当中出现的人数，其中你的序号是1号，实验室老师的序号是n。<br>接下来的m行，每行有两个整数x(1&lt;=x&lt;=n)，y(1&lt;=y&lt;=n)，代表x有y的电话号码。<br>输出描述:<br>对于每组测试样例，如果你最终能联系到老师，输出“Yes”，否则输出“No”。<br>示例1<br>输入<br>5 5<br>1 3<br>2 3<br>3 4<br>2 4<br>4 5<br>输出<br>Yes<br>示例2<br>输入<br>4 3<br>1 2<br>2 3<br>4 1<br>输出<br>No</p>
</blockquote>
<p>分析：要求1号能不能得到老师n号的电话号码，最后我们只要检测1号和n号在不在一个集合里，能否直接通过find()函数查找到。所以通过并查集解决这题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pre[<span class="number">2010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r=x;</span><br><span class="line">	<span class="keyword">while</span>(pre[r]!=r)</span><br><span class="line">		r = pre[r];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i=x, j;</span><br><span class="line">	<span class="keyword">while</span>(i!=r)&#123;</span><br><span class="line">		j = pre[i];</span><br><span class="line">		pre[i] = r;</span><br><span class="line">		i = j;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> p1, <span class="keyword">int</span> p2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> f1, f2;</span><br><span class="line">	f1 = find(p1);</span><br><span class="line">	f2 = find(p2);</span><br><span class="line">	<span class="keyword">if</span>(f2!=<span class="number">1</span>)&#123;</span><br><span class="line">		pre[f2] = f1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m,p1,p2;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m))&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">			pre[i]=i;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;p1&gt;&gt;p2;</span><br><span class="line">			join(p1, p2);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(find(n)==<span class="number">1</span>)</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"Yes"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"No"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程开发</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>算法笔记</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>错排公式的推导及应用</title>
    <url>/posts/15287.html</url>
    <content><![CDATA[<blockquote>
<p>之前就遇到过错排公式的题，但是自己没有注意这个知识点，以为只要硬记住就好啦，结果就是不知道推导过程完全记不住呀，所以今天认真整理一下错排公式相关的点。</p>
</blockquote>
<a id="more"></a>
<p>​       </p>
<h2 id="错排公式的推导"><a href="#错排公式的推导" class="headerlink" title="错排公式的推导"></a>错排公式的推导</h2><p>考虑一个有n个元素的排列，若一个排列中所有的元素都不在自己原来的位置上，那么这样的排列就称为原排列的一个错排，n个元素的错排记为D(n)。下面就是求出D(n)为多少中排列。</p>
<p>首先我们拿第一个元素的放置来理解一下这个过程：把元素1放在除自己原来的位置以外的位置，共有(n-1)种，假设第一个元素被放在了第k个元素的位置上，对第k个元素而言就有两种情况要讨论了，第一种，它放在非第一个位置上，所以对于接下来的排列就相当于是n-1个元素的错排，即D(n-1)；第二种，它就放在第1个元素的位置上，所以排列D(n)中有两个元素已经找到位置了，那么接下来就只需要考虑n-2个元素的错排，即D(n-2)。由此，我们就可以写出<strong>递推式对于D(n)都有D(n)=(n-1)*(D(n-1)+D(n-2))【特殊的情况 D(1)=0, D(2)=1】</strong>。</p>
<p>下面通过这个递推关系进行推导：<br>为了运算方便，我们设D(n)=n!<em>N(n)，则有：<br>n!</em>N(n) = (n-1)<em>(n-2)!</em>N(n-2) + (n-1)<em>(n-1)!N(n-1); 对两边同时除以(n-1)!，可得：<br>n</em>N(n) = N(n-2)+(n-1)<em>N(n-1)，移项：<br>N(n) - N(n-1) = (N(n-2) - N(n-1))/n = -(1/n)(N(n-1) - N(n-2))，所以，由此可以推出<br>N(n-1) - N(n-2) = -(1/(n-1))(N(n-2) - N(n-3))<br>……<br>N(2) - N(1) = 1/2;<br>由此，将每个式子相加得到：N(n) - N(1) = (1/2! - 1/3! + 1/4! - ……+((-1)^(n-1))/(n-1)! + (-1)^n/n!)<br>由于N(1) = 0，所以N(n) = (1/2! - 1/3! + 1/4! - …… +((-1)^(n-1))/(n-1)! + (-1)^n/n!)，于是可以得到：<br>错排公式<em>*D(n) = n!(1/2! - 1/3! + 1/4! - …… +((-1)^(n-1))/(n-1)! + (-1)^n/n!)</em></em>。</p>
<h2 id="错排公式的应用解题"><a href="#错排公式的应用解题" class="headerlink" title="错排公式的应用解题"></a>错排公式的应用解题</h2><h3 id="【hdu2049】考新郎"><a href="#【hdu2049】考新郎" class="headerlink" title="【hdu2049】考新郎"></a>【hdu2049】考新郎</h3><blockquote>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p> 在一场盛大的集体婚礼中,为了使婚礼进行的丰富一些,司仪临时想出了有一个有意思的节目,叫做”考新郎”,具体的操作是这样的:</p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p> 输入数据的第一行是一个整数C,表示测试实例的个数，然后是C行数据，每行包含两个整数N和M(1&lt; M&lt;=N&lt;=20)</p>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p> 对于每个测试实例，请输出一共有多少种发生这种情况的可能，每个实例的输出占一行。</p>
<h2 id="示例输入"><a href="#示例输入" class="headerlink" title="示例输入"></a>示例输入</h2><p> 2<br> 2 2<br> 3 2</p>
</blockquote>
<p>最开始做着题的时候就直接求解排列组合C(n,m)，没有考虑错排m个元素D(m)的问题，这里用上面的两种方法分别写出代码：</p>
<h4 id="方法一：递推公式-D-n-n-1-D-n-1-D-n-2-D-1-0，D-2-1"><a href="#方法一：递推公式-D-n-n-1-D-n-1-D-n-2-D-1-0，D-2-1" class="headerlink" title="方法一：递推公式 D(n)=(n-1)*(D(n-1)+D(n-2)) [D(1)=0，D(2)=1]"></a>方法一：递推公式 D(n)=(n-1)*(D(n-1)+D(n-2)) [D(1)=0，D(2)=1]</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">long long f[22];  </span><br><span class="line">void init()//错排  </span><br><span class="line">&#123;  </span><br><span class="line">	f[1]=0;  </span><br><span class="line">	f[2]=1;  </span><br><span class="line">	for(int i=3;i&lt;=20;i++)  </span><br><span class="line">	&#123;  </span><br><span class="line">		f[i]=(i-1)*(f[i-1]+f[i-2]);  </span><br><span class="line">	&#125;  </span><br><span class="line">	return ;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">int c(int x, int y)&#123;  </span><br><span class="line">	int n=x, m=y;</span><br><span class="line">	int sum=1,a=1,b=1;  </span><br><span class="line">	for(int i=1;i&lt;=y;i++)  &#123;  </span><br><span class="line">		a*=n;  </span><br><span class="line">		n--; </span><br><span class="line">		b*=m;  </span><br><span class="line">		m--; </span><br><span class="line">	&#125;  </span><br><span class="line">	sum=a/b;  </span><br><span class="line">	return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;  </span><br><span class="line">	int N,M;  </span><br><span class="line">	init();  </span><br><span class="line">	while(scanf(&quot;%d%d&quot;,&amp;N,&amp;M)!=EOF)  </span><br><span class="line">	&#123;  </span><br><span class="line">		</span><br><span class="line">		cout&lt;&lt;c(N,M)*f[M]&lt;&lt;endl;  </span><br><span class="line">	&#125;  </span><br><span class="line">	return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法二：通项公式-D-n-n-1-2-1-3-1-4-1-5-···-···-1-n-1-n-1-1-n-n"><a href="#方法二：通项公式-D-n-n-1-2-1-3-1-4-1-5-···-···-1-n-1-n-1-1-n-n" class="headerlink" title="方法二：通项公式 D(n)=n!*(1/2!-1/3!+1/4!- 1/5!+ ··· ··· +((-1)^(n-1))/(n-1)!+((-1)^n)/n! )"></a>方法二：通项公式 D(n)=n!*(1/2!-1/3!+1/4!- 1/5!+ ··· ··· +((-1)^(n-1))/(n-1)!+((-1)^n)/n! )</h4><p>对通项先进行简单变形：<br>C(n,m)<em>D(m) = (n!/(m!</em>(n-m)!))<em>D(m) = n!</em>(1/2!-1/3!+1/4!- 1/5!+ ··· ··· +((-1)^(m-1))/(m-1)!+((-1)^m)/m! )/(n-m)!</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">long long f[22];  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int c(int n)&#123;  </span><br><span class="line">	ll sum=1;</span><br><span class="line">	for(int i=1; i&lt;=n; i++)</span><br><span class="line">		sum*=i;</span><br><span class="line">	return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;  </span><br><span class="line">	int N,M;   </span><br><span class="line">	while(scanf(&quot;%d%d&quot;,&amp;N,&amp;M)!=EOF)  </span><br><span class="line">	&#123;  </span><br><span class="line">		ll a=c(N), sum=0, b=c(N-M);</span><br><span class="line">		for(int i=2; i&lt;=M; ++i)&#123;</span><br><span class="line">			a/=i;</span><br><span class="line">			if(i%2==0)</span><br><span class="line">				sum+=a;</span><br><span class="line">			else</span><br><span class="line">				sum-=a;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;sum/b&lt;&lt;endl;</span><br><span class="line">	&#125;  </span><br><span class="line">	return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>本文内容参考自：<br><a href="http://blog.csdn.net/yangyuhao0408/article/details/50971170" target="_blank" rel="noopener">http://blog.csdn.net/yangyuhao0408/article/details/50971170</a></p>
</blockquote>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>算法笔记</tag>
        <tag>错排公式</tag>
      </tags>
  </entry>
  <entry>
    <title>“埃氏筛法”思想运用</title>
    <url>/posts/d033fe5e.html</url>
    <content><![CDATA[<blockquote>
<p>埃拉托斯特尼筛法，简称埃氏筛或爱氏筛，是一种由希腊数学家埃拉托斯特尼所提出的一种简单检定素数的算法。要得到自然数n以内的全部素数，必须把不大于根号n的所有素数的倍数剔除，剩下的就是素数。</p>
</blockquote>
<a id="more"></a>
<p>​         </p>
<h2 id="求n以内的素数个数"><a href="#求n以内的素数个数" class="headerlink" title="求n以内的素数个数"></a>求n以内的素数个数</h2><p>给你一个数n,请问n以内有多少个素数?一般来说,要是对一个整数进行素数判断，首先想到的是写个函数判断是否为素数，然后调用这个函数，时间复杂度为O(n^(½)，但是要求n以内的素数就略显吃力了。这里就可以用埃氏筛法来处理这个问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">1e7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> prime[SIZE];		<span class="comment">//第i个素数</span></span><br><span class="line"><span class="keyword">bool</span> is_prime[SIZE];	<span class="comment">//true表示i是素数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++)</span><br><span class="line">		is_prime[i] = <span class="literal">true</span>;		<span class="comment">//初始化</span></span><br><span class="line">	is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="literal">false</span>;	<span class="comment">//0,1不是素数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(is_prime[i])&#123;</span><br><span class="line">			prime[p++] = i;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>*i; j&lt;=n; j+=i)  <span class="comment">//将i的倍数全部设为false</span></span><br><span class="line">				is_prime[j] = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">		<span class="keyword">int</span> res = slove(n);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;res; i++)</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;prime[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看代码说明，埃氏筛法是通过把不大于n的所有素数的倍数剔除，剩下的就是素数，这里最小的素数是2，将表中所有2的倍数都除去，剩下最小的数是3，不能被更小的数整除，所以是素数。再将表中3的倍数的数除去。以此类推。如果表中最小的数字是m，m就是素数。然后将表中所有m的倍数都除去……</p>
<p>​           </p>
<h2 id="利用埃氏筛法的思想解题"><a href="#利用埃氏筛法的思想解题" class="headerlink" title="利用埃氏筛法的思想解题"></a>利用埃氏筛法的思想解题</h2><p>链接：<a href="https://www.nowcoder.net/acm/contest/71/A" target="_blank" rel="noopener">https://www.nowcoder.net/acm/contest/71/A</a><br>来源：牛客网</p>
<blockquote>
<p>找一找<br>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 262144K，其他语言524288K<br>64bit IO Format: %lld<br>题目描述<br>给定n个正整数，请找出其中有多少个数x满足：在这n个数中存在数y=kx，其中k为大于1的整数<br>输入描述:<br>第一行输入一个n<br>接下来一行输入n个正整数ai<br>输出描述:<br>输出符合条件个数<br>示例1<br>输入<br>5<br>1 2 3 4 5<br>输出<br>2<br>说明<br>5个数中1和2符合条件，1是后面每个数的因子，2是4的因子<br>备注:<br>1≤n,a<br>i<br>≤1000000</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> b[N],a[N],sum;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a[i],b[a[i]]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			sum++;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=a[i]+a[i]; j&lt;N; j+=a[i])</span><br><span class="line">			<span class="keyword">if</span>(b[j]==<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				sum++;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum);</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程开发</category>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>算法笔记</tag>
        <tag>埃筛</tag>
      </tags>
  </entry>
  <entry>
    <title>浙江大学PAT题解目录</title>
    <url>/posts/5b9b2dff.html</url>
    <content><![CDATA[<blockquote>
<p><strong>PAT</strong></p>
<p>Record my code in Programming Ability Test</p>
<p><a href="https://github.com/hushhw/PAT" target="_blank" rel="noopener">https://github.com/hushhw/PAT</a></p>
</blockquote>
<a id="more"></a>
<p>​      </p>
<h2 id="PAT甲级"><a href="#PAT甲级" class="headerlink" title="PAT甲级"></a>PAT甲级</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">ID</th>
<th style="text-align:left">Title</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1001</td>
<td style="text-align:left">A+B Format (20)</td>
<td style="text-align:left">字符串处理</td>
</tr>
<tr>
<td style="text-align:center">1002</td>
<td style="text-align:left">A+B for Polynomials (25)</td>
<td style="text-align:left">模拟</td>
</tr>
<tr>
<td style="text-align:center">1003</td>
<td style="text-align:left">Emergency (25)</td>
<td style="text-align:left">Dijkstra算法及dfs解法</td>
</tr>
<tr>
<td style="text-align:center">1004</td>
<td style="text-align:left">Counting Leaves (30)</td>
<td style="text-align:left">BFS，DFS，树的层序遍历</td>
</tr>
<tr>
<td style="text-align:center">1005</td>
<td style="text-align:left">Spell It Right (20)</td>
<td style="text-align:left">字符串处理</td>
</tr>
<tr>
<td style="text-align:center">1006</td>
<td style="text-align:left">Sign In and Sign Out (25)</td>
<td style="text-align:left">查找元素</td>
</tr>
<tr>
<td style="text-align:center">1007</td>
<td style="text-align:left">Maximum Subsequence Sum(25)</td>
<td style="text-align:left">动态规划，最大连续子序列和</td>
</tr>
<tr>
<td style="text-align:center">1008</td>
<td style="text-align:left">Elevator (20)</td>
<td style="text-align:left">数学问题</td>
</tr>
<tr>
<td style="text-align:center">1009</td>
<td style="text-align:left">Product of Polynomials (25)</td>
<td style="text-align:left">模拟</td>
</tr>
<tr>
<td style="text-align:center">1010</td>
<td style="text-align:left">Radix (25)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">1011</td>
<td style="text-align:left">World Cup Betting (20)</td>
<td style="text-align:left">查找元素</td>
</tr>
</tbody>
</table>
</div>
<h2 id="PAT乙级"><a href="#PAT乙级" class="headerlink" title="PAT乙级"></a>PAT乙级</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">ID</th>
<th style="text-align:left">Title</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1001</td>
<td style="text-align:left">害死人不偿命的(3n+1)猜想(15)</td>
<td style="text-align:center">模拟</td>
</tr>
<tr>
<td style="text-align:center">1002</td>
<td style="text-align:left">写出这个数 (20)</td>
<td style="text-align:center">字符串处理</td>
</tr>
<tr>
<td style="text-align:center">1003</td>
<td style="text-align:left">我要通过！(20)</td>
<td style="text-align:center">数学题</td>
</tr>
<tr>
<td style="text-align:center">1004</td>
<td style="text-align:left">成绩排名 (20)</td>
<td style="text-align:center">Hash散列</td>
</tr>
<tr>
<td style="text-align:center">1006</td>
<td style="text-align:left">换个格式输出整数 (15)</td>
<td style="text-align:center">素数</td>
</tr>
<tr>
<td style="text-align:center">1008</td>
<td style="text-align:left">数组元素循环右移问题 (20)</td>
<td style="text-align:center">模拟</td>
</tr>
<tr>
<td style="text-align:center">1009</td>
<td style="text-align:left">说反话 (20)</td>
<td style="text-align:center">字符串处理</td>
</tr>
<tr>
<td style="text-align:center">1010</td>
<td style="text-align:left">一元多项式求导 (25)</td>
<td style="text-align:center">模拟</td>
</tr>
<tr>
<td style="text-align:center">1011</td>
<td style="text-align:left">A+B和C (15)</td>
<td style="text-align:center">模拟</td>
</tr>
<tr>
<td style="text-align:center">1012</td>
<td style="text-align:left">数字分类 (20)</td>
<td style="text-align:center">模拟</td>
</tr>
<tr>
<td style="text-align:center">1013</td>
<td style="text-align:left">数素数 (20)</td>
<td style="text-align:center">素数</td>
</tr>
<tr>
<td style="text-align:center">1014</td>
<td style="text-align:left">福尔摩斯的约会 (20)</td>
<td style="text-align:center">字符串处理</td>
</tr>
<tr>
<td style="text-align:center">1015</td>
<td style="text-align:left">德才论 (25)</td>
<td style="text-align:center">排序</td>
</tr>
<tr>
<td style="text-align:center">1016</td>
<td style="text-align:left">部分A+B (15)</td>
<td style="text-align:center">模拟</td>
</tr>
<tr>
<td style="text-align:center">1017</td>
<td style="text-align:left">A除以B (20)</td>
<td style="text-align:center">大整数运算</td>
</tr>
<tr>
<td style="text-align:center">1018</td>
<td style="text-align:left">锤子剪刀布 (20)</td>
<td style="text-align:center">模拟</td>
</tr>
<tr>
<td style="text-align:center">1019</td>
<td style="text-align:left">数字黑洞 (20)</td>
<td style="text-align:center">数学问题</td>
</tr>
<tr>
<td style="text-align:center">1020</td>
<td style="text-align:left">月饼 (25)</td>
<td style="text-align:center">贪心算法</td>
</tr>
<tr>
<td style="text-align:center">1021</td>
<td style="text-align:left">个位数统计 (15)</td>
<td style="text-align:center">字符串处理</td>
</tr>
<tr>
<td style="text-align:center">1022</td>
<td style="text-align:left">D进制的A+B (20)</td>
<td style="text-align:center">进制转换</td>
</tr>
<tr>
<td style="text-align:center">1023</td>
<td style="text-align:left">组个最小数 (20)</td>
<td style="text-align:center">贪心算法</td>
</tr>
<tr>
<td style="text-align:center">1024</td>
<td style="text-align:left">科学计数法 (20)</td>
<td style="text-align:center">字符串处理</td>
</tr>
<tr>
<td style="text-align:center">1025</td>
<td style="text-align:left">反转链表 (25)</td>
<td style="text-align:center">链表</td>
</tr>
<tr>
<td style="text-align:center">1026</td>
<td style="text-align:left">程序运行时间(15)</td>
<td style="text-align:center">模拟</td>
</tr>
<tr>
<td style="text-align:center">1027</td>
<td style="text-align:left">打印沙漏(20)</td>
<td style="text-align:center">图形打印</td>
</tr>
<tr>
<td style="text-align:center">1028</td>
<td style="text-align:left">人口普查(20)</td>
<td style="text-align:center">查找元素</td>
</tr>
<tr>
<td style="text-align:center">1029</td>
<td style="text-align:left">旧键盘(20)</td>
<td style="text-align:center">Hash散列</td>
</tr>
<tr>
<td style="text-align:center">1030</td>
<td style="text-align:left">完美数列(25)</td>
<td style="text-align:center">two pointers</td>
</tr>
<tr>
<td style="text-align:center">1031</td>
<td style="text-align:left">查验身份证(15)</td>
<td style="text-align:center">字符串处理</td>
</tr>
<tr>
<td style="text-align:center">1032</td>
<td style="text-align:left">挖掘机技术哪家强(20)</td>
<td style="text-align:center">查找元素</td>
</tr>
<tr>
<td style="text-align:center">1033</td>
<td style="text-align:left">旧键盘打字(20)</td>
<td style="text-align:center">Hash散列</td>
</tr>
<tr>
<td style="text-align:center">1034</td>
<td style="text-align:left">有理数四则运算(20)</td>
<td style="text-align:center">分数的四则运算</td>
</tr>
<tr>
<td style="text-align:center">1035</td>
<td style="text-align:left">插入与归并(25)</td>
<td style="text-align:center">two pointers</td>
</tr>
<tr>
<td style="text-align:center">1036</td>
<td style="text-align:left">跟奥巴马一起编程(15)</td>
<td style="text-align:center">图形打印</td>
</tr>
<tr>
<td style="text-align:center">1037</td>
<td style="text-align:left">在霍格沃茨找零钱（20)</td>
<td style="text-align:center">进制转换</td>
</tr>
<tr>
<td style="text-align:center">1038</td>
<td style="text-align:left">统计同成绩学生(20)</td>
<td style="text-align:center">Hash散列</td>
</tr>
<tr>
<td style="text-align:center">1039</td>
<td style="text-align:left">到底买不买 (20)</td>
<td style="text-align:center">Hash散列</td>
</tr>
<tr>
<td style="text-align:center">1040</td>
<td style="text-align:left">有几个PAT（25)</td>
<td style="text-align:center">逻辑题</td>
</tr>
<tr>
<td style="text-align:center">1041</td>
<td style="text-align:left">考试座位号(15)</td>
<td style="text-align:center">查找元素</td>
</tr>
<tr>
<td style="text-align:center">1042</td>
<td style="text-align:left">字符统计(20)</td>
<td style="text-align:center">Hash散列</td>
</tr>
<tr>
<td style="text-align:center">1043</td>
<td style="text-align:left">输出PATest(20)</td>
<td style="text-align:center">Hash散列</td>
</tr>
<tr>
<td style="text-align:center">1044</td>
<td style="text-align:left">火星数字(20)</td>
<td style="text-align:center">map映射，STL的使用</td>
</tr>
<tr>
<td style="text-align:center">1045</td>
<td style="text-align:left">快速排序(25)</td>
<td style="text-align:center">快速排序</td>
</tr>
<tr>
<td style="text-align:center">1046</td>
<td style="text-align:left">划拳(15)</td>
<td style="text-align:center">模拟</td>
</tr>
<tr>
<td style="text-align:center">1047</td>
<td style="text-align:left">编程团体赛(20)</td>
<td style="text-align:center">Hash散列</td>
</tr>
<tr>
<td style="text-align:center">1048</td>
<td style="text-align:left">数字加密(20)</td>
<td style="text-align:center">字符串处理</td>
</tr>
<tr>
<td style="text-align:center">1049</td>
<td style="text-align:left">数列的片段和(20)</td>
<td style="text-align:center">数学问题</td>
</tr>
<tr>
<td style="text-align:center">1050</td>
<td style="text-align:left">螺旋矩阵(25)</td>
<td style="text-align:center">模拟</td>
</tr>
<tr>
<td style="text-align:center">1051</td>
<td style="text-align:left">复数乘法 (15)</td>
<td style="text-align:center">模拟</td>
</tr>
<tr>
<td style="text-align:center">1052</td>
<td style="text-align:left">卖个萌 (20)</td>
<td style="text-align:center">字符串处理</td>
</tr>
<tr>
<td style="text-align:center">1053</td>
<td style="text-align:left">住房空置率 (20)</td>
<td style="text-align:center">模拟</td>
</tr>
<tr>
<td style="text-align:center">1054</td>
<td style="text-align:left">求平均值 (20)</td>
<td style="text-align:center">字符串处理</td>
</tr>
<tr>
<td style="text-align:center">1055</td>
<td style="text-align:left">集体照 (25)</td>
<td style="text-align:center">排序</td>
</tr>
<tr>
<td style="text-align:center">1056</td>
<td style="text-align:left">组合数的和(15)</td>
<td style="text-align:center">数学问题</td>
</tr>
<tr>
<td style="text-align:center">1057</td>
<td style="text-align:left">数零壹(20)</td>
<td style="text-align:center">进制转换</td>
</tr>
<tr>
<td style="text-align:center">1058</td>
<td style="text-align:left">选择题(20)</td>
<td style="text-align:center">字符串处理</td>
</tr>
<tr>
<td style="text-align:center">1059</td>
<td style="text-align:left">C语言竞赛(20)</td>
<td style="text-align:center">逻辑题</td>
</tr>
<tr>
<td style="text-align:center">1060</td>
<td style="text-align:left">爱丁顿数(25)</td>
<td style="text-align:center">逻辑题</td>
</tr>
<tr>
<td style="text-align:center">1061</td>
<td style="text-align:left">判断题(15)</td>
<td style="text-align:center">逻辑题</td>
</tr>
<tr>
<td style="text-align:center">1062</td>
<td style="text-align:left">最简分数(20)</td>
<td style="text-align:center">分数化简</td>
</tr>
<tr>
<td style="text-align:center">1063</td>
<td style="text-align:left">计算谱半径(20)</td>
<td style="text-align:center">逻辑题</td>
</tr>
<tr>
<td style="text-align:center">1064</td>
<td style="text-align:left">朋友数(20)</td>
<td style="text-align:center">set的使用</td>
</tr>
<tr>
<td style="text-align:center">1065</td>
<td style="text-align:left">单身狗(25)</td>
<td style="text-align:center">逻辑题，set的使用</td>
</tr>
<tr>
<td style="text-align:center">1066</td>
<td style="text-align:left">图像过滤(15)</td>
<td style="text-align:center">逻辑题</td>
</tr>
<tr>
<td style="text-align:center">1067</td>
<td style="text-align:left">试密码(20)</td>
<td style="text-align:center">字符串</td>
</tr>
<tr>
<td style="text-align:center">1068</td>
<td style="text-align:left">万绿丛中一点红(20)</td>
<td style="text-align:center">逻辑题</td>
</tr>
<tr>
<td style="text-align:center">1069</td>
<td style="text-align:left">微博转发抽奖(20)</td>
<td style="text-align:center">map映射</td>
</tr>
<tr>
<td style="text-align:center">1070</td>
<td style="text-align:left">结绳(25)</td>
<td style="text-align:center">排序，贪心</td>
</tr>
<tr>
<td style="text-align:center">1071</td>
<td style="text-align:left">小赌怡情(15)</td>
<td style="text-align:center">简单题</td>
</tr>
<tr>
<td style="text-align:center">1072</td>
<td style="text-align:left">开学寄语(20)</td>
<td style="text-align:center">简单题</td>
</tr>
<tr>
<td style="text-align:center">1073</td>
<td style="text-align:left">多选题常见计分法(20)</td>
<td style="text-align:center">逻辑题</td>
</tr>
<tr>
<td style="text-align:center">1074</td>
<td style="text-align:left">宇宙无敌加法器(20)</td>
<td style="text-align:center">逻辑题</td>
</tr>
<tr>
<td style="text-align:center">1075</td>
<td style="text-align:left">链表元素分类(25)</td>
<td style="text-align:center">链表</td>
</tr>
<tr>
<td style="text-align:center">1076</td>
<td style="text-align:left">Wifi密码</td>
<td style="text-align:center">简单题</td>
</tr>
<tr>
<td style="text-align:center">1077</td>
<td style="text-align:left">互评成绩计算</td>
<td style="text-align:center">简单题</td>
</tr>
<tr>
<td style="text-align:center">1078</td>
<td style="text-align:left">字符串压缩与解压</td>
<td style="text-align:center">逻辑题</td>
</tr>
<tr>
<td style="text-align:center">1079</td>
<td style="text-align:left">延迟的回文数</td>
<td style="text-align:center">回文数</td>
</tr>
<tr>
<td style="text-align:center">1080</td>
<td style="text-align:left">MOOC期终成绩</td>
<td style="text-align:center">map映射，排序</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>OJ刷题</category>
      </categories>
      <tags>
        <tag>OJ</tag>
        <tag>PAT</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>《计算机网络》复习笔记</title>
    <url>/posts/415999f5.html</url>
    <content><![CDATA[<blockquote>
<p>本复习笔记基于谢希仁的《计算机网络》第五版教材整理。</p>
<p>由于一些原因笔记并不完整，后来考研复习时的复习PPT可以作为补充：<a href="https://note.youdao.com/ynoteshare1/index.html?id=cf0592e2b1b463a48e9c8a0ef3c1396a&amp;type=notebook" target="_blank" rel="noopener">计算机网络笔记</a></p>
</blockquote>
<p>​          </p>
<h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><p>计算机网络：是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统。</p>
<p>计算机网络向用户提供的两个最重要的功能：</p>
<ul>
<li><strong>数据通信</strong>（连通性）：计算机网络最基本最重要的功能。</li>
<li><strong>资源共享</strong></li>
</ul>
<h3 id="因特网概述"><a href="#因特网概述" class="headerlink" title="因特网概述"></a>因特网概述</h3><p>因特网发展的三个阶段：</p>
<ul>
<li>第一阶段：从单个网络 ARPANET 向互联网发展的过程。1983 年 TCP/IP 协议成为 ARPANET 上的标准协议。</li>
<li>第二阶段：建成三级结构的因特网：主干网、地区网和校园网（或企业网）。</li>
<li>第三阶段：形成多层次的ISP（Internet Service Provider 因特网服务提供者）结构的因特网</li>
</ul>
<p>Internet 和 Internet 的区别：</p>
<ul>
<li><strong>internet</strong>：通用名词，它泛指由多个计算机网络互连而成的网络。</li>
<li><strong>Internet</strong>：专用名词，它指当前全球最大的、开放的、由众多网络相互连接而成的特定计算机网络，它采用 TCP/IP 协议族作为通信的规则，且其前身是美国的 ARPANET。</li>
</ul>
<h3 id="互联网的组成-P8"><a href="#互联网的组成-P8" class="headerlink" title="互联网的组成 P8"></a>互联网的组成 P8</h3><p><strong>边缘部分</strong>：由所有连接在因特网上的主机组成。这部分由<strong>用户直接使用</strong>，用来进行通信和资源共享。</p>
<p><strong>核心部分</strong> : 由大量的网络和连接这些网络的路由器组成。这部分是<strong>为边缘部分提供服务的</strong>（提供连通性和交换）。</p>
<p>处于边缘部分的用户通信方式 P9-P10</p>
<ul>
<li><p>客户服务器方式（<strong>C/S</strong>方式）：即 Client/Server 方式。（客户是服务的请求方，服务器是服务的提供方）</p>
</li>
<li><p>对等方式（<strong>P2P</strong>方式）：即 Peer-to-Peer 方式。（对等连接中的每一个主机既是客户又同时是服务器）</p>
</li>
</ul>
<p>核心部分的交换技术 P11-15</p>
<ul>
<li><strong>电路交换</strong> 的三个阶段：建立连接——通话——释放连接<br>在通话时，两用户之间占用端到端的资源，而由于绝大部分时间线路都是空闲的，所以线路的传输速率往往很低。</li>
<li><strong>分组交换</strong> 的组成：报文、首部、分组。采用存储转发技术，即收到分组——存储分组——查询路由（路由选择协议）——转发分组。优点：高效、灵活、迅速、可靠。缺点：时延、开销。关键构件：路由器。</li>
<li><strong>报文交换</strong> 整个报文传送到相邻结点，全部存储下来之后查询转发表，转发到下一个结点。<br><img src="https://photo.hushhw.cn/images/Snipaste_2019-01-12_19-21-39.png" alt><br><img src="https://photo.hushhw.cn/images/20180105203650888.png" alt></li>
</ul>
<h3 id="计算机网络的类别-P17"><a href="#计算机网络的类别-P17" class="headerlink" title="计算机网络的类别 P17"></a>计算机网络的类别 P17</h3><p>分类</p>
<ul>
<li>按通信距离分：广域网、局域网、城域网</li>
<li>按网络拓扑结构分：星型网、树型网、环型网、总线网</li>
<li>按传输带宽分：基带网、宽带网</li>
<li>按使用范围分：公用网、专用网</li>
<li>按速率分：高速网、中速网、低速网</li>
<li><p>按通信传播方式分：广播式、点到点式</p>
<ul>
<li>广播式网络：共享公共通信通道</li>
<li>点对点网络：使用分组存储转发和路由选择机制<br>性能指标（P18）：速率、带宽、时延</li>
</ul>
</li>
<li><p><strong>速率</strong>：指连接在计算机网络上的主机在数字信道上传送数据的速率。b/s（bps） 如100M以太网，实际是指100Mb/s。往往是指额定速率或标称速率。</p>
</li>
<li><strong>带宽</strong>：数字信道所能传送的最高速率。b/s（bps）</li>
<li><strong>吞吐量</strong>：单位时间内通过某个网络（或信道、接口）的实际数据量。其绝对上限值等于带宽。</li>
<li><p><strong>时延</strong>：数据（一个报文或分组、甚至比特）从网络（或链路）的一段传送到另一端的时间，也称延迟。<br>  &emsp; ① 发送时延：主机或路由器发送数据帧所需的时间，也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。也成传输时延。<br>  发送时延 = 数据帧长度（b） / 信道带宽（b/s）<br>  &emsp;② 传播时延：电磁波在信道中传输一定距离所需划分的时间。<br>  传播时间 = 信道长度（m） / 传输速率（m/s）<br>  &emsp;③ 处理时延：主机或路由器处理收到的分组所花费的时间。<br>  &emsp;④ 排队时延：分组在输入队列中等待处理的时间加上其在输出队列中等待转发的时间。<br>   综上：总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延。<br>  注：对于高速网络链路，提高的是发送速率而不是传播速率。</p>
</li>
<li><p>时延带宽积：传播时延 * 带宽。表示链路的容量。</p>
</li>
<li>往返时间RTT：从发送方发送数据开始，到发送发收到接收方的确认为止，所花费的时间。</li>
<li>利用率：某信道有百分之几是被利用的（有数据通过）。而信道或网络利用率过高会产生非常大的时延。<br>  当前时延=空闲时时延/（1-利用率）</li>
</ul>
<h3 id="计算机网络的体系结构-P25"><a href="#计算机网络的体系结构-P25" class="headerlink" title="计算机网络的体系结构 P25"></a>计算机网络的体系结构 P25</h3><p><strong>网络协议</strong>：简称协议，是为了进行网络中的数据交换而建立的规则、标准或约定，是控制两个对等实体进行通信的规则的集合。在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务，而要实现本层协议，还需要使用下一层提供的服务。</p>
<p>网络协议的三要素</p>
<ul>
<li>语法：数据与控制信息的结构或格式 </li>
<li>语义：需要发出何种控制信息，完成何种动作以及做出何种响应</li>
<li>同步：事件实现顺序的详细说明</li>
</ul>
<p><strong>实体</strong>：第 n 层的活动元素称为 n 层实体。同一层的实体叫<strong>对等实体</strong>。</p>
<p><strong>接口</strong>：上层使用下层服务的入口</p>
<p><strong>服务</strong>：下层为相邻上层提供的功能调用。</p>
<p><strong>体系结构</strong>(architecture)简称<strong>分层结构</strong>，是计算机网络的各层及其协议的集合。</p>
<p>7 层 <strong>OSI 参考模型</strong>：</p>
<ul>
<li>物理层、数据链路层、网络层：提供<strong>点到点</strong>的服务</li>
<li>传输层、会话层、表示层、应用层：提供<strong>端到端</strong>的服务</li>
</ul>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-03-14_17-33-35.png" alt></p>
<p>4 层 <strong>TCP/IP 参考模型</strong>：网络接口层、网际层IP、运输层、应用层</p>
<ul>
<li>TCP/IP 设计之初就考虑到异构网互联问题，将 IP 作为重要层次；而 OSI 参考模型先于协议发明，不偏向特定协议。</li>
<li>两者常考的异同点：OSI 参考模型网络层是「无连接+面向连接」，而 TCP/IP 模型是「无连接」的；OSI 参考模型传输层是「面向连接」，而 TCP/IP 模型是「无连接+面向连接」。</li>
</ul>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-03-14_17-37-40.png" alt></p>
<p>五层协议的体系结构（综合了 OSI 和 TCP/IP 的优点）</p>
<ul>
<li><strong>物理层</strong>：物理层的任务就是透明地传送比特流。（注意：传递信息的物理媒体，如双绞线、同轴电缆、光缆等，是在物理层的下面，当做第0 层。）物理层还要确定连接电缆插头的定义及连接法。</li>
<li><strong>数据链路层</strong>：将网络层交下来的IP数据报组装成帧，在两个相邻结点间的链路上”透明“的传送以帧为单位的数据。每一帧包括数据和必要的控制信息。在收到数据时，控制信息使收到端直到哪个帧从哪个比特开始和结束。</li>
<li><strong>网络层</strong>：选择合适的路由，使发送站的运输层所传下来的分组能够正确无误地按照地址找到目的站，并交付给目的站的运输层。网络层将运输层产生的报文或用户数据报封装成分组（IP数据报）或包进行传送。</li>
<li><strong>运输层</strong>：向上一层的进行通信的两个进程之间提供一个可靠的端对端服务，使它们看不见运输层以下的数据通信的细节。（TCP、UDP）</li>
<li><p><strong>应用层</strong>：直接为用户的应用进程提供服务（HTTP、FTP等）<br> <img src="https://photo.hushhw.cn/images/20180105203859787.jpg" alt></p>
<p>​</p>
</li>
</ul>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><blockquote>
<p>这一小节补充PPT：<a href="https://note.youdao.com/ynoteshare1/index.html?id=cf0592e2b1b463a48e9c8a0ef3c1396a&amp;type=notebook#/b435c72341f168a19f766acb8dc19833" target="_blank" rel="noopener">物理层</a></p>
</blockquote>
<h3 id="物理层基础概念"><a href="#物理层基础概念" class="headerlink" title="物理层基础概念"></a>物理层基础概念</h3><p>物理层解决如何在连接各种计算机的传输媒体上传输数据比特流，而不是值具体的传输媒体。</p>
<p>物理层特性：</p>
<ul>
<li>机械特性</li>
<li>电气特性</li>
<li>功能特性</li>
<li>规程特性</li>
</ul>
<h3 id="数据通信基础知识"><a href="#数据通信基础知识" class="headerlink" title="数据通信基础知识"></a>数据通信基础知识</h3><p><strong>数据</strong>：传递信息的实体，通常是有意义的符号序列。</p>
<p><strong>信号</strong>：数据的电气/电磁的表现，是数据在传输过程中的存在形式。</p>
<ul>
<li>数字信号：代表消息的参数取值是离散的</li>
<li>模拟信号：代表信号的参数取值是连续的</li>
</ul>
<p><strong>信源</strong>：产生和发送数据的源头。</p>
<p><strong>信宿</strong>：接收数据的终点</p>
<p><strong>信道</strong>：信号的传输媒介。一般用来表示像某一个方向传输信号的介质，因此一条通信线路往往包含一条发送信道和一条接收信道。</p>
<p>三种通信方式：</p>
<ul>
<li><strong>单工通信</strong>：只有一个方向的通信而没有反方向的交互，仅需一条信道。</li>
<li><strong>半双工通信</strong>：通信的双方都可以发送或接受信息，但任何一方都不能同时发送和接收，需要两条信道。</li>
<li><strong>全双工通信</strong>：通信双方可以同时发送和接收信息，也需要两条信道。</li>
</ul>
<p>两种数据传输方式：</p>
<ul>
<li><strong>串行传输</strong>：速度慢，费用低，适合远距离</li>
<li><strong>并行传输</strong>：速度快，费用高，适合近距离</li>
</ul>
<h3 id="物理层下的传输媒体"><a href="#物理层下的传输媒体" class="headerlink" title="物理层下的传输媒体"></a>物理层下的传输媒体</h3><p><img src="https://photo.hushhw.cn/images/20180105222431656.png" alt></p>
<p>双绞线：双绞线已成为局域网中的主流传输媒体</p>
<ul>
<li><strong>屏蔽双绞线 STP</strong> (Shielded Twisted Pair)</li>
<li><strong>无屏蔽双绞线 UTP</strong> (Unshielded Twisted Pair)</li>
</ul>
<p>同轴电缆：</p>
<ul>
<li><strong>细缆</strong>（适合短距离，安装容易，造价低）</li>
<li><strong>粗缆</strong>（适合较大局域网，布线距离长，可靠性好）</li>
</ul>
<p>光纤：光纤有很好的抗电磁干扰特性和很宽的频带，主要用在环形网中</p>
<ul>
<li><strong>多模光纤</strong>（用发光二极管，便宜，定向性较差）</li>
<li><strong>单模光纤</strong>（注入激光二极管，定向性好）</li>
</ul>
<p>非导向传输媒体：微波、红外线、激光、卫星通信</p>
<h3 id="2-3-信道复用技术"><a href="#2-3-信道复用技术" class="headerlink" title="2.3 信道复用技术"></a>2.3 信道复用技术</h3><blockquote>
<p>这部分掌握码分复用计算即可</p>
</blockquote>
<ul>
<li>频分复用FDM (Frequency Division Multiplexing)：所有用户在同样的时间占用不同的频率带宽资源。</li>
<li>时分复用TDM(Time Division Multiplexing)则是将时间划分为一段段等长的时分复用帧（TDM 帧）。</li>
<li>统计时分复用 STDM(Statistic TDM)是改进的时分复用，明显地提高信道的利用率。</li>
<li>波分复用 WDM (Wavelength Division Multiplexing)：光的频分复用</li>
<li><p>码分复用 CDM (Code Division Multiplexing)常用的名词是<strong>码分多址 CDMA</strong>：有很强的抗干扰能力。</p>
<p>码分多址的计算靠一个例题就基本会了：<br><img src="https://photo.hushhw.cn/images/20180105230449989.png" alt></p>
</li>
</ul>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>数据链路层使用的信道主要有以下两种类型：</p>
<ul>
<li>点对点信道</li>
<li>广播信道</li>
</ul>
<h3 id="3-1-使用点对点信道的数据链路层"><a href="#3-1-使用点对点信道的数据链路层" class="headerlink" title="3.1 使用点对点信道的数据链路层"></a>3.1 使用点对点信道的数据链路层</h3><ol>
<li><strong>链路</strong> ：从一个结点到相邻结点的一段物理线路</li>
<li><p><strong>数据链路</strong> ：把实现这些协议的硬件和软件加载链路上<br>现在最常用的方法是使用适配器（即网卡）来实现这些协议的硬件和软件。一般的适配器都包括了数据链路层和物理层这两层的功能。</p>
</li>
<li><p>三个基本问题：</p>
<ul>
<li><strong>封装成帧</strong><br>就是在一段数据的前后分别添加首部（帧开始符SOH 01）和尾部（帧结束符EOT 04），然后就构成了一个帧。（数据部分&lt;=长度限制MTU）首部和尾部的一个重要作用就是进行帧定界。<br>  <strong>帧定界是分组交换的必然要求</strong></li>
<li><strong>透明传输</strong><br>为了达到透明传输（即传输的数据部分不会因为包含SOH和EOT而出错），在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”(十六进制1B)<br>  <strong>透明传输避免消息符号与帧定界符号相混淆</strong></li>
<li><strong>差错检测</strong><br>现实通信链路中比特在传输中会产生差错，传输错误的比特占比称为<strong>误码率BER</strong>，为了保证可靠性，通常通过<strong>循环冗余检验CRC</strong>来做差错检测。<br>  <strong>差错检测防止无效数据帧浪费后续路由上的传输和处理资源</strong></li>
</ul>
<blockquote>
<p>CRC校验在计算机组成与结构中学过不做解释<br>会做课后习题7、8题即可</p>
</blockquote>
</li>
</ol>
<h3 id="3-2点对点协议-PPP-P70"><a href="#3-2点对点协议-PPP-P70" class="headerlink" title="3.2点对点协议 PPP P70"></a>3.2点对点协议 PPP P70</h3><ol>
<li>PPP协议的组成部分<ul>
<li>一个将 IP 数据报封装到串行链路的方法</li>
<li>链路控制协议 LCP (Link Control Protocol)</li>
<li>网络控制协议 NCP (Network Control Protocol)</li>
</ul>
</li>
</ol>
<ol>
<li>PPP协议的帧格式<br>  <img src="https://photo.hushhw.cn/images/Snipaste_2019-01-12_19-34-19.png" alt></li>
</ol>
<p>首部：</p>
<ul>
<li>首部中的标志字段F(Flag)，规定为0x7E(符号0x表示它后面的字符是用十六进制表示的。十六进制的7E的二进制表示是01111110)，标志字段表示一个帧的开始。</li>
<li>首部中的地址字段A规定为0xFF(即11111111)。</li>
<li>首部中的控制字段C规定为0x03(即00000011)。</li>
<li>首部中的2字节的协议字段：<br>  (1)当协议字段为0x0021时，PPP帧的信息字段就是IP数据报。<pre><code>(2)当协议字段为0xC021时，PPP帧的信息字段就是PPP链路控制协议LCP的数据。
(3)当协议字段为0x8021时，PPP帧的信息字段就是网络层的控制数据。
</code></pre></li>
</ul>
<p>尾部：</p>
<ul>
<li>尾部中的第一个字段(2个字节)是使用CRC的帧检验序列FCS。</li>
<li>尾部中的标志字段F(Flag)，规定为0x7E(符号0x表示它后面的字符是用十六进制表示的。十六进制的7E的二进制表示是01111110)，标志字段表示一个帧的结束。</li>
</ul>
<ol>
<li><p>透明传输的实现方法<br> 当信息字段中出现和标志字段一样的比特(0x7E)组合时，就必须采取一些措施使这种形式上和标志字段一样的比特组合不出现在信息字段中。</p>
<ul>
<li><p><strong>字节填充</strong>——PPP使用异步传输<br>当 PPP 用在异步传输时，就使用一种特殊的字符填充法：将每一个 0x7E字节变为(0x7D, 0x5E)，0x7D转变成为(0x7D, 0x5D)。ASCII 码的控制字符（即数值小于 0x20 的字符），则在前面要加入0x7D，同时将该字符的编码加以改变。</p>
</li>
<li><p><strong>零比特填充</strong>——PPP使用同步传输<br>只要发现有5个连续的1，则立即填入一个0<br>   <img src="https://photo.hushhw.cn/images/Snipaste_2019-01-12_19-35-15.png" alt></p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>这部分考题很简单：见课后习题10</p>
</blockquote>
<ol>
<li>PPP 协议的工作状态：<br>  链路静止-建立物理层-链路建立-pc发LCP-NCP分配IP地址-链路打开，网络层建立。（释放时倒过来）</li>
</ol>
<h3 id="3-3-使用广播信道的数据链路层-P76"><a href="#3-3-使用广播信道的数据链路层-P76" class="headerlink" title="3.3 使用广播信道的数据链路层 P76"></a>3.3 使用广播信道的数据链路层 P76</h3><p>广播信道是一种一对多的通信，局域网使用的就是广播信道</p>
<ol>
<li><p>局域网的数据链路层（局域网的数据链路层被拆分为了两个子层）</p>
<ul>
<li>逻辑链路控制LLC子层：与传输媒体无关</li>
<li>媒体接入控制MAC子层：和局域网都对LLC子层来说是透明的</li>
</ul>
</li>
<li><p>CSMA/CD 协议<br>  以太网采用CSMA/CD协议的方式来协调总线上各计算机的工作。在使用CSMA/CD协议的时候，一个站不可能同时进行发送和接收，因此使用CSMA/CD协议的以太网不可能进行全双工通信而只能进行双向交替通信（半双工）。</p>
</li>
</ol>
<p>CSMA/CD是<strong>载波监听多点接入/碰撞检测</strong>（Carrier Sense Multiple Access with Collision Detection）的缩写，下面是CSMA/CD协议的要点：</p>
<ul>
<li><strong>“多点接入”</strong>就是计算机以多点接入（动态媒体接入控制）的方式连接在一根总线上。</li>
<li><strong>“载波监听”</strong>就是”发送前先监听”，即每一个站在发送数据前先要检测一下总线是否有其他站在发送数据，如有则暂时不要发送数据，要等到信道为空闲。</li>
<li><strong>“碰撞检测”</strong>就是“边发送边监听”，即适配器边发送数据边检测信道上的信号电压的变化情况。当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送。</li>
</ul>
<p>把总线上的单程端到端传播时延记为τ，A 发送数据后，最迟要经过2τ才能知道自己发送的数据和其他站发送的数据有没有发生碰撞。</p>
<h3 id="3-4-以太网的MAC层"><a href="#3-4-以太网的MAC层" class="headerlink" title="3.4 以太网的MAC层"></a>3.4 以太网的MAC层</h3><ol>
<li><p>MAC地址<br>“MAC地址”又叫做硬件地址或物理地址，实际上就是适配器地址或适配器标识符EUI-48。高位24位：厂家，低位24位由厂家自行指派</p>
</li>
<li><p>MAC帧的格式<br>  常用的以太网MAC帧格式有两种标准 ： DIX Ethernet V2 标准IEEE 的 802.3 标准。V2使用较多，如图：</p>
<pre><code>![](https://photo.hushhw.cn/images/20131017004657921.png)
以太网V2的MAC帧较为简单，有五个字段组成。
前两个字段分别为6字长的目标地址和源地址字段。第三个字段是2字节的类型字段，用来标志上一层使用的是什么协议，以便把收到的MAC帧的数据上交给上一层的这个协议。后面数据字段46~1500字节，FCS字段4个字节。
</code></pre></li>
</ol>
<h3 id="3-5-扩展的以太网"><a href="#3-5-扩展的以太网" class="headerlink" title="3.5 扩展的以太网"></a>3.5 扩展的以太网</h3><ol>
<li>在物理层扩展—集线器 P91<br>  现在，双绞线以太网成为以太网的主流类型，扩展主机和集线器之间的距离的一种简单方法就是使用光纤(通常是一对光纤)和一对光纤调制解调器。</li>
</ol>
<p>光纤调制解调器的作用，是进行电信号和光信号的转换。</p>
<ol>
<li><p>在数据链路层扩展—网桥（自学习算法）P94<br>  <strong>注：在数据链路层扩展以太网要使用网桥</strong></p>
<pre><code>网桥工作在数据链路层，它根据MAC帧的目的地址对收到的帧进行转发或过滤。当网桥收到一个帧时，并不是向所有的接口转发这个帧，而是检查此帧的目的MAC地址，然后再确定将该帧转发到哪一个接口，或者是把它丢弃(即过滤)。
</code></pre><blockquote>
<p>具体可以参考这篇博客：<br><a href="http://blog.csdn.net/cainv89/article/details/50651489" target="_blank" rel="noopener">http://blog.csdn.net/cainv89/article/details/50651489</a></p>
</blockquote>
</li>
</ol>
<ol>
<li>虚拟局域网-交换机P98<br>  多接口网桥即交换式集线器常称为以太网交换机。利用以太网交换机可以很方便地 实现虚拟局域网，虚拟局域网协议允许在以太网的帧格式中插入一个 4 字节的标识符，称为 VLAN 标记。</li>
</ol>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="4-1-网际协议IP"><a href="#4-1-网际协议IP" class="headerlink" title="4.1 网际协议IP"></a>4.1 网际协议IP</h3><p>网际协议IP是TCP/IP体系中两个最重要的协议之一，也是最重要的因特网标准协议之一。与IP协议配套是用的四个协议：<br>1.<strong>地址解析协议ARP</strong>：是解决同一个局域网上的主机或路由器的IP地址和硬件地址的映射问题。<br>2.<strong>逆地址解析协议RARP</strong>：是解决同一个局域网上的主机或路由器的硬件地址和IP地址的映射问题。<br>3.<strong>网际控制报文协议ICMP</strong>：提供差错报告和询问报文，以提高IP数据交付成功的机会<br>4.<strong>网际组管理协议IGMP</strong>：：用于探寻、转发本局域网内的组成员关系。</p>
<h4 id="4-1-1-虚拟互连网络"><a href="#4-1-1-虚拟互连网络" class="headerlink" title="4.1.1 虚拟互连网络"></a>4.1.1 虚拟互连网络</h4><p>因为没有一种单一的网络能够适应所有的用户需求，所以网络互连也变得困难，所以需要一些中间设备：</p>
<ul>
<li>物理层中间设备：转发器(repeater)</li>
<li>数据链路层中间设备：网桥或桥接器(bridge)</li>
<li>网络层中间设备：路由器(router)</li>
<li><p>网络层以上的中间设备：网关(gateway)</p>
<blockquote>
<p> 具体各层的设备说明可以看这篇博客“网络设备”部分：<br> <a href="http://blog.csdn.net/hushhw/article/details/78489470" target="_blank" rel="noopener">http://blog.csdn.net/hushhw/article/details/78489470</a></p>
</blockquote>
</li>
</ul>
<h4 id="4-1-2-分类的IP地址-P113"><a href="#4-1-2-分类的IP地址-P113" class="headerlink" title="4.1.2 分类的IP地址 P113"></a>4.1.2 分类的IP地址 P113</h4><p><strong>IP 地址</strong>就是给每个连接在因特网上的主机（或路由器）分配一个在全世界范围是唯一的 32 位的标识符。由因特网名字与号码指派公司ICANN进行分配。</p>
<p>IP地址编制方法的三个阶段：</p>
<ul>
<li>分类的IP地址</li>
<li>子网的划分</li>
<li>构成超网</li>
</ul>
<p>每一类地址都由 <strong>网络号</strong> net-id和 <strong>主机号</strong> host-id组成<br><strong>主机号中全0表示网络地址，全1表示广播地址</strong><br><img src="https://photo.hushhw.cn/images/20180107023041372.jpg" alt><br><img src="https://photo.hushhw.cn/images/20180107023943820.jpg" alt></p>
<ul>
<li><p>A类</p>
<ol>
<li>由1字节的网络地址和3字节主机地址组成</li>
<li>网络地址的最高位必须是“0“，可指派的网络数为128-2，减2的原因是0.0.0.0对应“本网络”，另外一个是127.0.0.1是本地软件的回环地址，用于测试自己电脑IP地址是否可用。</li>
<li>地址范围1.0.0.0到126.255.255.255</li>
<li>最大主机数为256<sup>3</sup>-2=16777214台，减2的原因是全0的主机号字段代表该IP地址是”本主机“，全1表示”所有的“，表示该网络上的所有主机</li>
</ol>
</li>
<li><p>B类</p>
<ol>
<li>由2字节的网络地址和2字节主机地址组成</li>
<li>网络地址的最高位必须是“10”，可指派的网络数为 2<sup>14</sup> -1，因为最高位为10，所以不存在全0全1的情况，但是B类网络地址128.0.0.0是不指派的，可指派最小网络地址是128.1.0.0</li>
<li>地址范围128.0.0.0-191.255.255.255</li>
<li>最大主机数为256<sup>2</sup>-2=65534台，减2同样是全0全1情况。</li>
</ol>
</li>
<li><p>C类</p>
<ol>
<li>由3字节的网络地址和1字节主机地址组成</li>
<li>网络地址的最高位必须是“110”，可指派的网络数为2<sup>21</sup>-1，192.0.0.0不指派，最小可指派网络地址是192.0.1.0</li>
<li>地址范围192.0.0.0-223.255.255.255</li>
<li>最大主机数为256-2=254台，减2同样是全0全1情况。</li>
</ol>
</li>
<li><p>D类是多播地址，“lll0”开始</p>
</li>
<li><p>E类地址保留为今后使用，“llll0”开头</p>
</li>
</ul>
<h4 id="4-1-3-IP地址与硬件地址"><a href="#4-1-3-IP地址与硬件地址" class="headerlink" title="4.1.3 IP地址与硬件地址"></a>4.1.3 IP地址与硬件地址</h4><p><strong>硬件地址</strong>是数据链路层和物理层使用的地址<br><strong>IP地址</strong>是网络层和以上各层使用的地址，是一种逻辑地址</p>
<p>IP地址放在IP数据报的首部，而硬件地址放在MAC帧的首部。当数据报放入数据链路层的MAC帧中后，整个IP数据报就成为MAC帧的数据，因而在数据链路层看不见数据报的IP地址。</p>
<h4 id="4-1-4-地址解析协议ARP"><a href="#4-1-4-地址解析协议ARP" class="headerlink" title="4.1.4 地址解析协议ARP"></a>4.1.4 地址解析协议ARP</h4><p>ARP是解决<strong>同一个局域网上</strong>的主机或路由器的 IP 地址和硬件地址的映射问题。<br>每一个主机都设有一个ARP高速缓存(ARP  cache)，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。<br>如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。</p>
<h4 id="4-1-5-IP数据报"><a href="#4-1-5-IP数据报" class="headerlink" title="4.1.5 IP数据报"></a>4.1.5 IP数据报</h4><ol>
<li><p>IP数据报格式<br>一个IP数据报由首部（20 字节+可选字段）和数据两部分组成<br><img src="https://photo.hushhw.cn/images/20180107045436621.png" alt><br><img src="https://photo.hushhw.cn/images/20180107045539001.png" alt></p>
</li>
<li><p>分组转发<br> (1) 从数据报的首部提取目的主机的 IP 地址 D, 得出目的网络地址为 N。<br> (2) 若网络 N 与此路由器直接相连，则把数据报直接交付目的主机 D；否则是间接交付，执行(3)。<br> (3) 若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行(4)。<br> (4) 若路由表中有到达网络 N 的路由，则把数据报传送给路由表指明的下一跳路由器；否则，执行(5)。<br> (5) 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行(6)<br> (6) 报告转发分组出错。</p>
</li>
</ol>
<h3 id="4-2-划分子网-P128"><a href="#4-2-划分子网-P128" class="headerlink" title="4.2 划分子网 P128"></a>4.2 划分子网 P128</h3><ol>
<li><p>两级IP地址缺陷：</p>
<ol>
<li>IP 地址空间的利用率有时很低。</li>
<li>给每一个物理网络分配一个网络号会使路由表变得太大因而使网络性能变坏。</li>
<li>两级的 IP 地址不够灵活</li>
</ol>
</li>
<li><p>子网划分的基本思路：</p>
<ol>
<li>划分子网纯属一个单位内部的事情，单位对外仍然表现为没有划分子网的网络。</li>
<li>划分子网的方法是从主机号借用若干个位作为子网号。</li>
<li>路由器在收到IP数据报后，按目标网络号和子网号定位目标子网</li>
</ol>
</li>
<li><p>子网掩码<br>子网掩码是一个网络或一个子网的重要属性</p>
</li>
</ol>
<blockquote>
<p>这里要会已知IP地址，子网掩码，求网络地址</p>
</blockquote>
<h3 id="4-3-构造超网（无分类编址CIDR）"><a href="#4-3-构造超网（无分类编址CIDR）" class="headerlink" title="4.3 构造超网（无分类编址CIDR）"></a>4.3 构造超网（无分类编址CIDR）</h3><ol>
<li><p><strong>CIDR（无分类域间路由选择）</strong>的主要特点：</p>
<ul>
<li>CIDR消除了传统的A、B、C类地址以及划分子网的概念，用<strong>网络前缀</strong>代替网络号和子网号，后面的部分指明主机。因此，CIDR使IP地址从三级编址(使用子网掩码)，又回到了两级编址，但这已是无分类的两级编址。</li>
<li>CIDR把网络前缀相同的连续的IP地址组成一个”CIDR地址块”只要知道CIDR地址块中的任何一个地址，就可以知道这地址块的起始地址(即最小地址)和最大地址，以及地址块中的地址数。</li>
</ul>
</li>
<li><p>地址掩码：是一连串的1和0组成，而1的个数救赎网络前缀长度。在斜线记法中。斜线后面的数字就是地址掩码中1的个数。</p>
</li>
<li><p>构成超网：由于一个CIDR地址块中含有很多地址，所以在路由表中就利用CIDR地址块来查找目标网络，这种地址的聚合常称为路由聚合，也称构成超网。</p>
</li>
</ol>
<h3 id="4-4-网际控制报文协议ICMP"><a href="#4-4-网际控制报文协议ICMP" class="headerlink" title="4.4 网际控制报文协议ICMP"></a>4.4 网际控制报文协议ICMP</h3><p>为了更有效地转发IP数据报和提高交付成功的机会，在网际层使用了ICMP，ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告。</p>
<ol>
<li><p>ICMP报文的种类</p>
<ul>
<li>ICMP差错报告报文</li>
<li>ICMP询问报文</li>
</ul>
</li>
<li><p>ICMP 差错报告报文共有 5 种：</p>
<ul>
<li>终点不可达</li>
<li>源点抑制(Source quench)</li>
<li>时间超过</li>
<li>参数问题</li>
<li>改变路由（重定向）(Redirect)</li>
</ul>
</li>
<li><p>ICMP 询问报文有两种：</p>
<ul>
<li>回送请求和回答报文</li>
<li>时间戳请求和回答报文</li>
</ul>
</li>
</ol>
<h3 id="4-5-路由选择协议"><a href="#4-5-路由选择协议" class="headerlink" title="4.5 路由选择协议"></a>4.5 路由选择协议</h3><ol>
<li><p>两大类路由选择协议：</p>
<ul>
<li><strong>内部网关协议 IGP</strong>：一个自治系统内部使用的路由选择协议。有多种协议，如 RIP 和OSPF 协议。</li>
<li><strong>外部网关协议EGP</strong>：一个自治系统的边界，将路由选择信息传递到另一个自治系统中。目前使用的就是BGP</li>
</ul>
<p>RIP协议的优缺点：</p>
<ul>
<li>RIP 存在的一个问题是当网络出现故障时，要经过比较长的时间才能将此信息传送到所有的路由器。</li>
<li>RIP 协议最大的优点就是实现简单，开销较小。</li>
<li>RIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）。</li>
<li>路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。   </li>
</ul>
<blockquote>
<p>书上例题P149 例4-5<br>更新路由表</p>
</blockquote>
</li>
</ol>
<p> RIP是一种分布式的基于距离向量的路由选择协议，其主要特点：<br>（1）仅和相邻路由器交换信息。<br>（3）按固定的时间间隔交换路由信息，例如，每隔30秒。 </p>
<p> OSPF最主要的特征就是使用分布式的链路状态协议，其主要特点：<br>（1）使用洪泛法向本自治系统中所有路由器发送信息。<br>（2）发送的信息是与本路由器相邻的所有路由器的链路状态。<br>（3）只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。 </p>
<p> BGP是不同自治系统的路由器之间交换路由信息的协议，它采用路径向量路由选择协议，其主要特点：<br>（2）自治系统AS之间的路由选择必须考虑有关策略。<br>（3）BGP只能力求寻找一条能够到达目的网络且比较好的路由，而并非要寻找一条最佳路由。</p>
<h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><h3 id="5-1-运输层协议概述"><a href="#5-1-运输层协议概述" class="headerlink" title="5.1 运输层协议概述"></a>5.1 运输层协议概述</h3><ol>
<li><p>运输层功能</p>
<ul>
<li>运输层为应用进程之间提供端到端的逻辑通信（但网络层是为主机之间提供逻辑通信）</li>
<li>运输层还要对收到的报文进行差错检测</li>
<li>运输层需要有两种不同的运输协议，即面向连接的 <strong>TCP</strong> 和无连接的 <strong>UDP</strong></li>
</ul>
</li>
<li><p>运输层的两个主要协议<br>TCP/IP 的运输层有两个不同的协议：</p>
<ul>
<li><strong>用户数据报协议 UDP</strong>(User Datagram Protocol)</li>
<li><strong>传输控制协议 TCP</strong>(Transmission Control Protocol)</li>
</ul>
<p>UDP 在传送数据之前不需要先建立连接。对方的运输层在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 是一种最有效的工作方式。</p>
<p>TCP 则提供面向连接的服务。TCP 不提供广播或多播服务。由于 TCP 要提供可靠的、面向连接的运输服务，因此不可避免地增加了许多的开销。这不仅使协议数据单元的首部增大很多，还要占用许多的处理机资源。  </p>
</li>
</ol>
<p><img src="https://photo.hushhw.cn/images/20180108005811225.jpg" alt></p>
<ol>
<li><p>运输层的端口<br>  TCP/IP的运输层的端口用一个 16 位端口号进行标志</p>
<pre><code>端口号只具备本地意义，即端口号只是为了标志本计算机应用层中的各进程。 
</code></pre><p>客户发起通讯请求时，必须先知道对方服务器的IP地址和端口号，运输层的端口号分为下面三大类：</p>
</li>
</ol>
<ul>
<li><p>熟知端口号，数值一般为 0~1023。<br> 一些常用的数值端口号：<br>  <strong>FTP 21</strong><br>  <strong>LELNET 23</strong><br>  <strong>SMTP 25</strong><br>  <strong>DNS 53</strong><br>  <strong>TFTP 69</strong><br>  <strong>HTTP 80</strong><br>  <strong>SNMP 161</strong><br>  <strong>SNMP(trap) 162</strong></p>
<ul>
<li><p>登记端口号，数值为1024~49151，为没有熟知端口号的应用程序使用的。</p>
</li>
<li><p>客户端口号或短暂端口号，数值为49152~65535，留给客户进程选择暂时使用。</p>
</li>
</ul>
</li>
</ul>
<h3 id="5-2-用户数据报协议-UDP"><a href="#5-2-用户数据报协议-UDP" class="headerlink" title="5.2 用户数据报协议 UDP"></a>5.2 用户数据报协议 UDP</h3><ol>
<li>UDP的主要特点：<ul>
<li><strong>UDP 是无连接的</strong>，即发送数据之前不需要建立连接。</li>
<li><strong>UDP 使用尽最大努力交付</strong>，即不保证可靠交付，同时也不使用拥塞控制</li>
<li><strong>UDP 是面向报文的</strong></li>
<li><strong>UDP 没有拥塞控制</strong>，很适合多媒体通信的要求。</li>
<li><strong>UDP 支持一对一、一对多、多对一和多对多的交互通信</strong></li>
<li><strong>UDP 的首部开销小</strong>，只有 8 个字节</li>
</ul>
</li>
</ol>
<h3 id="5-3-传输控制协议-TCP"><a href="#5-3-传输控制协议-TCP" class="headerlink" title="5.3 传输控制协议 TCP"></a>5.3 传输控制协议 TCP</h3><ol>
<li>TCP的主要特点：<ul>
<li><strong>TCP 是面向连接的运输层协议</strong></li>
<li><strong>每一条 TCP 连接只能有两个端点(endpoint)</strong>，每一条 TCP 连接只能是点对点的（一对一）</li>
<li><strong>TCP 提供可靠交付的服务</strong></li>
<li><strong>TCP 提供全双工通信</strong></li>
<li><strong>面向字节流</strong>  </li>
</ul>
</li>
</ol>
<blockquote>
<p>首发：<a href="https://blog.csdn.net/hushhw/article/details/78985307" target="_blank" rel="noopener">https://blog.csdn.net/hushhw/article/details/78985307</a></p>
</blockquote>
]]></content>
      <categories>
        <category>笔记整理</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>复习笔记</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《WebGL编程指南》学习笔记——4.绘制一个点</title>
    <url>/posts/15b73260.html</url>
    <content><![CDATA[<p>之前，我们学习了如何建立一个WebGL程序，如何使用一些简单的WebGL相关函数。这一节，我们进一步在一个示例程序中绘制一个最简单的图形：一个点以及弄懂一个重要的概念：着色器。</p>
<p>此系列我编写的源码都可以在我的github下载到：<a href="https://github.com/hushhw/WebGL-Programming-Guide/tree/master/02HelloPoint1" target="_blank" rel="noopener">02HelloPoint1</a></p>
<p>​                       </p>
<h2 id="HelloPoint1-html"><a href="#HelloPoint1-html" class="headerlink" title="HelloPoint1.html"></a>HelloPoint1.html</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Draw a point<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"main()"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"webgl"</span> <span class="attr">width</span>=<span class="string">"400"</span> <span class="attr">height</span>=<span class="string">"400"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        Please use the browser supporting "canvas".</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../lib/webgl-utils.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../lib/webgl-debug.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../lib/cuon-utils.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"HelloPoint1.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在HelloCanvas.html文件中比较简单，需要注意的是需要引入一些其他的文件来支持webgl，文件下载可以到<a href="https://github.com/hushhw/WebGL-Programming-Guide/tree/master/lib自行下载。" target="_blank" rel="noopener">https://github.com/hushhw/WebGL-Programming-Guide/tree/master/lib自行下载。</a></p>
<p>​          </p>
<h2 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h2><p>WebGL依赖于一种新的称为着色器（shader）的绘图机制。着色器提供了灵活且强大的绘制二维或三维图形的方法，所有WebGL程序必须使用它。</p>
<p>HelloPoint1.js是这本书中使用着色器的第一个WebGL程序，在代码中，着色器程序是以字符串的形式“嵌入”在JavaScript文件中的，在程序真正开始运行前它已经设置好了。</p>
<p>​           </p>
<p>WebGL需要两种着色器：</p>
<h3 id="1-顶点着色器（-Vertex-shader-）"><a href="#1-顶点着色器（-Vertex-shader-）" class="headerlink" title="1. 顶点着色器（ Vertex shader ）"></a><strong>1. 顶点着色器（ Vertex shader ）</strong></h3><p>顶点着色器是用来描述顶点特性（如位置、颜色等）的程序。<strong>顶点</strong>（vertex）是指二维或三维空间中的一个点，如二维或三维图形的端点或交点。</p>
<p>​            </p>
<h3 id="2-片元着色器（Fragment-shader）"><a href="#2-片元着色器（Fragment-shader）" class="headerlink" title="2.片元着色器（Fragment shader）"></a><strong>2.片元着色器（Fragment shader）</strong></h3><p>片元着色器是进行逐片元处理过程如光照的程序。<strong>片元</strong>（fragment）是一个WebGL术语，你可以将其理解为像素（图像的单元）。</p>
<p>​             </p>
<p>在后续，我们会详细的学习着色器。简单的说，在三维场景中，仅仅用线条和颜色把图形画出来是远远不够的。你必须考虑如光线照上去后，或者观察者的视角发生变化时，对场景会有什么影响。着色器可以高度灵活的完成这些工作；提供各种渲染效果。这也就是现在制作的三维场景如此逼真的原因。</p>
<p><img src="https://photo.hushhw.cn/images/20171224155525787.png" alt></p>
<p>图的左侧是两个浏览器窗口。它们是同一个窗口，上面一个是执行JS程序之前的窗口，下面一个执行之后的。 </p>
<p>程序执行的流程大概是：</p>
<ul>
<li><p>运行JS程序，调用了WebGL的相关方法。 </p>
</li>
<li><p>顶点着色器和片元着色器会执行，在颜色缓冲区内进行绘制，这时就清空了绘图区。</p>
</li>
<li><p>颜色缓冲区中的内容会自动在浏览器的 &lt; canvas &gt;上显示出来。</p>
</li>
</ul>
<p><img src="https://photo.hushhw.cn/images/20171224155749311.png" alt></p>
<p>​             </p>
<h2 id="初始化着色器"><a href="#初始化着色器" class="headerlink" title="初始化着色器"></a>初始化着色器</h2><p>“初始化着色器”我们调用辅助函数initShaders()对字符串形式的着色器进行了初始化。该函数被定义在lib文件夹下，前文提到下载方式了。</p>
<p><img src="https://photo.hushhw.cn/images/20171224161606349.png" alt></p>
<p><img src="https://photo.hushhw.cn/images/20171224161654909.png" alt></p>
<p>Web系统由两部分组成，即顶点着色器和片元着色器。在初始化着色器之前，顶点着色器和片元着色器都是空白的，我们需要将字符串形式的着色器代码从JavaScript传给WebGL系统，并建立着色器，这就是initShaders()函数要做的事情。着色器运行在WebGL系统中，而不是JavaScript程序中。</p>
<p>initShaders()函数执行成功后，着色器被创建好了并随时可以使用，顶点着色器将被首先执行，它对gl_Position变量和gl_PointSize变量进行赋值，并将它们传入片元着色器，然后片元着色器再执行。实际上，片元着色器接收到的是经过光栅化（将几何图形变为二维图像的过程）处理后的片元值；现在可以简单认为这两个变量从顶点着色器传入了片元着色器。</p>
<p>​        </p>
<h2 id="HelloPoint1-js"><a href="#HelloPoint1-js" class="headerlink" title="HelloPoint1.js"></a>HelloPoint1.js</h2><p>回到这个实例中来：示例程序的任务是，在屏幕上绘制一个10像素大小的点 ，它用到了两个着色器：</p>
<ul>
<li><p>顶点着色器指定了点的位置和尺寸。本例中：点的位置是（0.0，0.0，0.0），尺寸是10.0像素</p>
</li>
<li><p>片元着色器指定了点的颜色。本例中，点的颜色是红色（1.0，0.0，0.0，1.0）。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Created by hushhw on 17/12/12.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//HelloPoint1.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点着色器程序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> VSHADER_SOURCE =</span><br><span class="line"></span><br><span class="line">    <span class="string">'void main() &#123;\n'</span> +</span><br><span class="line"></span><br><span class="line">    <span class="string">'gl_Position = vec4(0.5, 0.0, 0.0, 1.0);\n'</span> + <span class="comment">//设置坐标</span></span><br><span class="line"></span><br><span class="line">    <span class="string">'gl_PointSize = 50.0;\n'</span> + <span class="comment">//设置尺寸</span></span><br><span class="line"></span><br><span class="line">    <span class="string">'&#125;\n'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//片元着色器程序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> FSHADER_SOURCE=</span><br><span class="line"></span><br><span class="line">    <span class="string">'void main()&#123;\n'</span>+</span><br><span class="line"></span><br><span class="line">    <span class="string">'gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n'</span>+ <span class="comment">//设置颜色</span></span><br><span class="line"></span><br><span class="line">    <span class="string">'&#125;\n'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'webgl'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> gl = getWebGLContext(canvas);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!gl)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Failed to get the rendering context for WebGL'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化着色器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE))&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Failed to initialize shaders.'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    gl.clearColor(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">    gl.clear(gl.COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    gl.drawArrays(gl.POINTS, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个文件包含三个部分：</p>
<ul>
<li><p>顶点着色器程序（GLSL ES 语言）</p>
</li>
<li><p>片元着色器程序（GLSL ES 语言）</p>
</li>
<li><p>主程序（JavaScript语言）</p>
</li>
</ul>
<p>​           </p>
<h3 id="顶点着色器程序和片元着色器程序"><a href="#顶点着色器程序和片元着色器程序" class="headerlink" title="顶点着色器程序和片元着色器程序"></a>顶点着色器程序和片元着色器程序</h3><p><img src="https://photo.hushhw.cn/images/20171224160348903.png" alt></p>
<p>着色器程序代码必须预先处理成单个字符串的形式，所以我们用+号将多行字符串连成一个长字符串。（每一行以\n结束，这是由于当着色器内部出错时，就能获取出错的行号，这对于检查源代码中的错误很有帮助；但是，\n并不是必须的。为了更容易维护，也可以把着色器代码写到单独的文件中（就像javaScript文件一样），然后通过javaScript程序从文件中读取出来加载。）</p>
<p>就像JS一样，着色器程序使用 = 操作符为变量赋值。首先将点的位置赋值给 gl_Position 变量，然后将点的尺寸赋值给 gl_PointSize 变量，这两个变量是内置在顶点着色器中，而且有特殊含义；gl_Position 表示顶点的位置，gl_PointSize 表示点的尺寸。</p>
<p>在看代码的时候你可能会有疑问，好像在定义顶点着色器时的类型和JS不一样。那是因为GLSL ES是一种强类型的编程语言，也就是说，开发者必须明确指出某个变量是某种“类型”的。 </p>
<p>下面是这一节出现在GLSL ES代码中的几种类型：</p>
<p><img src="https://photo.hushhw.cn/images/20171224162729559.png" alt></p>
<p><em>注意：如果向某类型的变量赋一个不同类型的值。就会出错，例如，gl_PointSize 是浮点型的变量，你就必须向其赋浮点型的值。</em> </p>
<p>在赋值给 gl_Position 时，我们添加了1.0作为第4个分量。由4个分量组成的矢量被称为齐次坐标。因为它能够提高处理三维数据的效率，所以在三维图形中被大量使用。虽然齐次坐标是四维的，但如果其最后一个分量是 1.0，那么这个齐次坐标就可以表示“前三个分量为坐标值”的那各个点。所以，当你需要用齐次坐标表示顶点坐标的时候，只要将最后一个分量赋为 1.0 就可以了。</p>
<p>​          </p>
<h3 id="主程序"><a href="#主程序" class="headerlink" title="主程序"></a>主程序</h3><p><img src="https://photo.hushhw.cn/images/20171224161103636.png" alt></p>
<p>main()函数的执行流程：</p>
<p><img src="https://photo.hushhw.cn/images/20171224161210334.png" alt></p>
<p>这个流程和上一节的区别就是增加了“初始化着色器”和“绘图”部分。</p>
<p>​         </p>
<h4 id="初始化着色器-1"><a href="#初始化着色器-1" class="headerlink" title="初始化着色器"></a>初始化着色器</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//初始化着色器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE))&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Failed to initialize shaders.'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>​      </p>
<h4 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h4><p>首先我们清空绘制区域，然后我们使用 gl.drawArrays(）来进行绘制。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">gl.drawArrays(gl.POINTS, <span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>gl.drawArrays(）是一个强大的函数，它可以用来绘制各种图形：</p>
<p><img src="https://photo.hushhw.cn/images/20171224163102828.png" alt></p>
<p><em>示例函数调用该函数时，因为我么绘制的是单独的点，所以设置第1个参数为 gl.POINTS， 设置第2个参数为0，表示从第1个顶点（虽然只有1个顶点）开始画，第3个参数 count 为1，表示在这个简单的程序中仅绘制了1个点。</em></p>
<p>​        </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一旦顶点着色器执行完后，片元着色器就会开始执行，调用main()函数，将颜色值（红色）赋给gl_FragColor。最后，一个红色的10像素大小的点就被绘制在了（0.0，0.0，0.0，1.0）处，也就是绘制区域的中心位置。</p>
<p><img src="https://photo.hushhw.cn/images/20171224163358200.png" alt></p>
<p>​         </p>
<p>下小节我们介绍坐标系统</p>
<p>​             </p>
<blockquote>
<p>文章内容借鉴于：</p>
<p>《WebGL编程指南》</p>
<p><a href="http://www.cnblogs.com/mirror-pc/p/4181398.html" target="_blank" rel="noopener">http://www.cnblogs.com/mirror-pc/p/4181398.html</a></p>
<p><a href="http://blog.csdn.net/weixin_40282619/article/details/78030629" target="_blank" rel="noopener">http://blog.csdn.net/weixin_40282619/article/details/78030629</a></p>
</blockquote>
]]></content>
      <categories>
        <category>笔记整理</category>
        <category>WebGL</category>
      </categories>
      <tags>
        <tag>WebGL</tag>
      </tags>
  </entry>
  <entry>
    <title>《WebGL编程指南》学习笔记——3.在Canvas中使用WebGL</title>
    <url>/posts/8116aeda.html</url>
    <content><![CDATA[<p>上一节学习了使用 &lt; canvas &gt; 元素绘制二维图形，这一节里面我们在 &lt; canvas &gt; 中使用 WebGL，这一小节中我们通过个实例来讲解在 &lt; canvas &gt; 中使用WebGL，此系列我编写的源码都可以在我的github下载到：<a href="https://github.com/hushhw/WebGL-Programming-Guide/tree/master/01HelloCanvas" target="_blank" rel="noopener">code in github</a> </p>
<p>​           </p>
<h2 id="HelloCanvas-html"><a href="#HelloCanvas-html" class="headerlink" title="HelloCanvas.html"></a>HelloCanvas.html</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>Clear canvas<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"main()"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"webgl"</span> <span class="attr">width</span>=<span class="string">"400"</span> <span class="attr">height</span>=<span class="string">"400"</span>&gt;</span></span><br><span class="line">		Please use the browser supporting "canvas"</span><br><span class="line">	<span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../lib/webgl-utils.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../lib/webgl-debug.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../lib/cuon-utils.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"HelloCanvas.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 HelloCanvas.html 文件中比较简单，需要注意的是需要引入一些其他的文件来支持 webgl ，文件下载可以到<a href="https://github.com/hushhw/WebGL-Programming-Guide/tree/master/lib" target="_blank" rel="noopener">lib</a> 自行下载。</p>
<p>​          </p>
<h2 id="HelloCanvas-js"><a href="#HelloCanvas-js" class="headerlink" title="HelloCanvas.js"></a>HelloCanvas.js</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HelloCanvas.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">//获取&lt;canvas&gt;元素</span></span><br><span class="line">	<span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'webgl'</span>);</span><br><span class="line">	<span class="comment">//获取WebGl绘图上下文</span></span><br><span class="line">	<span class="keyword">var</span> gl = getWebGLContext(canvas);</span><br><span class="line">	<span class="keyword">if</span>(!gl) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'Failed to get the rendering context for WebGL'</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//指定清空&lt;canvas&gt;的颜色</span></span><br><span class="line">	gl.clearColor(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">	<span class="comment">//清空&lt;canvas&gt;</span></span><br><span class="line">	gl.clear(gl.COLOR_BUFFER_BIT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回顾一下上一篇提到的绘制二维图形的三个步骤：</p>
<ul>
<li><p>获取 &lt; canvas &gt; 元素 </p>
</li>
<li><p>获取绘图上下文 </p>
</li>
<li><p>设置 &lt; canvas &gt;颜色</p>
</li>
<li><p>清空&lt; canvas &gt;</p>
</li>
</ul>
<p>在 main() 函数中，我们通过 id 找到&lt; canvas &gt;标签，这里跟绘制 2d 图形的步骤是一模一样的。</p>
<p>​          </p>
<h3 id="获取绘图上下文"><a href="#获取绘图上下文" class="headerlink" title="获取绘图上下文"></a>获取绘图上下文</h3><p>在绘制 2d 图形的时候，我们是通过调用 canvas 的 getContext 方法，传入『2d』参数来获取 2d 图形的回绘图上下文的。</p>
<p>这里需要解释一下，通常来说，我们应该使用 <code>canvas.getContext()</code> 函数来获取绘图上下文（就像之前那样）。但是在获取 WebGL 绘图上下文时，<code>canvas.getContext()</code> 函数接收的参数，在不同浏览器中会不同（虽然大部分浏览器都接收字符串 <code>“expeimental-webgl”</code>或 <code>“webgl”</code> ，但并非所有浏览器都这样），所以我们使用 <code>getWebGLContext(canvas)</code> 来隐藏不同浏览器之间的差异。</p>
<p><code>getWebGLContext(canvas, opt_debug)</code> 函数位于 cuon-utils.js 文件中。</p>
<p><code>getWebGLContext(canvas, opt_debug)</code> 函数的功能是：获取WebGL绘图上下文，如果开启了debug属性，遇到错误时将在控制台显示错误消息。以下是该函数的具体说明：</p>
<p><img src="https://photo.hushhw.cn/images/232358247656436.png" alt></p>
<p>​          </p>
<h3 id="设置-lt-canvas-gt-颜色"><a href="#设置-lt-canvas-gt-颜色" class="headerlink" title="设置 &lt; canvas &gt;颜色"></a>设置 &lt; canvas &gt;颜色</h3><p>在获取到绘图上下文以后，我们就可以绘制图形了，并且可以绘制 3d 图形了；这也说明 WebGL 已经调用成功，我们现在可以使用 WebGL 函数了。</p>
<p>我们将上下文放到名为 gl 的变量中，有了这个上下文，我们就可以设置颜色来清除&lt; canvas &gt;标签指定的绘图区了。在之前绘制2d图形时，我们在绘制之前就指定了绘图颜色。在 WebGL 中是相似的，清空绘图区之前也需要指定颜色。</p>
<p><code>gl.clearColor(RGBA)</code> 函数通过传入 RGBA 格式的颜色参数指定颜色。我们在代码中指定了黑色，也可以随意指定其他颜色。在绘制 2d 图形时，RGBA 每个分量的取值范围是0-255之间，但是在 WebGL 中，每个分量的取值范围是 0-1，这和 OpenGL 保持了一致。一旦指定了颜色，这个颜色就会驻存在 WebGL 系统中，直到你重新指定新的颜色。在这之前，你可以无数次的使用该颜色进行清除绘图区而无须重新指定。</p>
<p>​         </p>
<h3 id="清空-lt-canvas-gt"><a href="#清空-lt-canvas-gt" class="headerlink" title="清空&lt; canvas &gt;"></a>清空&lt; canvas &gt;</h3><p>最后调用这个函数，用之前指定的背景色清空（用背景色填充，擦除已经绘制的内容）绘图区域。</p>
<p>清除绘图区我们使用 <code>gl.clear(gl.COLOR_BUFFER_BIT)</code> 函数，你可能觉得很奇怪，参数不应该是表示绘图区的&lt; canvas &gt;吗？这是由于 <code>gl.Clear()</code> 函数继承自 OpenGL，它基于多基本缓冲区模型，比二维绘图上下文要复杂得多。清空绘图区，实际上是在清空颜色缓冲区（通过指定的颜色去擦除已经绘制的内容），传递 gl.COLOR_BUFFER_BIT 参数就是在告诉 WebGL 清空颜色缓冲区。</p>
<p>如果在使用该函数之前我们没有指定任何颜色，那么默认会以 RGBA(0,0,0,0) 作为清除颜色，这个颜色是全透明的，替换出来的结果就是什么颜色都没有，显示为浏览器本身的颜色。</p>
<p>​         </p>
<p>下小节我们正式开始学习如何使用WebGL绘制基本图形</p>
<p>​        </p>
<blockquote>
<p>文章内容参考自：</p>
<p>《WebGL编程指南》</p>
<p><a href="http://www.cnblogs.com/mirror-pc/p/4181398.html" target="_blank" rel="noopener">http://www.cnblogs.com/mirror-pc/p/4181398.html</a></p>
<p><a href="http://blog.csdn.net/weixin_40282619/article/details/78030629" target="_blank" rel="noopener">http://blog.csdn.net/weixin_40282619/article/details/78030629</a></p>
</blockquote>
]]></content>
      <categories>
        <category>笔记整理</category>
        <category>WebGL</category>
      </categories>
      <tags>
        <tag>WebGL</tag>
      </tags>
  </entry>
  <entry>
    <title>《WebGL编程指南》学习笔记——2.使用canvas元素</title>
    <url>/posts/3abb9ed2.html</url>
    <content><![CDATA[<p>上一节初步认识了 WebGL，这一小节我们来开始学习使用 &lt; canvas &gt; 元素绘制二维图形。WebGL 采用 HTML5 中新引入的 &lt; canvas &gt; 元素，它定义了网页上的绘图区域，如果没有 WebGL，JS 只能在 &lt; canvas &gt; 上绘制二维图形，有了 WebGL 就可以在上面绘制三维图形了。</p>
<p>​         </p>
<h2 id="认识-lt-canvas-gt-标签"><a href="#认识-lt-canvas-gt-标签" class="headerlink" title="认识&lt; canvas &gt;标签"></a>认识&lt; canvas &gt;标签</h2><p>HTML5 出现以前，如果你想在网页上显示图像，只能使用 HTML 提供的原生方案 &lt; img &gt; 标签，用这个标签显示图像虽然简单，但只能显示静态的图片，不能进行实时绘制和渲染。后来出现了一些第三方解决方案，如 Flash Player 等。而 HTML5 的出现改变了一切，它引入了 &lt; canvas &gt; 标签，允许 JS 动态地绘制图形。</p>
<p>艺术家们将画布（ canvas 译为”画布”）作为绘画的地方，类似地，&lt; canvas &gt; 标签定义了网页上的绘图区域。有了 &lt; canvas &gt;，你就可以使用 JS 绘制任何你想画的东西。&lt; canvas &gt; 提供一些简单的绘图函数，用来描绘点、线、矩形、圆等。</p>
<p>​           </p>
<h2 id="使用-lt-canvas-gt-标签"><a href="#使用-lt-canvas-gt-标签" class="headerlink" title="使用&lt; canvas &gt; 标签"></a>使用&lt; canvas &gt; 标签</h2><p>为了在&lt; canvas &gt;上绘制二维图形，需经过以下几个步骤：</p>
<ul>
<li><p>创建 &lt; canvas &gt; 标签，指定绘图范围。</p>
</li>
<li><p>利用JavaScript获取到 &lt; canvas &gt; 标签。</p>
</li>
<li><p>向该标签请求二维图形的“绘图上下文”。</p>
</li>
<li><p>使用绘图上下文调用相应的绘图函数，绘制二维图形。</p>
</li>
</ul>
<p>​             </p>
<h2 id="HelloCanvas2d-实例"><a href="#HelloCanvas2d-实例" class="headerlink" title="HelloCanvas2d 实例"></a>HelloCanvas2d 实例</h2><p>下面是 HelloCanvas2d 实例，我们利用 &lt; canvas &gt; 画个矩形，并用红色填充。</p>
<p>此系列我编写的源码都可以在我的github下载到：<a href="https://github.com/hushhw/WebGL-Programming-Guide/tree/master/00HelloCanvas2d" target="_blank" rel="noopener">code in github</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>Clear canvas<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"main()"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"mycanvas"</span> <span class="attr">width</span>=<span class="string">"400"</span> <span class="attr">height</span>=<span class="string">"400"</span>&gt;</span></span><br><span class="line">		Please use the browser supporting "canvas"</span><br><span class="line">	<span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"HelloCanvas2d.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//HelloCanvas2d.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">//获取&lt;canvas&gt;标签</span></span><br><span class="line">	<span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">"mycanvas"</span>);</span><br><span class="line">	<span class="comment">//如果没找到&lt;canvas&gt;标签，则输出错误信息</span></span><br><span class="line">	<span class="keyword">if</span> (!canvas) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'Failed to retrieve the &lt;canvas&gt; element.'</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//要在&lt;canvas&gt;上绘制图像，须先获取绘图上下文，“2d”代表我们要绘制二维图形。</span></span><br><span class="line">	<span class="keyword">var</span> ctx = canvas.getContext(<span class="string">"2d"</span>);</span><br><span class="line">	<span class="comment">//fillstyle：设置或返回用于填充绘画的颜色、渐变或模式；这里我们设置填充颜色为红色。</span></span><br><span class="line">	ctx.fillStyle = <span class="string">"red"</span>;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 使用填充颜色填充矩形。</span></span><br><span class="line"><span class="comment">	 fillRect(x,y,width,height)</span></span><br><span class="line"><span class="comment">	 x    矩形左上角的 x 坐标</span></span><br><span class="line"><span class="comment">	 y    矩形左上角的 y 坐标</span></span><br><span class="line"><span class="comment">	 width        矩形的宽度</span></span><br><span class="line"><span class="comment">	 height   矩形的高度</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ctx.fillRect(<span class="number">120</span>, <span class="number">10</span>, <span class="number">150</span>, <span class="number">150</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        </p>
<h3 id="获取-lt-canvas-gt-元素"><a href="#获取-lt-canvas-gt-元素" class="headerlink" title="获取&lt; canvas &gt;元素"></a>获取&lt; canvas &gt;元素</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取&lt;canvas&gt;标签</span></span><br><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">"mycanvas"</span>);</span><br><span class="line"><span class="comment">//如果没找到&lt;canvas&gt;标签，则输出错误信息</span></span><br><span class="line"><span class="keyword">if</span> (!canvas) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'Failed to retrieve the &lt;canvas&gt; element.'</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在HTML文件中通过 JS 程序获取 &lt; canvas &gt; 元素。可以使用 document.getElementById() 的函数来获取。这个方法只有一个参数，就是HTML文件中&lt; canvas &gt;标签的 id 属性</p>
<p>　　 </p>
<h3 id="通过元素来获取二维图形的绘图上下文"><a href="#通过元素来获取二维图形的绘图上下文" class="headerlink" title="通过元素来获取二维图形的绘图上下文"></a>通过元素来获取二维图形的绘图上下文</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//要在&lt;canvas&gt;上绘制图像，须先获取绘图上下文，“2d”代表我们要绘制二维图形。</span></span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">"2d"</span>);</span><br></pre></td></tr></table></figure>
<p>&lt; canvas &gt; 元素可以同时支持二维图形和三维图形，它不直接提供绘图方法，而是提供一种叫<strong>上下文</strong>的机制来绘图。</p>
<p>在上述代码中，canvas.getContext() 方法的参数制订了上下文的类型（二维或三维）。如果你想要绘制二维图形，就必须指定为2d（区分大小写）。</p>
<p>　　</p>
<h3 id="绘制二维图形"><a href="#绘制二维图形" class="headerlink" title="绘制二维图形"></a>绘制二维图形</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//fillstyle：设置或返回用于填充绘画的颜色、渐变或模式；这里我们设置填充颜色为红色。</span></span><br><span class="line">	ctx.fillStyle = <span class="string">"red"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	 使用填充颜色填充矩形。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	 fillRect(x,y,width,height)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	 x    矩形左上角的 x 坐标</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	 y    矩形左上角的 y 坐标</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	 width        矩形的宽度</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	 height   矩形的高度</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	ctx.fillRect(<span class="number">120</span>, <span class="number">10</span>, <span class="number">150</span>, <span class="number">150</span>);</span><br></pre></td></tr></table></figure>
<p>&lt; canvas &gt; 的坐标系横轴为 x 轴（正方向朝右），纵轴为 y 轴（正方向朝下）。原点（0，0）在左上方。</p>
<p>fillRect 方法中设置的 x，y 指的是从 &lt; canvas &gt; 坐标的开始算，右移 x 像素，下移 y 像素的位置，就是矩形左上角的位置。如图所示：</p>
<p><img src="https://photo.hushhw.cn/images/20171216202917965.png" alt></p>
<p>　　</p>
<p>下小节我们正式开始学习如何在&lt; canvas &gt;中使用 WebGL</p>
<p>​        </p>
<blockquote>
<p>文章内容参考自： </p>
<p>Kouichi Matsuda, Rodger Lea. 《WebGL编程指南》</p>
<p><a href="http://www.cnblogs.com/mirror-pc/p/4179062.html" target="_blank" rel="noopener">http://www.cnblogs.com/mirror-pc/p/4179062.html</a></p>
<p><a href="http://blog.csdn.net/weixin_40282619/article/details/78019085" target="_blank" rel="noopener">http://blog.csdn.net/weixin_40282619/article/details/78019085</a></p>
</blockquote>
]]></content>
      <categories>
        <category>笔记整理</category>
        <category>WebGL</category>
      </categories>
      <tags>
        <tag>WebGL</tag>
      </tags>
  </entry>
  <entry>
    <title>《WebGL编程指南》学习笔记——1.WebGL概述</title>
    <url>/posts/18614.html</url>
    <content><![CDATA[<blockquote>
<p> <strong>此系列用来记录我学习《WebGL编程指南》这本书后的心得，重点内容和总结</strong></p>
</blockquote>
<h2 id="WebGL概述"><a href="#WebGL概述" class="headerlink" title="WebGL概述"></a>WebGL概述</h2><p>WebGL 是一项用来在网页上绘制和渲染复杂三维图形（3D 图形），并允许用户与之交互的技术。随着个人计算机和浏览器的性能越来越强，我们能够在 Web 上创建越来越精美、越来越复杂的3D图形。<a href="http://webglsamples.org/" target="_blank" rel="noopener">http://webglsamples.org/</a> 这个网址展示了Google发布的一些示例 WebGL 程序，在惊叹美轮美奂的效果的同时，我们发现发布和运行也变得非常简单。</p>
<p>从传统意义上来说，为了显示三维图形，开发者需要使用 C 或 C++ 语言，辅以专门的计算机图形库，如 OpenGL 或 Direct3D 来开发一个独立的应用程序，现在有了 WebGL 我们只需要向已经熟悉的 HTML 和 JS 中添加一些额外的三维图形学的代码，就可以在网页上显示三维图形了。</p>
<p>WebGL 是内嵌在浏览器中的，你不必安装插件和库就可以直接使用它。而且，因为它是基于浏览器的，你可以在多种平台上运行 WebGL 程序，而且使用起来有诸多便利点：</p>
<ul>
<li><p>你只需要一个<strong>文本编辑器</strong>和一个<strong>浏览器</strong>，就可以开始编写三维图形程序了。</p>
</li>
<li><p>你可以使用通用的 Web 技术发布三维图形程序，展示给你的朋友和其他开发者</p>
</li>
<li><p>你可以充分利用浏览器的功能</p>
</li>
<li><p>互联网上有大量现成的资料，它们可以帮助你学习 WebGL ，编写三维程序等。</p>
</li>
</ul>
<p>​              </p>
<h2 id="WebGL起源"><a href="#WebGL起源" class="headerlink" title="WebGL起源"></a>WebGL起源</h2><p>在个人计算机上使用最广泛的两种三维图形渲染技术是 <strong>Direct3D</strong> 和 <strong>OpenGL</strong>。</p>
<p>Direct3D 是微软 DirectX 技术的一部分，是一套由微软控制的编程接口 API ，主要用在 Windows 平台。 </p>
<p>OpenGL 由于其开发和免费的特性，在多种平台上都有广泛的使用。Windows 对 OpenGL 也提供了良好的支持，开发者也可以用它来代替 Direct3D。</p>
<p>OpenGL 最初由 SGI 开发，并在 1992 年发布为开源标准。多年以来，OpenGL 发展了数个版本，并对三维图形开发，软件产品开发，甚至电影制作产生了深远影响。 </p>
<p>虽然 WebGL 根植于 OpenGL ，但它实际上是从 OpenGL 的一个特殊版本 OpenGL ES 中派生出来的，后者专用于嵌入式计算机、智能手机、家用游戏机等设备。OpenGL ES 于 2003 - 2004 年被首次提出，并在 2007 年（ES 2.0）和 2012 年（ES 3.0）进行了两次升级，<strong>WebGL 是基于 OpenGL ES 2.0 的</strong>。</p>
<p>下图显示了OpenGL、OpenGL ES 1.1/2.0/3.0和WebGL的关系。 </p>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-03-05_09-37-29.png" alt></p>
<p>从 2.0 版本开始，OpenGL 支持了一项非常重要的特性，即<strong>可编程着色器方法</strong>。该特性被 OpenGL ES 2.0 继承，并成为了 WebGL 1.0 标准的核心部分。</p>
<p>着色器使用一种类似于 C 的编程语言实现了精美的视觉效果，编写着色器的语言又称为<strong>着色器语言</strong>。WebGL 基于OpenGL ES 2.0，使用 GLSL ES 语言编写着色器。</p>
<p>虽然 WebGL 强大到令人惊叹，但使用这项技术进行开发却异常简单：只需要一个文本编辑器（Notepad 或 TextEdit）和一个浏览器（Chrome）即可，并且不需要去搭建开发环境，因为 WebGL 是内嵌在浏览器中的。</p>
<p>下图显示了WebGL程序的结构：</p>
<p><img src="https://photo.hushhw.cn/images/Snipaste_2019-03-05_09-37-53.png" alt></p>
<p>由于 GLSL ES 通常是以字符串的形式在 JavaScript 中编写的，所以虽然 WebGL 网页更加复杂，但它仍然保持着与传统的动态网页相同的结构：只用到HTML文件和JavaScript文件。</p>
<p>　　</p>
<blockquote>
<p>文章内容借鉴于：<br>《WebGL编程指南》<br> <a href="https://www.cnblogs.com/mirror-pc/p/4178897.html" target="_blank" rel="noopener">https://www.cnblogs.com/mirror-pc/p/4178897.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>笔记整理</category>
        <category>WebGL</category>
      </categories>
      <tags>
        <tag>WebGL</tag>
      </tags>
  </entry>
</search>
